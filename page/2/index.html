<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Sky的博客">
<meta property="og:url" content="http://coderzhou.com/page/2/index.html">
<meta property="og:site_name" content="Sky的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sky的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coderzhou.com/page/2/"/>

  <title> Sky的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sky的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一枚小小的程序猿，专注于iOS开发</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/Runtime学习之一：类与对象/" itemprop="url">
                  Runtime学习之一：类与对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-08T13:49:52+08:00" content="2017-03-08">
              2017-03-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/08/Runtime学习之一：类与对象/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/08/Runtime学习之一：类与对象/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/03/08/Runtime学习之一：类与对象/" class="leancloud_visitors" data-flag-title="Runtime学习之一：类与对象">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着 iOS开发的深入，必须要了解一些底层的东西才能算上高级iOS开发工程师，比如 Runtime，Roonloop之类的。以前都是零碎的看过网上的文章，接下来就系统整理一下，也算是对记忆的加深。</p>
<p>###简介<br>Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。</p>
<p>Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。</p>
<p>开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。</p>
<p>我们可以通过<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">这里</a>来下载Runtime源码</p>
<p>通过源码我们可以看到，NSObject定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSObject &lt;NSObject&gt; &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这个<code>Class</code>又是什么呢？我们点进去可以看一下，是一个objc_class类型的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div><div class="line">typedef struct objc_object *id;</div></pre></td></tr></table></figure>
<p>到这里我们来看一下，Runtime里面Class和Object基础数据结构，objc/runtime.h中objc_class结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">Class super_class OBJC2_UNAVAILABLE; // 父类</div><div class="line">const char *name OBJC2_UNAVAILABLE; // 类名</div><div class="line">long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0</div><div class="line">long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识</div><div class="line">long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小</div><div class="line">struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表</div><div class="line">struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表</div><div class="line">struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在methodLists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</div><div class="line">struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>此时注意，带有<code>OBJC2_UNAVAILABLE</code>标记的表示已经废弃，其实早在 2006 年，苹果在 WWDC 大会上就发布了 Objective-C 2.0，其中的改动包括 Max OS X 平台上的垃圾回收机制(现已废弃)，runtime 性能优化等。所以说，以上只是老版的objc_class结构体定义，现在我们看下新的结构体信息是怎么样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    // Class ISA;</div><div class="line">    Class superclass; //父类的指针</div><div class="line">    cache_t cache;   // 方法缓存          // formerly cache pointer and vtable</div><div class="line">    class_data_bits_t bits;  //实例方法列表  // class_rw_t * plus custom rr/alloc flags</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出objc_class是继承自objc_object的，本质上,类是一个对象,这也就是我们通常会说的’类对象’的缘由.<br>其中objc_object有一个唯一的私有变量 - isa_t类型的isa指针，所以objc_class也有这个指针。</p>
<p>当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_data_bits_t中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。</p>
<p>但是在我们调用类方法的时候，类对象的isa里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念，即：</p>
<p>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。<br>类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/ObjectAndClass.png" alt="image"></p>
<p>上图实线是super_class指针，虚线是isa指针，我们可以看出</p>
<ol>
<li>Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil</li>
<li>每个Class都有一个isa指针指向唯一的Meta class</li>
<li>Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路</li>
<li>每个Meta class的isa指针都指向Root class (meta)</li>
</ol>
<h4 id="1-isa-t-isa"><a href="#1-isa-t-isa" class="headerlink" title="1.isa_t isa"></a>1.isa_t isa</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">union isa_t </div><div class="line">&#123;</div><div class="line">    isa_t() &#123; &#125;</div><div class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class="line"></div><div class="line">    Class cls;</div><div class="line">    uintptr_t bits;</div><div class="line"></div><div class="line"># if __arm64__</div><div class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</div><div class="line">    struct &#123;</div><div class="line">        uintptr_t nonpointer        : 1;</div><div class="line">        uintptr_t has_assoc         : 1;//对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</div><div class="line">        uintptr_t has_cxx_dtor      : 1;//析构器方法,如果没有析构器就会快速释放内存</div><div class="line">        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000</div><div class="line">        uintptr_t magic             : 6;//用于调试器判断当前对象是真的对象还是没有初始化的空间</div><div class="line">        uintptr_t weakly_referenced : 1;//对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</div><div class="line">        uintptr_t deallocating      : 1;//对象正在释放内存</div><div class="line">        uintptr_t has_sidetable_rc  : 1;//对象的引用计数太大了，存不下</div><div class="line">        uintptr_t extra_rc          : 19;//对象的引用计数超过 1，会存在这个这个里面</div><div class="line">#       define RC_ONE   (1ULL&lt;&lt;45)</div><div class="line">#       define RC_HALF  (1ULL&lt;&lt;18)</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"># elif __x86_64__</div><div class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</div><div class="line">    struct &#123;</div><div class="line">        uintptr_t nonpointer        : 1;</div><div class="line">        uintptr_t has_assoc         : 1;</div><div class="line">        uintptr_t has_cxx_dtor      : 1;</div><div class="line">        uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000</div><div class="line">        uintptr_t magic             : 6;</div><div class="line">        uintptr_t weakly_referenced : 1;</div><div class="line">        uintptr_t deallocating      : 1;</div><div class="line">        uintptr_t has_sidetable_rc  : 1;</div><div class="line">        uintptr_t extra_rc          : 8;</div><div class="line">#       define RC_ONE   (1ULL&lt;&lt;56)</div><div class="line">#       define RC_HALF  (1ULL&lt;&lt;7)</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"># else</div><div class="line">#   error unknown architecture for packed isa</div><div class="line"># endif</div><div class="line"></div><div class="line">// SUPPORT_PACKED_ISA</div><div class="line">#endif</div><div class="line"></div><div class="line"></div><div class="line">#if SUPPORT_INDEXED_ISA</div><div class="line"></div><div class="line"># if  __ARM_ARCH_7K__ &gt;= 2</div><div class="line"></div><div class="line">#   define ISA_INDEX_IS_NPI      1</div><div class="line">#   define ISA_INDEX_MASK        0x0001FFFC</div><div class="line">#   define ISA_INDEX_SHIFT       2</div><div class="line">#   define ISA_INDEX_BITS        15</div><div class="line">#   define ISA_INDEX_COUNT       (1 &lt;&lt; ISA_INDEX_BITS)</div><div class="line">#   define ISA_INDEX_MAGIC_MASK  0x001E0001</div><div class="line">#   define ISA_INDEX_MAGIC_VALUE 0x001C0001</div><div class="line">    struct &#123;</div><div class="line">        uintptr_t nonpointer        : 1;</div><div class="line">        uintptr_t has_assoc         : 1;</div><div class="line">        uintptr_t indexcls          : 15;</div><div class="line">        uintptr_t magic             : 4;</div><div class="line">        uintptr_t has_cxx_dtor      : 1;</div><div class="line">        uintptr_t weakly_referenced : 1;</div><div class="line">        uintptr_t deallocating      : 1;</div><div class="line">        uintptr_t has_sidetable_rc  : 1;</div><div class="line">        uintptr_t extra_rc          : 7;</div><div class="line">#       define RC_ONE   (1ULL&lt;&lt;25)</div><div class="line">#       define RC_HALF  (1ULL&lt;&lt;6)</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"># else</div><div class="line">#   error unknown architecture for indexed isa</div><div class="line"># endif</div><div class="line"></div><div class="line">// SUPPORT_INDEXED_ISA</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>看到isa指针是一个联合体，它在在 <strong>x86_64</strong> 上的实现 和 在<strong>arm64</strong> 的设备可能有些差别，不过这些字段都是存在的</p>
<p>其中</p>
<p>SUPPORT_INDEXED_ISA,文档注释Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa  field as an index into a class table.,也就是当该属性为真,则把该类存储在isa中,作为全局class表的索引();</p>
<p>nonpointer为1,表示使用优化的isa指针,包含了引用计数,析构状态等.</p>
<p>has_assoc,是否包含关联对象,如果没有,会更快的释放内存;</p>
<p>has_cxx_dtor,是否包含析构函数,如果没有,会更快的释放内存;</p>
<p>shiftcls,类的指针;</p>
<p>magic,固定值,用于判断是否完成初始化;</p>
<p>weakly_referenced,对象是否指向一个弱引用对象,没有弱引用对象可以更快的被释放;</p>
<p>deallocating,对象是否正在销毁;</p>
<p>has_sidetable_rc,是否有sidetable(散列表),如果为真,则引用计数存储在该散列表中;</p>
<p>extra_rc,存储引用计数,比真实的引用计数少1.</p>
<h4 id="2-cache-t的具体实现"><a href="#2-cache-t的具体实现" class="headerlink" title="2.cache_t的具体实现"></a>2.cache_t的具体实现</h4><p>Cache的作用主要是为了优化方法调用的性能。如果每发送一个消息都需要去方法表中去查找，当方法很多的时候，查找是很耗力的，并且当 存在继承关系的时候，一个方法的查找链可能会很长。那么对使用过的方法进行缓存，便于第二次查找。我们看下源码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct cache_t &#123;</div><div class="line">    struct bucket_t *_buckets;</div><div class="line">    mask_t _mask;</div><div class="line">    mask_t _occupied;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而bucket_t 结构体，mask_t分别是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct bucket_t &#123;</div><div class="line">private:</div><div class="line">    cache_key_t _key;</div><div class="line">    IMP _imp;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> typedef uint32_t mask_t</div><div class="line"> typedef uintptr_t cache_key_t</div></pre></td></tr></table></figure>
<p>_buckets是一个散列表，用来方法缓存，bucket_t的结构体中存储了一个IMP，MP是一个函数指针，指向了一个方法的具体实现。</p>
<p>mask表示缓存bucket的总数。</p>
<p>occupied表明目前实际占用的缓存bucket的个数。</p>
<h4 id="3-class-data-bits-t-bits"><a href="#3-class-data-bits-t-bits" class="headerlink" title="3.class_data_bits_t bits"></a>3.class_data_bits_t bits</h4><p>bits 就是存储类的方法、属性、遵循的协议等信息的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct class_data_bits_t &#123;</div><div class="line">    // Values are the FAST_ flags above.</div><div class="line">    uintptr_t bits;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>由此可以看出ObjC 中 class_data_bits_t 的结构体，其中只含有一个 64 位的 bits 用于存储与类有关的信息，而在在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>那么这个class_rw_t又是什么呢？源码里面也为我们提供了方法返回该类型的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class_rw_t* data() &#123;</div><div class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>ObjC 类中的属性、方法还有遵循的协议等信息都保存在 class_rw_t 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct class_rw_t &#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t version;</div><div class="line"></div><div class="line">    const class_ro_t *ro;</div><div class="line"></div><div class="line">    method_array_t methods;</div><div class="line">    property_array_t properties;</div><div class="line">    protocol_array_t protocols;</div><div class="line"></div><div class="line">    Class firstSubclass;</div><div class="line">    Class nextSiblingClass;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中还有一个指向常量的指针 ro，其中存储了当前类在编译期就已经确定的属性、方法以及遵循的协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct class_ro_t &#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t instanceStart;</div><div class="line">    uint32_t instanceSize;</div><div class="line">    uint32_t reserved;</div><div class="line"></div><div class="line">    const uint8_t * ivarLayout;</div><div class="line"></div><div class="line">    const char * name;</div><div class="line">    method_list_t * baseMethodList;</div><div class="line">    protocol_list_t * baseProtocols;</div><div class="line">    const ivar_list_t * ivars;</div><div class="line"></div><div class="line">    const uint8_t * weakIvarLayout;</div><div class="line">    property_list_t *baseProperties;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在编译期间类的结构中的 class_data_bits_t <em>data 指向的是一个 class_ro_t </em> 指针。</p>
<p>总之就是，class_rw_t<em> data,存储该类方法属性协议等相关内容的指针,该结构体包含一个const class_ro_t </em>ro只读属性ro,ro中存储类在编译阶段就存在的方法属性协议等,因此当在运行时向类添加方法,那么改变的是class_rw_t类型的rw中的方法列表,而不是class_ro_t类型的ro的列表(rw即读写,ro即只读).<br>关于更详细的ObjC 中方法的结构，大家可以看<a href="http://www.jianshu.com/p/d7a60fc7b0a1" target="_blank" rel="external">这篇文章</a></p>
<p>这篇文章只是介绍了Runtime中的类与对象，接下来还会介绍Runtime对于消息是怎么处理的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/22/iOS事件的传递与响应/" itemprop="url">
                  iOS事件的传递与响应
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-22T15:19:03+08:00" content="2016-08-22">
              2016-08-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/22/iOS事件的传递与响应/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/22/iOS事件的传递与响应/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/22/iOS事件的传递与响应/" class="leancloud_visitors" data-flag-title="iOS事件的传递与响应">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在iOS中，能够响应事件的对象都是UIResponder的子类对象。UIResponder提供了四个用户点击的回调方法，分别对应用户点击开始、移动、点击结束以及取消点击。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesCancelled:(nullable NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div></pre></td></tr></table></figure>
<p>点击一个 UIView 或产生一个触摸事件，首先接收事件的是 UIApplication，UIApplication 把这个事件添加到管理的事件队列中，那么这个事件是怎么找到合适的 view 去处理事件呢？</p>
<h3 id="一、事件的传递"><a href="#一、事件的传递" class="headerlink" title="一、事件的传递"></a>一、事件的传递</h3><p>UIView 是如何判定这个事件是否是自己应该处理的呢？iOS 系统检测到一个触摸操作时会打包一个UIEvent 对象，并放入 Application 的队列，Application 从队列中取出事件后交给 UIWindow 来处理，UIWindow 会使用 hitTest:withEvent: 方法来递归的寻找操作初始点所在的 view，这个过程成为 hit-test view。</p>
<ol>
<li><p>调用当前 view 的 pointInside:withEvent: 方法来判定触摸点是否在当前view内部</p>
</li>
<li><p>如果返回 NO,则 hitTest:withEvent: 返回 nil，如果返回 YES,向当前 view 内的subViews 发送 hitTest:withEvent: 消息</p>
</li>
<li><p>如此循环遍历子控件，直到找到最合适的 view，如果没有更合适的子控件，那么自己就成为最合适的 view。</p>
</li>
</ol>
<p>注意，当 view 的 userInteractionEnabled = NO 或 view.hidden = YES 或 view 为透明，是不能接收触摸事件的，如果父控件不能接收触摸事件，那么子控件也不能收到触摸事件。<br>遍历子控件的顺序，是从最层级从高到低的顺序，即最顶层的 SubView 开始遍历，一旦有视图可以接收此次事件，就不会再往下遍历。下面通过代码来验证一下：</p>
<p>新建一个类，MyView，继承自 UIView,定义一个属性 name;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface MyView : UIView</div><div class="line">@property (nonatomic,copy)NSString *name;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#import &quot;MyView.h&quot;</div><div class="line"></div><div class="line">@implementation MyView</div><div class="line"></div><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;hitTest %@ 进入 event=%p&quot;, self.name, event);</div><div class="line">    UIView *view =  [super hitTest:point withEvent:event];</div><div class="line">    NSLog(@&quot;hitTest %@ 退出 event=%p&quot;, self.name, event);</div><div class="line">    return view;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    BOOL ret = [super pointInside:point withEvent:event];</div><div class="line">    if (ret) &#123;</div><div class="line">        NSLog(@&quot;pointInside %@ = YES&quot;, self.name);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;pointInside %@ = NO&quot;, self.name);</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;处理事件的view为:%@&quot;,self.name);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在 ViewController 中分别实例化 MyView 的对象,superView，viewA,viewB,viewC,viewD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">MyView *superView = [[MyView alloc] initWithFrame:CGRectMake(50, 100, 250, 450)];</div><div class="line">superView.name = @&quot;superView&quot;;</div><div class="line">superView.backgroundColor = [UIColor grayColor];</div><div class="line">[self.view addSubview:superView];</div><div class="line"></div><div class="line">MyView *viewA =[[MyView alloc] initWithFrame:CGRectMake(25, 80, 200, 100)];</div><div class="line">viewA.name = @&quot;viewA&quot;;</div><div class="line">viewA.backgroundColor = [UIColor cyanColor];</div><div class="line">[superView addSubview:viewA];</div><div class="line"></div><div class="line">MyView *viewB =[[MyView alloc] initWithFrame:CGRectMake(25, 200, 200, 220)];</div><div class="line">viewB.name = @&quot;viewB&quot;;</div><div class="line">viewB.backgroundColor = [UIColor orangeColor];</div><div class="line">[superView addSubview:viewB];</div><div class="line"></div><div class="line">MyView *viewC =[[MyView alloc] initWithFrame:CGRectMake(25, 40, 150, 80)];</div><div class="line">viewC.name = @&quot;viewC&quot;;</div><div class="line">viewC.backgroundColor = [UIColor blueColor];</div><div class="line">[viewB addSubview:viewC];</div><div class="line"></div><div class="line">MyView *viewD =[[MyView alloc] initWithFrame:CGRectMake(25, 130, 150, 80)];</div><div class="line">viewD.name = @&quot;viewD&quot;;</div><div class="line">viewD.backgroundColor = [UIColor greenColor];</div><div class="line">[viewB addSubview:viewD];</div></pre></td></tr></table></figure>
<p>viewA 和 viewB 为 superView 的子视图，viewC 和 viewD 为 viewB 的子视图,运行后，视图为：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/hitTest.png" alt="image"></p>
<p>当我点击 viewC 时，控制台输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">2016-08-22 17:46:15.273 EventDemo[3268:357205] hitTest superView 进入 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.274 EventDemo[3268:357205] pointInside superView = YES</div><div class="line">2016-08-22 17:46:15.274 EventDemo[3268:357205] hitTest viewB 进入 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.274 EventDemo[3268:357205] pointInside viewB = YES</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] hitTest viewD 进入 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] pointInside viewD = NO</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] hitTest viewD 退出 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] hitTest viewC 进入 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] pointInside viewC = YES</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] hitTest viewC 退出 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.276 EventDemo[3268:357205] hitTest viewB 退出 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.276 EventDemo[3268:357205] hitTest superView 退出 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.279 EventDemo[3268:357205] 处理事件的view为:viewC</div></pre></td></tr></table></figure>
<p>由控制台输出可以看出，的确是一层一层遍历子视图，最后找到处理视图 viewC。这里为什么没有遍历 viewA 呢，正如上面所说的，遍历顺序是从 superView 的最上层子视图，即 viewB 开始的。viewC 和 viewD 作为 viewB 的子视图，viewD 后添加到 viewB 上，先遍历 viewD 。</p>
<h3 id="二、事件的响应"><a href="#二、事件的响应" class="headerlink" title="二、事件的响应"></a>二、事件的响应</h3><p>先看下官方给的图：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/hitappleaggin.png" alt="image"></p>
<ol>
<li><p>事件顺着responder chain传递，如果一环不处理，则传递到下一环</p>
</li>
<li><p>view 的下一级是包含它的 viewController，如果没有 viewController 则是它的 superView</p>
</li>
<li><p>viewController 的下一级是它的 view 的 superView</p>
</li>
<li><p>view 之后是 window，最后传给 application，如果都没有处理，最后回到UIApplication，再不处理就会抛弃</p>
</li>
</ol>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>1、当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。</p>
<p>2、事件的响应，首先看initial view能否处理这个事件，如果不能则会将事件传递给其上级视图；如果上级视图仍然无法处理则会继续传递；一直到 window，如果window还是不能处理此事件则继续交给application处理，如果最后application还是不能处理此事件则将其丢弃</p>
<p>3、在事件的响应中，如果某个控件实现了touches…方法，则这个事件将由该控件来接受，如果调用了[supertouches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的touches….方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/18/Objective-C Category/" itemprop="url">
                  Objective-C Category
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-18T16:13:04+08:00" content="2016-08-18">
              2016-08-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/18/Objective-C Category/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/18/Objective-C Category/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/18/Objective-C Category/" class="leancloud_visitors" data-flag-title="Objective-C Category">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Category简介"><a href="#Category简介" class="headerlink" title="Category简介"></a>Category简介</h3><p>最近更加深入了学习category，查阅了好多大牛博客，系统的整理一下学习过程。</p>
<p>关于Category的简单介绍，首先摘自官方文档的一句话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">You use categories to define additional methods of an existing class—even one whose source code is unavailable to you—without subclassing. You typically use a category to add methods to an existing class, such as one defined in the Cocoa frameworks. The added methods are inherited by subclasses and are indistinguishable at runtime from the original methods of the class</div><div class="line"></div><div class="line">* Distribute the implementation of your own classes into separate source </div><div class="line">* files—for example, you could group the methods of a large class into several categories and put each category in a different file.</div><div class="line">Declare private methods.</div></pre></td></tr></table></figure>
<p>说的很清楚，当原有的方法不能满足你需要的时候，你可以用category来定义一个自己的方法。使用场景有：</p>
<p>1.给现有的类添加方法</p>
<p>2.将类的实现分开在不同的文件里</p>
<p>3.声明私有方法</p>
<p>接下来将结合 runtime，了解 category 的内部实现原理。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>所有的OC类和对象，在 runtime 层都是用 struct 表示的，category 也不例外，在 runtime层，category 用结构体 category_t 表示，在 objc-runtime-new.h 文件中，我们可以看到关于 category_t 的定义：（ 没有的同学可以在这里下载： <a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">Runtime源码下载</a> ）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">struct category_t &#123;</div><div class="line">    const char *name; //类的名字</div><div class="line">    classref_t cls; //要扩展的类对象</div><div class="line">    struct method_list_t *instanceMethods; //category中所有给类添加的实例方法的列表</div><div class="line">    struct method_list_t *classMethods; //category中所有添加的类方法的列表</div><div class="line">    struct protocol_list_t *protocols; //category实现的所有协议的列表</div><div class="line">    struct property_list_t *instanceProperties; //category中添加的所有属性</div><div class="line"></div><div class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</div><div class="line">        if (isMeta) return classMethods;</div><div class="line">        else return instanceMethods;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    property_list_t *propertiesForMeta(bool isMeta) &#123;</div><div class="line">        if (isMeta) return nil; // classProperties;</div><div class="line">        else return instanceProperties;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们代码中写入 category，它是如何加载的呢，我们继续阅读 runtime源码,对月OC运行时，runtime的加载入口是下面的一个方法，我们 可以在objc-os.mm 文件中看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void _objc_init(void)</div><div class="line">&#123;</div><div class="line">    static bool initialized = false;</div><div class="line">    if (initialized) return;</div><div class="line">    initialized = true;</div><div class="line">    </div><div class="line">    // fixme defer initialization until an objc-using image is found?</div><div class="line">    environ_init();</div><div class="line">    tls_init();</div><div class="line">    static_init();</div><div class="line">    lock_init();</div><div class="line">    exception_init();</div><div class="line">        </div><div class="line">    // Register for unmap first, in case some +load unmaps something</div><div class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</div><div class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,</div><div class="line">                                             1/*batch*/, &amp;map_2_images);</div><div class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>category被附加到类上面是在 map_2_images 的时候发生的,_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，最终 category 的加载方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">void _read_images(header_info **hList, uint32_t hCount)</div><div class="line">&#123;</div><div class="line">  // 其它的加载，在这里省略</div><div class="line">  // Discover categories. </div><div class="line">    for (EACH_HEADER) &#123;</div><div class="line">        category_t **catlist = </div><div class="line">            _getObjc2CategoryList(hi, &amp;count);</div><div class="line">        for (i = 0; i &lt; count; i++) &#123;</div><div class="line">            category_t *cat = catlist[i];</div><div class="line">            Class cls = remapClass(cat-&gt;cls);</div><div class="line"></div><div class="line">            if (!cls) &#123;</div><div class="line">                // Category&apos;s target class is missing (probably weak-linked).</div><div class="line">                // Disavow any knowledge of this category.</div><div class="line">                catlist[i] = nil;</div><div class="line">                if (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</div><div class="line">                                 &quot;missing weak-linked target class&quot;, </div><div class="line">                                 cat-&gt;name, cat);</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Process this category. </div><div class="line">            // First, register the category with its target class. </div><div class="line">            // Then, rebuild the class&apos;s method lists (etc) if </div><div class="line">            // the class is realized. </div><div class="line">            bool classExists = NO;</div><div class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </div><div class="line">                ||  cat-&gt;instanceProperties) </div><div class="line">            &#123;</div><div class="line">                addUnattachedCategoryForClass(cat, cls, hi);</div><div class="line">                if (cls-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls);</div><div class="line">                    classExists = YES;</div><div class="line">                &#125;</div><div class="line">                if (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, </div><div class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </div><div class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </div><div class="line">                /* ||  cat-&gt;classProperties */) </div><div class="line">            &#123;</div><div class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</div><div class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls-&gt;ISA());</div><div class="line">                &#125;</div><div class="line">                if (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, </div><div class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这一大堆代码，我们可以看到：</p>
<ol>
<li>遍历 catlist 数组（装有categoty_t的数组），把 category 的实例方法，协议及属性添加到主类上</li>
<li>把 category 的类方法和协议添加到 metaclass 上。</li>
</ol>
<p>我们再来分析一下上面的代码的关键方法： remethodizeClass</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void remethodizeClass(Class cls)</div><div class="line">&#123;</div><div class="line">    category_list *cats;</div><div class="line">    bool isMeta;</div><div class="line"></div><div class="line">    runtimeLock.assertWriting();</div><div class="line"></div><div class="line">    isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    // Re-methodizing: check for more categories</div><div class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</div><div class="line">        if (PrintConnecting) &#123;</div><div class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;, </div><div class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        attachCategories(cls, cats, true /*flush caches*/);        </div><div class="line">        free(cats);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法又调用了 attachCategories：（一层套一层，汗！）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">// Attach method lists and properties and protocols from categories to a class.</div><div class="line">// Assumes the categories in cats are all loaded and sorted by load order, </div><div class="line">// oldest categories first.</div><div class="line">static void </div><div class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</div><div class="line">&#123;</div><div class="line">    if (!cats) return;</div><div class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line"></div><div class="line">    bool isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    // fixme rearrange to remove these intermediate allocations</div><div class="line">    method_list_t **mlists = (method_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*mlists));</div><div class="line">    property_list_t **proplists = (property_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*proplists));</div><div class="line">    protocol_list_t **protolists = (protocol_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*protolists));</div><div class="line"></div><div class="line">    // Count backwards through cats to get newest categories first</div><div class="line">    int mcount = 0;</div><div class="line">    int propcount = 0;</div><div class="line">    int protocount = 0;</div><div class="line">    int i = cats-&gt;count;</div><div class="line">    bool fromBundle = NO;</div><div class="line">    while (i--) &#123;</div><div class="line">        auto&amp; entry = cats-&gt;list[i];</div><div class="line"></div><div class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">        if (mlist) &#123;</div><div class="line">            mlists[mcount++] = mlist;</div><div class="line">            fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta);</div><div class="line">        if (proplist) &#123;</div><div class="line">            proplists[propcount++] = proplist;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class="line">        if (protolist) &#123;</div><div class="line">            protolists[protocount++] = protolist;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    auto rw = cls-&gt;data();</div><div class="line"></div><div class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">    free(mlists);</div><div class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class="line"></div><div class="line">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">    free(proplists);</div><div class="line"></div><div class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">    free(protolists);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码才是关键，注意看苹果给的这个方法的注释：Attach method lists and properties and protocols from categories to a class,把 category 中的方法，属性，协议从 category 中加到类上面，<br>通过 while 循环，遍历所有的 category,得到它的方法列表并存入 mlist 中，最后通过 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rw-&gt;methods.attachLists(mlists, mcount);</div></pre></td></tr></table></figure>
<p>将 category 中的方法，与原方法 合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;  </div><div class="line">    if (addedCount == 0) return;</div><div class="line">    uint32_t oldCount = array()-&gt;count;</div><div class="line">    uint32_t newCount = oldCount + addedCount;</div><div class="line">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class="line">    array()-&gt;count = newCount;</div><div class="line">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0]));</div><div class="line">    memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 attachLists 方法就是合并的方法，将新的方法列表数组，即 category 中的方法 添加到了原方法列表中的前面，所以说：<br>category 中的方法并没有替换掉原来类已经有的方法，只不过新添加的方法在原来类方法的前面，运行时在查找方法时，是按着方法列表的顺序查找的，只要一找到，就会停止查找，所以说会调用 category 中的方法</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.sunnyxx.com/2014/03/05/objc_category_secret/" target="_blank" rel="external">objc category的秘密</a></p>
<p><a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a></p>
<p><a href="http://www.jianshu.com/p/d66d65314add" target="_blank" rel="external">结合 category 工作原理分析 OC2.0 中的 runtime</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/16/KVO原理/" itemprop="url">
                  KVO原理实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-16T16:57:11+08:00" content="2016-08-16">
              2016-08-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/16/KVO原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/16/KVO原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/16/KVO原理/" class="leancloud_visitors" data-flag-title="KVO原理实现">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、KVO简介"><a href="#一、KVO简介" class="headerlink" title="一、KVO简介"></a>一、KVO简介</h3><p>KVO是 Objective-C 对观察者设计模式的一种实现，它提供一种机制，指定一个被观察对象，当这个对象指定的属性发生改变时，对象会获得通知，并作出相应处理。比如在下拉刷新控件中，观察scrollView的contentOffset属性，当contentOffset发生改变时，让刷新控件显示不同的状态。</p>
<h3 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h3><p>KVO的实现依赖于 Objective-C 强大的 Runtime，下面我们来探索一下：<br>新建一个Person类，监听它的name属性，并在监听前与监听后分别输出相关信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.per = [[Person alloc] init];</div><div class="line">NSLogDescription(self.per);</div><div class="line">[self.per addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];</div><div class="line">NSLogDescription(self.per);</div></pre></td></tr></table></figure>
<p>NSLogDescription方法为工具方法，输出类的名字，isa，实现的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static void NSLogDescription(id obj)</div><div class="line">&#123;</div><div class="line">    NSString *str = [NSString stringWithFormat:</div><div class="line">                     @&quot;%@\n\tclassName: %s\n\tclsss isa: %s\n\timplements methods &lt;%@&gt;&quot;,</div><div class="line">                     obj,</div><div class="line">                     class_getName([obj class]),</div><div class="line">                     class_getName(object_getClass(obj)),</div><div class="line">                     [ClassMethodNames(object_getClass(obj)) componentsJoinedByString:@&quot;, &quot;]];</div><div class="line">    printf(&quot;%s\n&quot;, [str UTF8String]);</div><div class="line">&#125;</div><div class="line">static NSArray *ClassMethodNames(Class c)</div><div class="line">&#123;</div><div class="line">    NSMutableArray *array = [NSMutableArray array];</div><div class="line">    </div><div class="line">    unsigned int methodCount = 0;</div><div class="line">    Method *methodList = class_copyMethodList(c, &amp;methodCount);</div><div class="line">    unsigned int i;</div><div class="line">    for(i = 0; i &lt; methodCount; i++)</div><div class="line">        [array addObject: NSStringFromSelector(method_getName(methodList[i]))];</div><div class="line">    free(methodList);</div><div class="line">    return array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在控制台可以看见监听前和监听后的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Person: 0x7fcc4b61a240&gt;</div><div class="line">	className: Person</div><div class="line">	clsss isa: Person</div><div class="line">	implements methods &lt;.cxx_destruct, name, setName:&gt;</div><div class="line">&lt;Person: 0x7fcc4b61a240&gt;</div><div class="line">	className: Person</div><div class="line">	clsss isa: NSKVONotifying_Person</div><div class="line">	implements methods &lt;setName:, class, dealloc, _isKVOA&gt;</div></pre></td></tr></table></figure>
<p>我们看到，类的名字还是 Person，但是 isa 指针却是 NSKVONotifying<em>Person，并且实现的方法也变了<br>其实这是 Runtime 搞的鬼，当某个类的对象第一次被观察时，系统就会在运行期动态的创建该类的子类，修改这个类的 isa 指向这个新的子类，类名字就是这种 NSKVONotifying</em>(类名)。由于在 iOS 中函数调用都转化为 isa 查表形式，所以这次查的是新的子类的表，也就是说对类的函数调用被子类给拦截了。这种修改类的 isa 技术被称为 isa-swizzling 技术。由此可见，新的 NSKVONotifying_Person 类都做了一下事情：</p>
<p> 2.1、重写 class 方法</p>
<p>当你打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.per class];</div></pre></td></tr></table></figure>
<p>不管在监听前，还是监听后，都返回 Person,这应该是苹果故意而为之，他们不希望这个机制暴露在外面，故重写了 class 方法</p>
<p> 2.2、重写 set 方法</p>
<p>新类会重写监听属性的 set 方法，如果该类还有其他属性，但是没有监听，不会重写其他属性的 set 方法，并且在重写的 set 方法内增加了另外两个方法的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(void)willChangeValueForKey:(NSString *)key</div><div class="line">-(void)didChangeValueForKey:(NSString *)key</div></pre></td></tr></table></figure>
<p>其中，didChangeValueForKey:方法负责调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(NSDictionary *)change</div><div class="line">                       context:(void *)context</div></pre></td></tr></table></figure>
<p>这就是 KVO 实现的原理了。</p>
<p>2.3、增加了 _isKVOA  dealloc 方法</p>
<p>_isKVOA 用来标示该类是一个 KVO 机制声称的类。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>KVO 是 Cocoa 提供的一个很强大的特性，但同时它也有很多坑需要我我们注意，比如比如添加完监听后，要在不需要的时候删除掉监听，否则就会造成意外崩溃。还有相对于 delegate , notification,KVO 要创建子类及重写方法，相对的占用更多的内存。对一个复杂和相关性很多的class，用 delegate 或 notification 的方式比较简洁</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/15/老生常谈NSString与NSMutableString/" itemprop="url">
                  老生常谈NSString与NSMutableString
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-15T11:38:34+08:00" content="2016-08-15">
              2016-08-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/15/老生常谈NSString与NSMutableString/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/15/老生常谈NSString与NSMutableString/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/15/老生常谈NSString与NSMutableString/" class="leancloud_visitors" data-flag-title="老生常谈NSString与NSMutableString">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSString与NSMutableString是我们在写代码中最熟悉不过的了，今天我们就来完全彻底的认识一下他们。</p>
<h3 id="一-、NSConstantString"><a href="#一-、NSConstantString" class="headerlink" title="一 、NSConstantString"></a>一 、NSConstantString</h3><p>我们一般通过下面这种方法来创建一个字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *string1 = @&quot;Hello World!&quot;;</div><div class="line">NSString *string2 = @&quot;Hello World!&quot;;</div></pre></td></tr></table></figure>
<p>此时我们打印一下string1与string2的内存地址发现他们是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-08-15 11:14:22.661 StringTest[1028:98759] string1: 0x102c31050</div><div class="line">2016-08-15 11:14:22.661 StringTest[1028:98759] string1: 0x102c31050</div></pre></td></tr></table></figure>
<p>其实字string1与string2并不是真正包含一个字符串对象，而是指向内存中字符串对象的指针，字面量@”Hello World!”存储在文字常量区，指针string1与string2都指向它，他们在编译时真实类型是NSConstantString</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;string1:%@&quot;,[string1 class]);</div><div class="line">NSLog(@&quot;string2:%@&quot;,[string2 class]);</div><div class="line"></div><div class="line">输出为：</div><div class="line">string1:__NSCFConstantString</div><div class="line">string2:__NSCFConstantString</div></pre></td></tr></table></figure>
<p>NSConstantString是NSString的子类，是一个字符串常量，是在编译时创建的，并且是没有retainCount(引用计数的)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSString *string1 = @&quot;Hello World!&quot;;</div><div class="line">NSLog(@&quot;引用计数为：%lu&quot;,string1.retainCount);</div><div class="line">[string1 retainCount];</div><div class="line">NSLog(@&quot;retainCount后引用计数为：%lu&quot;,string1.retainCount);</div><div class="line"></div><div class="line">输出为：</div><div class="line">引用计数为：18446744073709551615</div><div class="line">retainCount后引用计数为：18446744073709551615</div></pre></td></tr></table></figure>
<p>由此可见，打印引用计数，以及retainCount一次后引用计数都为非正常值，所以说是无引用计数的.<br>再比如我在ViewController里定义了两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,strong)NSString *string1;</div><div class="line">@property(nonatomic,weak)NSString *string2;</div></pre></td></tr></table></figure>
<p>然后在实现方法里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.string1 = @&quot;Hello World!&quot;;</div><div class="line">self.string2 = self.string1;</div><div class="line">self.string1 = nil;</div><div class="line">NSLog(@&quot;%@ %@&quot;,self.string1,self.string2);</div></pre></td></tr></table></figure>
<p>由于string2修饰符是weak，当我让self.string1 = nil时，self.string2也应该为nil，但输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-08-15 14:09:47.400 StringTest[1265:166991] (null) Hello World!</div></pre></td></tr></table></figure>
<p>self.string2还有值！<br>原因还是上面所说的，NSConstantString类型的字符串没有引用计数，所以没有强指针指向它，它也不会被销毁。那怎么也让self.string2也为nil呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.string1 = [[NSMutableString alloc] initWithFormat:@&quot;Hello World!&quot;];</div></pre></td></tr></table></figure>
<p>只要这样初始化self.string1就可以啦,此时self.string1类型为__NSCFString，除此之外还有一种类型NSTaggedPointerString，它也是NSString的子类，也是无引用计数的。关于Tagged Pointer，它是苹果为了节省内存和提高执行效率引进的概念，对于64位程序，能大大提高访问速度及减少内存占用，可以看看这篇文章 <a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/" target="_blank" rel="external">深入理解Tagged Pointer</a></p>
<h3 id="二、copy与strong"><a href="#二、copy与strong" class="headerlink" title="二、copy与strong"></a>二、copy与strong</h3><p>我们在一个类里声明两个字符串属性,一个修饰符是strong，一个copy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,strong)NSString *strongStr;</div><div class="line">@property(nonatomic,copy)NSString *copyedStr;</div></pre></td></tr></table></figure>
<p>首先，我们用一个不可变字符串来为他们赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;Hello World!&quot;;</div><div class="line">self.strongStr = string;</div><div class="line">self.copyedStr = string;</div><div class="line">NSLog(@&quot;string:    %@, %p, %p&quot;,string, string,&amp;string);</div><div class="line">NSLog(@&quot;strongStr: %@, %p, %p&quot;,_strongStr,_strongStr,&amp;_strongStr);</div><div class="line">NSLog(@&quot;copyedStr: %@, %p, %p&quot;,_copyedStr,_copyedStr,&amp;_copyedStr);</div></pre></td></tr></table></figure>
<p> 输出分别是值，内存地址，指针地址，输出为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string:    Hello World!, 0x101314078, 0x7fff5e8eba68</div><div class="line">strongStr: Hello World!, 0x101314078, 0x7f8951f48b60</div><div class="line">copyedStr: Hello World!, 0x101314078, 0x7f8951f48b68</div></pre></td></tr></table></figure>
<p> 由此可见，不管是strong还是copy，string指向的地址都是同一个，假设string有引用计数的话,strong操作和copy操作都使string得引用计数加1。</p>
<p>接下来，我们把string变成可变对象，并且在对self.strongStr,self.copyedStr赋值后修改string的值，再看一下输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;Hello World!&quot;];</div><div class="line">self.strongStr = string;</div><div class="line">self.copyedStr = string;</div><div class="line">//在这里修改一下string的值</div><div class="line">[string appendFormat:@&quot;Hi!&quot;];</div><div class="line"></div><div class="line">NSLog(@&quot;string:    %@, %p, %p&quot;,string, string,&amp;string);</div><div class="line">NSLog(@&quot;strongStr: %@, %p, %p&quot;,_strongStr,_strongStr,&amp;_strongStr);</div><div class="line">NSLog(@&quot;copyedStr: %@, %p, %p&quot;,_copyedStr,_copyedStr,&amp;_copyedStr);</div><div class="line">NSLog(@&quot;%lu %lu&quot;,string.retainCount,self.copyedStr.retainCount);</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string:    Hello World!Hi!, 0x7fea9ae0abb0, 0x7fff59876a68</div><div class="line">strongStr: Hello World!Hi!, 0x7fea9ae0abb0, 0x7fea9ad32500</div><div class="line">copyedStr: Hello World!, 0x7fea9ae0d4c0, 0x7fea9ad32508</div><div class="line">2 1</div></pre></td></tr></table></figure>
<p> 可以发现，copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让_copyedStr指向了这个字符串，string的值再发生改变时，_copyedStr的值不会发生变化。此时string的引用计数为2,self.copyedStr引用计数为1.</p>
<p> 由上面的例子可以看出，当源字符串是NSString时，由于字符串是不可变的，所以，不管strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>
<p> 当源字符串是NSMutableString时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。</p>
<p> 所以，在声明NSString时，到底是选择strong还是copy，视情况而定。不过，一般我们将对象声明为NSString时，都不希望它改变，所以，大多情况下，我们建议用copy</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/12/新的博客，新的开始/" itemprop="url">
                  新的博客，新的开始
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-12T13:57:19+08:00" content="2016-08-12">
              2016-08-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/12/新的博客，新的开始/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/12/新的博客，新的开始/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/12/新的博客，新的开始/" class="leancloud_visitors" data-flag-title="新的博客，新的开始">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看到别人都有自己的技术博客，一时心血来潮，自己也建一个，由于对这方面一窍不通，查了好多资料，用了整整一天，才把这个博客建立起来。</p>
<p>作为一个搞IT开发的，拥有属于自己的技术博客是必须的，这个博客算是对自己学习过程的记录吧，公司项目不忙的话，尽量多抽点时间学点技术写博客，写完之后你会对所写的技术理解更加深刻，记忆也就越深，总之，也督促自己一定要不断学习。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ocauxqtbu.bkt.clouddn.com/27563317749u=2381918280,2871499884&fm=21&gp=0.jpg"
               alt="Zhou Jian" />
          <p class="site-author-name" itemprop="name">Zhou Jian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coderZhou10496" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"coderzhou"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Bw40KBIPanRkt0iqTr7NLT6I-gzGzoHsz", "MQjFPSYkEazqnUv2rS7TOsui");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
