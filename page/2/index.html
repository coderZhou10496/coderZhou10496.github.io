<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Jianless的博客">
<meta property="og:url" content="http://coderzhou.com/page/2/index.html">
<meta property="og:site_name" content="Jianless的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jianless的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coderzhou.com/page/2/"/>

  <title> Jianless的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Jianless的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">专注于iOS开发</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/16/程序的启动链接过程/" itemprop="url">
                  程序的启动链接过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-16T10:32:04+08:00" content="2018-03-16">
              2018-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/16/程序的启动链接过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/16/程序的启动链接过程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/16/程序的启动链接过程/" class="leancloud_visitors" data-flag-title="程序的启动链接过程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>main函数是程序的启动入口，但是系统为程序的启动又做了哪些准备呢，二进制文件又是怎样加载进内存的呢？这两天花了点时间深入了了解了一下。</p>
<h3 id="Mach-O格式简单介绍"><a href="#Mach-O格式简单介绍" class="headerlink" title="Mach-O格式简单介绍"></a>Mach-O格式简单介绍</h3><p>Mach则是苹果操作系统内核，在Mach上，一种可执行的文件格是就是Mach-O（Mach Object file format），这是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。Mach-O 文件一般都有一个 Header ，各种 Load Commands 以及多个 Segment：<br><img src="http://ocauxqtbu.bkt.clouddn.com/link_mach-o.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.Header：保存了Mach-O的一些基本信息，包括了平台、文件类型、LoadCommands的个数等等。</div><div class="line">2.LoadCommands：这一段紧跟Header，加载Mach-O文件时会使用这里的数据来确定内存的分布。</div><div class="line">3.Data：每一个segment的具体数据都保存在这里，这里包含了具体的代码、数据等等。</div></pre></td></tr></table></figure>
<p>####Header<br><img src="http://ocauxqtbu.bkt.clouddn.com/link_mach-o_header.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Magic Number:			该文件是64位平台文件还是32位平台文件。值为0xFEEDFACF表示64位，0xFEEDFACE表示32位；</div><div class="line">CPU Type,CPU subType:	确定CPU的平台与版本；</div><div class="line">File Type:				该文件的类型。MH_EXECUTE表示这是一个可执行文件；</div><div class="line">Number of 				Load Commands:Load Commands的个数；</div><div class="line">Size of Load Commands:	Load Commands的长度；</div><div class="line">Flags:					dylb加载时需要的标志位；</div><div class="line">Reserved:				只有64位的时候才存在的字段，暂时没用</div></pre></td></tr></table></figure>
<p>####Load Commands<br>Load Commands表示的是加载命令，不同的字段就是表示不同的命令，通过解析LoadCommand来加载接下来的数据。举几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LC_MAIN：整个程序的入口地址，保证进程启动后能够正常的开始整个应用程序的运行</div><div class="line">LC_UUID：唯一ID</div><div class="line">LC_LOAD_DYLINKER：获得动态加载器地址,调用dylb程序</div><div class="line">LC_CODE_SIGNATURE：进行数字签名.</div></pre></td></tr></table></figure>
<p>等等</p>
<p>####Segment &amp; Section<br>Data表示原始数据,可以拥有多个段（segment），每个段可以拥有零个或多个区域（section）。每一个段（segment）都拥有一段虚拟地址映射到进程的地址空间。<br>加载数据时，主要加载的就是<code>LC_SEGMENT</code>或者<code>LC_SEGMENT_64</code>。这里大部分的数据是用来帮助内核将Segment映射到虚拟内存。<code>LC_SEGMENT_64</code>的数据结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT_64 */</div><div class="line">	uint32_t	cmdsize;	/* load command的大小 */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint64_t	vmaddr;		/* 段的虚拟内存地址 */</div><div class="line">	uint64_t	vmsize;		/*  段的虚拟内存大小 */</div><div class="line">	uint64_t	fileoff;	/* 段在文件中偏移量 */</div><div class="line">	uint64_t	filesize;	/* 段在文件中的大小 */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* 标示了Segment中有多少secetion */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Section的数据结构为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct section &#123; /* for 32-bit architectures */</div><div class="line">    char        sectname[16];   /* name of this section */</div><div class="line">    char        segname[16];    /* segment this section goes in */</div><div class="line">    uint32_t    addr;       /* memory address of this section */</div><div class="line">    uint32_t    size;       /* size in bytes of this section */</div><div class="line">    uint32_t    offset;     /* file offset of this section */</div><div class="line">    uint32_t    align;      /* 字节大小对齐 */</div><div class="line">    uint32_t    reloff;     /* file offset of relocation entries */</div><div class="line">    uint32_t    nreloc;     /* number of relocation entries */</div><div class="line">    uint32_t    flags;      /* flags (section type and attributes)*/</div><div class="line">    uint32_t    reserved1;  /* reserved (for offset or index) */</div><div class="line">    uint32_t    reserved2;  /* reserved (for count or sizeof) */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>__PAGEZERO</code>是第一个段，它的大小在 32 位系统是 4KB+，而在 64 位系统是 4GB+。位于虚拟内存从 0x000000 到 App 真实起始位置之间，都是被标记为不可读写和不可执行。因为里面并没有数据，所以 file size 为 0。主要的作用是为了捕获 NULL 指针使用和指针截断错误，防止引起系统崩溃。开发中常见的 EXC_BAD_ACCESS 异常都是因为错误访问到这里了。</p>
</li>
<li><p><code>__TEXT</code> 段包含了 Mach 头部，被执行的代码和只读常量，它被只读和可执行的方式映射。以下是几个常见的 section：</p>
</li>
<li><p><code>__text</code> 里就是程序编译后的机器码。</p>
</li>
<li><code>__stubs</code> 和 <code>__stub_helper</code> 是给动态链接器（dyld）使用的。</li>
<li><code>__const</code> 包含常量变量，所有不需要重定向的常量数据都会被编译器放在这里。</li>
<li><code>__cstring</code> 包含硬编码的字符串常量。</li>
<li><code>__DATA</code> 段包含了可读写的内容，全局变量和静态变量等，以可读写和不可执行的方式映射。常见的 section 有：<br><code>__nl_symbol_ptr</code> 和 <code>__la_symbol_ptr</code> 分别是 non-lazy 和 lazy 符号指针。lazy 符号指针用于可执行文件中调用未定义的函数，例如不包含在可执行文件中的函数，它们将会延迟加载。而针对 non-lazy 符号指针，当可执行文件被加载同时，也会被加载。</li>
<li><code>__const</code> 包含需要重定向的常量数据。</li>
<li><code>__bss</code> 包含没有被初始化的静态变量。</li>
<li><code>__LINKEDIT</code> 段它的作用是包含如何加载整个文件的「元数据」。例如符号表，字符串表和重定位表。代码签名后每页的加密散列值也会存储到这里。</li>
</ul>
<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>一个程序的编译过程简单分为预编译、编译、汇编、链接等过程。链接就是讲多个目标文件合并成一个可执行文件，静态库和动态库的区别就是在链接阶段如何处理库。在链接阶段，将汇编生成的目标文件与引用到的库一个链接打包到可执行文件中，因为对应的链接方式成为静态链接。而动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。使用动态库的好处有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.代码共用：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份</div><div class="line">2.易于维护：由于被依赖的 lib 是程序执行时才 link 的，所以这些 lib 很容易做更新</div><div class="line">3.减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多</div></pre></td></tr></table></figure>
<p>但是同样的，加载动态库，就需要动态连接器dylb。动态链接加载器在系统中以一个用户态的可执行文件形式存在，一般应用程序会在Mach-O文件部分指定一个LC_LOAD_DYLINKER的加载命令，此加载命令指定了dyld的路径，通常它的默认值是“/usr/lib/dyld”。系统内核在加载Mach-O文件时，会使用该路径指定的程序作为动态库的加载器来加载dylib。不过dylb是<a href="https://github.com/opensource-apple/dyld" target="_blank" rel="external">开源</a>的。</p>
<p>###mach-o文件加载</p>
<p>####dyld自身如何加载</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/link_objc_init.png" alt="image"><br>我们在程序中设个断点，断在<code>_objc_init</code>，我们看到了栈底的<code>_dylb_start</code>方法，那么问题来了,既然各种二进制都是走dyld加载的，那么dyld自身是如何加载进来的呢？<br>系统在解析Mach-O文件时，<code>_dylb_start</code> 的方法地址的是在 <code>LC_UNIXTHREAD</code> 段中解析出来的，然后通过 <code>LC_LOAD_DYLINKER</code> 这个字段来启动这个二进制加载器。从下面dylb的这段源码可以看到，启动前还要做一些准备引导工作，到最后才是调用<code>dyld::_main</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</div><div class="line">//  In dyld we have to do this manually.</div><div class="line">//</div><div class="line">uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], </div><div class="line">				intptr_t slide, const struct macho_header* dyldsMachHeader,</div><div class="line">				uintptr_t* startGlue)</div><div class="line">&#123;</div><div class="line">	// if kernel had to slide dyld, we need to fix up load sensitive locations</div><div class="line">	// we have to do this before using any global variables</div><div class="line">	if ( slide != 0 ) &#123;</div><div class="line">		rebaseDyld(dyldsMachHeader, slide);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// allow dyld to use mach messaging</div><div class="line">	mach_init();</div><div class="line"></div><div class="line">	// kernel sets up env pointer to be just past end of agv array</div><div class="line">	const char** envp = &amp;argv[argc+1];</div><div class="line">	</div><div class="line">	// kernel sets up apple pointer to be just past end of envp array</div><div class="line">	const char** apple = envp;</div><div class="line">	while(*apple != NULL) &#123; ++apple; &#125;</div><div class="line">	++apple;</div><div class="line"></div><div class="line">	// set up random value for stack canary</div><div class="line">	__guard_setup(apple);</div><div class="line"></div><div class="line">#if DYLD_INITIALIZER_SUPPORT</div><div class="line">	// run all C++ initializers inside dyld</div><div class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</div><div class="line">#endif</div><div class="line"></div><div class="line">	// now that we are done bootstrapping dyld, call dyld&apos;s main</div><div class="line">	uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader);</div><div class="line">	return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><p>有兴趣的同学可以下载源码看下，<code>dyld::_main</code>main方法做的主要事情有</p>
<ul>
<li>设置运行环境，环境变量</li>
<li>实例化Image</li>
<li>加载共享缓存</li>
<li>动态库的版本化重载</li>
<li>加载插入的动态库</li>
<li>link主程序</li>
<li>link插入的动态库</li>
<li>weakBind弱符号绑定</li>
<li>initialize</li>
<li>查找入口点并返回</li>
</ul>
<p>在所有的动态库做好符号重定位和初始化工作之后，也就是 dyld::_main 临近末尾的时候，dyld 会获取 main 函数的地址返回给 dyld，dyld 紧接着调用 main 函数，将控制权交换给主程序，程序开始真正的执行。<br>下面是<code>dyld::_main</code>方法的部分源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</div><div class="line">// sets up some registers and call this function.</div><div class="line">//</div><div class="line">// Returns address of main() in target program which __dyld_start jumps to</div><div class="line">//</div><div class="line">uintptr_t</div><div class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </div><div class="line">		int argc, const char* argv[], const char* envp[], const char* apple[], </div><div class="line">		uintptr_t* startGlue) &#123;</div><div class="line">		...</div><div class="line">		//实例化Image</div><div class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</div><div class="line">		&#125;</div><div class="line">		...</div><div class="line">		//		加载共享缓存</div><div class="line">		checkSharedRegionDisable();</div><div class="line">		...</div><div class="line">			#if DYLD_SHARED_CACHE_SUPPORT</div><div class="line">//		动态库的版本化重载</div><div class="line">		if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion )</div><div class="line">			mapSharedCache();</div><div class="line">	#endif</div><div class="line"></div><div class="line">		// Now that shared cache is loaded, setup an versioned dylib overrides</div><div class="line">	#if SUPPORT_VERSIONED_PATHS</div><div class="line">		checkVersionedPaths();</div><div class="line">	#endif</div><div class="line">//加载插入的动态库</div><div class="line">		// load any inserted libraries</div><div class="line">		if	( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;</div><div class="line">			for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) </div><div class="line">				loadInsertedDylib(*lib);</div><div class="line">		&#125;</div><div class="line">		// record count of inserted libraries so that a flat search will look at </div><div class="line">		// inserted libraries, then main, then others.</div><div class="line">		sInsertedDylibCount = sAllImages.size()-1;</div><div class="line"></div><div class="line">//		link主程序</div><div class="line">		// link main executable</div><div class="line">		gLinkContext.linkingMainExecutable = true;</div><div class="line">		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL));</div><div class="line">		sMainExecutable-&gt;setNeverUnloadRecursive();</div><div class="line">		if ( sMainExecutable-&gt;forceFlat() ) &#123;</div><div class="line">			gLinkContext.bindFlat = true;</div><div class="line">			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>我们来看一下实例化image的过程,Runtime的初始化过程就是在这里进行的。这个image不是图片的意思，它大概表示一个二进制文件，<code>instantiateFromLoadedImage</code>这个方法就是实例化的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// The kernel maps in main executable before dyld gets control.  We need to </div><div class="line">// make an ImageLoader* for the already mapped in main executable.</div><div class="line">static ImageLoader* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)</div><div class="line">&#123;</div><div class="line">	// try mach-o loader</div><div class="line">	if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123; //检测macho文件是否符合条件,意思是该手机能否处理此mach-o文件</div><div class="line">//		初始化实例：方法内部通过判断mach-o文件是否是压缩过的，然后选择相应的类进行实例化</div><div class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</div><div class="line">//		添加image到管理的模块中</div><div class="line">		addImage(image);</div><div class="line">		return image;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	throw &quot;main executable not a known format&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>isCompatibleMachO</code>方法部分源码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// This is used to validate if a non-fat (aka thin or raw) mach-o file can be used</div><div class="line">// on the current processor. //</div><div class="line">bool isCompatibleMachO(const uint8_t* firstPage, const char* path)</div><div class="line">&#123;</div><div class="line">#if CPU_SUBTYPES_SUPPORTED</div><div class="line">	// It is deemed compatible if any of the following are true:</div><div class="line">	//  1) mach_header subtype is in list of compatible subtypes for running processor</div><div class="line">	//  2) mach_header subtype is same as running processor subtype</div><div class="line">	//  3) mach_header subtype runs on all processor variants</div><div class="line">	const mach_header* mh = (mach_header*)firstPage;</div><div class="line">	...</div><div class="line">	...</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>从注释中，可以看出，要满足以下三个条件，手机才能处理此mach-o文件</p>
<ul>
<li>mach_header中的subtype支持当前CPU版本。</li>
<li>mach_header中的subtype和当前正在运行的CPU版本相同。</li>
<li>mach_header中的subtype在该CPU的所有版本都可以处理。</li>
</ul>
<p><code>instantiateMainExecutable</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// create image for main executable</div><div class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	//dyld::log(&quot;ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n&quot;,</div><div class="line">	//	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</div><div class="line">	bool compressed;</div><div class="line">	unsigned int segCount;</div><div class="line">	unsigned int libCount;</div><div class="line">	const linkedit_data_command* codeSigCmd;</div><div class="line">	const encryption_info_command* encryptCmd;</div><div class="line">//	判断mach-o文件是否是压缩过</div><div class="line">	sniffLoadCommands(mh, path, false, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</div><div class="line">	// instantiate concrete class based on content of load commands</div><div class="line">//	通过是否压缩，用不同的方法来处理</div><div class="line">	if ( compressed )</div><div class="line">		return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">	else</div><div class="line">#if SUPPORT_CLASSIC_MACHO</div><div class="line">		return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">#else</div><div class="line">		throw &quot;missing LC_DYLD_INFO load command&quot;;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先判断mach-o文件是否压缩过，然后再用不用的方式处理此文件。两个方法的处理方式大同小异，<code>ImageLoaderMachOClassic::instantiateMainExecutable</code>方法里又调用了<code>ImageLoaderMachOClassic::instantiateStart</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// construct ImageLoaderMachOClassic using &quot;placement new&quot; with SegmentMachO objects array at end</div><div class="line">ImageLoaderMachOClassic* ImageLoaderMachOClassic::instantiateStart(const macho_header* mh, const char* path,</div><div class="line">																		unsigned int segCount, unsigned int libCount)</div><div class="line">&#123;</div><div class="line">	size_t size = sizeof(ImageLoaderMachOClassic) + segCount * sizeof(uint32_t) + libCount * sizeof(ImageLoader*);</div><div class="line">	ImageLoaderMachOClassic* allocatedSpace = static_cast&lt;ImageLoaderMachOClassic*&gt;(malloc(size));</div><div class="line">	if ( allocatedSpace == NULL )</div><div class="line">		throw &quot;malloc failed&quot;;</div><div class="line">	uint32_t* segOffsets = ((uint32_t*)(((uint8_t*)allocatedSpace) + sizeof(ImageLoaderMachOClassic)));</div><div class="line">	bzero(&amp;segOffsets[segCount], libCount*sizeof(void*));	// zero out lib array</div><div class="line">	return new (allocatedSpace) ImageLoaderMachOClassic(mh, path, segCount, segOffsets, libCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法内主要是申请内存，然后调用<code>ImageLoaderMachOClassic</code>方法，根据mach-o文件segments的规则将数据加载到内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ImageLoaderMachO::ImageLoaderMachO(const macho_header* mh, const char* path, unsigned int segCount, </div><div class="line">																uint32_t segOffsets[], unsigned int libCount)</div><div class="line"> : ImageLoader(path, libCount), fCoveredCodeLength(0), fMachOData((uint8_t*)mh), fLinkEditBase(NULL), fSlide(0),</div><div class="line">......</div><div class="line">&#123;</div><div class="line">	fIsSplitSeg = ((mh-&gt;flags &amp; MH_SPLIT_SEGS) != 0);        </div><div class="line"></div><div class="line">	// construct SegmentMachO object for each LC_SEGMENT cmd using &quot;placement new&quot; to put </div><div class="line">	// each SegmentMachO object in array at end of ImageLoaderMachO object</div><div class="line">	const uint32_t cmd_count = mh-&gt;ncmds;</div><div class="line">	const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)];</div><div class="line">	const struct load_command* cmd = cmds;</div><div class="line">	for (uint32_t i = 0, segIndex=0; i &lt; cmd_count; ++i) &#123;</div><div class="line">		if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</div><div class="line">			const struct macho_segment_command* segCmd = (struct macho_segment_command*)cmd;</div><div class="line">			// ignore zero-sized segments</div><div class="line">			if ( segCmd-&gt;vmsize != 0 ) &#123;</div><div class="line">				// record offset of load command</div><div class="line">				segOffsets[segIndex++] = (uint32_t)((uint8_t*)segCmd - fMachOData);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，这个方法就执行完了。然后就是最开始的调用<code>addimage</code>方法。这里涉及的源代码非常多，我只是粘贴了一部分。</p>
<p>####Runtime是在哪个过程中初始化的？</p>
<p>从上面的那个<code>_objc_init</code>调用栈可以看出，<code>initializeMainExecutable</code>内会进行Runtime的初始化</p>
<ul>
<li>initializeMainExecutable()</li>
<li>ImageLoader::runInitializers()</li>
<li>…</li>
<li>doModInitFunctions()</li>
<li>libdispatch_init</li>
<li>_os_object_init</li>
</ul>
<p>最终的，在<code>_os_object_init</code>这个方法内调用了<code>_objc_init()</code>方法，Runtime 接手后调用，调用map_images 做解析和处理，把 Category 的实例方法、协议以及属性添加到类上，把 Category 的类方法和协议添加到类的 metaclass 上；接下来 <code>load_images</code> 中调用 <code>call_load_methods</code> 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 load 方法和其 Category 的 load 方法。</p>
<p>本文只是简单介绍了dylb加载mach-o文件的简单流程，具体方法内部如何加载并没有过多探究，比如符号绑定，延迟加载等每一个知识点都可以写一篇文章来阐述。如有错误，请指正</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/19/容器类型数据防Crash处理/" itemprop="url">
                  容器类型数据防Crash处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-19T19:32:07+08:00" content="2018-01-19">
              2018-01-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/01/19/容器类型数据防Crash处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/19/容器类型数据防Crash处理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/19/容器类型数据防Crash处理/" class="leancloud_visitors" data-flag-title="容器类型数据防Crash处理">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="容器类型处理"><a href="#容器类型处理" class="headerlink" title="容器类型处理"></a>容器类型处理</h3><p>当我们使用NSArray或NSDictionary,如果使用不当，很容易造成crash比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@1,@2,@3];</div><div class="line">array[3];</div><div class="line"></div><div class="line">id value = nil;</div><div class="line">NSDictionary *dic = @&#123;@&quot;key&quot;:value&#125;;</div></pre></td></tr></table></figure>
<p>数组越界和初始化NSDictionary时value为nil，都会crash.</p>
<p>防护措施就是hook系统方法，在自己的方法里先进行判断，然后再调用系统方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ZJSwizzleMethod(NSClassFromString(@&quot;__NSArrayI&quot;), @selector(objectAtIndex:), </div><div class="line">@selector(zj_objectAtIndex:));</div><div class="line"></div><div class="line">void ZJSwizzleMethod(Class c, SEL origSEL, SEL newSEL) &#123;</div><div class="line">    Method origMethod = class_getInstanceMethod(c, origSEL);</div><div class="line">    Method newMethod = nil;</div><div class="line">    if (!origMethod) &#123;</div><div class="line">        c = object_getClass(c);</div><div class="line">        return ZJSwizzleMethod(c, origSEL, newSEL);</div><div class="line">    &#125;else&#123;</div><div class="line">        newMethod = class_getInstanceMethod(c, newSEL);</div><div class="line">        if (!newMethod) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if(class_addMethod(c, origSEL, method_getImplementation(newMethod), </div><div class="line">    method_getTypeEncoding(newMethod)))&#123;</div><div class="line">            </div><div class="line">        class_replaceMethod(c, newSEL, method_getImplementation(origMethod),</div><div class="line">         method_getTypeEncoding(origMethod));</div><div class="line">    &#125;else&#123;</div><div class="line">            </div><div class="line">        method_exchangeImplementations(origMethod, newMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在交换的方法里判断index是否小于数组个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)zj_objectAtIndex:(NSUInteger)index &#123;</div><div class="line">    </div><div class="line">    if(index &gt;= self.count) &#123;</div><div class="line">        ZJSafeCollectionLog(@&quot;[%@ %@] index &#123;%zd&#125; beyond bounds [0...%zd]&quot;,NSStringFromClass([self class]),NSStringFromSelector(_cmd),index,MAX(self.count - 1, 0));</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [self zj_objectAtIndex:index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果越界，就在控制台输出日志，但是不会Crash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void ZJSafeCollectionLog(NSString*fmt,...) &#123;</div><div class="line">    if (ZJSafeCollectionLogEnabled)</div><div class="line">    &#123;</div><div class="line">        va_list ap;</div><div class="line">        va_start(ap, fmt);</div><div class="line">        NSString *content = [[NSString alloc] initWithFormat:fmt arguments:ap];</div><div class="line">        NSLog(@&quot;%@&quot;, content);</div><div class="line">        va_end(ap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例如刚才的这段代码，输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@1,@2,@3];</div><div class="line">array[3];</div><div class="line"></div><div class="line">[__NSArrayI objectAtIndexedSubscript:] index &#123;3&#125; beyond bounds [0...2]</div></pre></td></tr></table></figure>
<p>同样的，不仅仅是NSArray,对NSMutableArray，NSDictionary，NSMutableDictionary都hook了常用的方法，具体见<a href="https://github.com/coderZhou10496/ZJSafeCollectionDemo" target="_blank" rel="external">Github地址</a></p>
<h3 id="unrecognized-selector处理"><a href="#unrecognized-selector处理" class="headerlink" title="unrecognized selector处理"></a>unrecognized selector处理</h3><p>这个异常是未实现相应的方法，这个Crash防护措施是也是用Runtime进行消息转发。消息转发过程为：</p>
<ul>
<li><ol>
<li>调用resolveInstanceMethod:方法 (或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会响应这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。</li>
</ol>
</li>
<li><ol>
<li>调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</li>
</ol>
</li>
<li><ol>
<li>调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。在forwardInvocation里进行转发。</li>
</ol>
</li>
</ul>
<p>可以看出，我们可以在这三个过程中进行动态的添加方法，或对未实现的方法进行转发。</p>
<p>这种Crash类型分两种，一种是实例方法未实现，一种是类方法未实现。如果是实例方法，在这三步中任何一步进行补救就行，但是如果是类方法，只能在第一步中动态的添加方法来进行防护。</p>
<p>创建一个NSObject的分类，重写系统方法。但是如果用分类重写方法的话，就会出现一个问题，就是会拦截系统自带的方法，而这些是不需要我们处理的，系统会自动处理，所以我们只需要处理自己创建的类就行了，比如对类方法进行防护Crash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</div><div class="line">#warning &apos;ZJTestClass&apos; only test class</div><div class="line">    Class metaClass = object_getClass([ZJTestClass class]);</div><div class="line">    if([self isKindOfClass:[metaClass class]]) &#123;</div><div class="line">        class_addMethod(metaClass, sel, (IMP)remedyMethod, &quot;v@:&quot;);</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ZJTestClass为自己创建的class，实际项目中可以换成BaseModel或者BaseController.如果是类方法未实现，就会进入<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>方法里。因为是类方法，所以代码中的metaClass为元类，如果是自己创建的类，就会进入到if语句中，从而动态添加方法。</p>
<p>对于实例方法Crash的防护，我是在第二步进行的，具体原因在<a href="https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651113088&amp;idx=1&amp;sn=10b28d7fbcdf0def1a47113e5505728d" target="_blank" rel="external">这篇文章中</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.resolveInstanceMethod需要在类的本身上动态添加它本身不存在的方法，这些方法对于该类本身来说冗余的</div><div class="line">2.forwardInvocation可以通过NSInvocation的形式将消息转发给多个对象，但是其开销较大，需要</div><div class="line">创建新的NSInvocation对象，并且forwardInvocation的函数经常被使用者调用，来做多层消息转发</div><div class="line">选择机制，不适合多次重写</div><div class="line">3.forwardingTargetForSelector可以将消息转发给一个对象，开销较小，并且被重写的概率较低，适合重写</div></pre></td></tr></table></figure>
<p>具体代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void remedyMethod (id self,SEL _cmd)</div><div class="line">&#123;</div><div class="line">    if(ZJForwardingLogEnabled) &#123;</div><div class="line">        Class cs = object_getClass(self);</div><div class="line">        NSLog(@&quot;[%@ %@] unrecognized selector&quot;,NSStringFromClass(cs),NSStringFromSelector(_cmd));</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">#warning &apos;ZJTestClass&apos; only test class</div><div class="line">    if([self isKindOfClass:[UIResponder class]]|| [self isKindOfClass:[ZJTestClass class]] || [self isKindOfClass:[NSNull class]]) &#123;</div><div class="line">        Class ZJProtectorCls = NSClassFromString(@&quot;ZJProtector&quot;);</div><div class="line">        if(!ZJProtectorCls) &#123;</div><div class="line">            ZJProtectorCls = objc_allocateClassPair([NSObject class], &quot;ZJProtector&quot;, 0);</div><div class="line">            objc_registerClassPair(ZJProtectorCls);</div><div class="line">        &#125;</div><div class="line">        class_addMethod(ZJProtectorCls, aSelector, (IMP)remedyMethod, &quot;v@:&quot;);</div><div class="line"></div><div class="line">        Class ZJProtector = [ZJProtectorCls class];</div><div class="line">        id instance = [[ZJProtector alloc] init];</div><div class="line">        return instance;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>动态的创建了一个类<code>ZJProtector</code>，然后再对这个类添加方法<code>class_addMethod</code>。</p>
<p>最后消息会进入到remedyMethod方法里，方法里有日志输出。</p>
<h3 id="对NSNull的处理"><a href="#对NSNull的处理" class="headerlink" title="对NSNull的处理"></a>对NSNull的处理</h3><p>NSNull与nil不同，对nil发送任何方法都是无效的，不会Crash，但是NSNull就像平常使用的类一样，会Crash。GitHub上有一个<a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="external">NullSafe</a>库，是专门处理这个问题的。也是用消息转发处理的。其中有段代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//get class list </div><div class="line">int numClasses = objc_getClassList(NULL, 0);</div><div class="line">Class *classes = (Class *)malloc(sizeof(Class) * (unsigned long)numClasses);</div><div class="line">numClasses = objc_getClassList(classes, numClasses);</div><div class="line"></div><div class="line">//add to list for checking</div><div class="line">for (int i = 0; i &lt; numClasses; i++)</div><div class="line">&#123;</div><div class="line">    //determine if class has a superclass</div><div class="line">    Class someClass = classes[i];</div><div class="line">    Class superclass = class_getSuperclass(someClass);</div><div class="line">    while (superclass)</div><div class="line">    &#123;</div><div class="line">        if (superclass == [NSObject class])</div><div class="line">        &#123;</div><div class="line">            [classList addObject:someClass];</div><div class="line">            [classList removeObject:[someClass superclass]];</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        superclass = class_getSuperclass(superclass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码意思是获取项目中所有的类，然后遍历，如果是NSObject的子类，就添加到NSMutableSet里。我测试了下，即使为空工程，numClasses为11970，意思是要遍历11970次，非常耗时间。并且在转发时，还要遍历这个classList，判断里面的类是否能响应调用的方法，找到了一个类能响应，就停止遍历。比较耗时间，所以我感觉这样做不太合理。所以我在上面的<code>forwardingTargetForSelector</code>里也添加了对NSNull的判断。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSNull *nul = [NSNull null];</div><div class="line">[nul performSelector:@selector(testMethod)];</div></pre></td></tr></table></figure>
<p>这样写也不会Crash.但是如果仅仅是用了NullSafe这个库，是处理不了的，因为它仅仅是把消息转发给其他类，然而并没有一个类能响应这个方法，所以一样抛出异常。</p>
<p>具体Demo：<a href="https://github.com/coderZhou10496/ZJSafeCollectionDemo" target="_blank" rel="external">Github</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/04/UIView block动画原理分析/" itemprop="url">
                  UIView block动画原理浅析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-04T18:05:52+08:00" content="2018-01-04">
              2018-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/01/04/UIView block动画原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/04/UIView block动画原理分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/04/UIView block动画原理分析/" class="leancloud_visitors" data-flag-title="UIView block动画原理浅析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们在Xcode里写下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:1 animations:^&#123;</div><div class="line">        view.center = CGPointMake(200, 200);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>我们的view就会进行动画，那么我们今天来探究两个问题</p>
<p> 1.这行代码写在block里面跟写在外面到底有什么不一样，系统是怎么处理的？</p>
<p> 2.系统是怎么知道 <code>view.center = CGPointMake(200, 200)</code> 这行代码是写在 UIView block 中的？</p>
<h3 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h3><p>动画分为隐式动画和显示动画，隐式动画就是我们并没有指定任何动画的类型，仅仅是改变了一个属性，没有加动画特效，但它却默认有动画效果。区分隐式动画和显示动画是由由CoreAnimation中的CATransaction控制的。官方文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Core Animation supports two types of transactions: implicit transactions </div><div class="line">and explicit transactions. Implicit transactions are created automatically</div><div class="line">when the layer tree is modified by a thread without an active transaction </div><div class="line">and are committed automatically when the thread&apos;s runloop next iterates. </div><div class="line">Explicit transactions occur when the the application sends the </div><div class="line">CATransaction class a begin message before modifying the layer tree, and a </div><div class="line">commit message afterwards.</div></pre></td></tr></table></figure>
<p>意思是CoreAnimation支持两种事务，显式事务和隐式事务。<br>显式事务是调用[CATransaction begin]，然后是[CATransaction commit]。当没有实现这些时CoreAnimation自动创建隐式事务，它们在线程的运行循环下一次迭代时自动提交。</p>
<p>大家按住cmd点进CALayer的头文件中看的话，会发现很多的属性的注释中，最后会有一个词叫做Animatable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/** Geometry and layer hierarchy properties. **/</div><div class="line">/* The bounds of the layer. Defaults to CGRectZero. Animatable. */</div><div class="line"></div><div class="line">@property CGRect bounds;</div></pre></td></tr></table></figure>
<p>表示直接对layer的这个属性进行赋值，会产生隐式动画。</p>
<p>比如这段代码，点击按钮改变创建的layer的背景色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">self.layer = [CALayer layer];</div><div class="line">self.layer.frame = CGRectMake(130.0f, 200.0f, 100.0f, 100.0f);</div><div class="line">self.layer.backgroundColor = [UIColor blueColor].CGColor; </div><div class="line">[self.view.layer addSublayer:self.layer];</div><div class="line"></div><div class="line">- (IBAction)click:(UIButton *)sender &#123;</div><div class="line">    sender.selected = !sender.selected;</div><div class="line">    self.layer.backgroundColor = sender.selected ? [UIColor redColor].CGColor : [UIColor blueColor].CGColor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AnimationColor1.gif" alt="image"></p>
<p>可以看到，每一次改变颜色都有默认的很短的动画效果，这个动画就是隐式动画。</p>
<p>但是假如我们这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (IBAction)click:(UIButton *)sender &#123;</div><div class="line"></div><div class="line">	[CATransaction begin];</div><div class="line">	[CATransaction setAnimationDuration:1.0];</div><div class="line">    sender.selected = !sender.selected;</div><div class="line">    self.layer.backgroundColor = sender.selected ? [UIColor redColor].CGColor : [UIColor blueColor].CGColor;</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AnimationColor2.gif" alt="image"></p>
<p>这样就是显式动画，这样我们就可以看到动画效果了。</p>
<p>在iOS 4之前我们通过下面的方式进行动画，实际上在 <code>beginAnimations:context:</code> 和 <code>commitAnimations</code>之间所有视图或者图层属性的改变而做的动画都是由于设置了CATransaction的原因,另外Block动画方法也是一样，CATransaction 的<code>begin</code> 和 <code>commit</code> 会在block块中内部自动调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[UIView beginAnimations:@&quot;...&quot; context:nil];</div><div class="line">...</div><div class="line">...</div><div class="line">[UIView commitAnimations];</div></pre></td></tr></table></figure>
<h3 id="actionForLayer-forKey-方法"><a href="#actionForLayer-forKey-方法" class="headerlink" title="actionForLayer: forKey:方法"></a>actionForLayer: forKey:方法</h3><p>CALayer有个属性delegate，创建layer时，delegate默认为nil，动画效果就按默认的隐式动画呈现。如果对delegate赋值，并且这个delegate实现了delegate方法，那么动画效果就由delegate方法控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的返回值分以下三种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.返回实现了`&lt;CAAction&gt;`的对象,就按照对象的动画效果</div><div class="line"></div><div class="line">2.返回nil，意思等同于是没有实现这个方法，隐式动画。</div><div class="line"></div><div class="line">3.返回NSNull对象，表示结束，无隐式动画。</div></pre></td></tr></table></figure>
<p>那么这个方法什么时候调用呢？是当这个layer显示、不显示、和属性改变的时候调用，并且从CALayer的头文件可以看出显示和不显示的event参数值为 <code>onOrderIn</code> 和 <code>onOrderOut</code>，改变属性的时候参数值为属性值字符串。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/Animation_key.png" alt="image"></p>
<p>初始化layer的时候，我们可以把当前viewController作为delegate，实现一下这个delegate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123;</div><div class="line">	CABasicAnimation *ani = [[CABasicAnimation alloc] init];</div><div class="line">    ani.duration = 1.0;//设置动画时间为1秒钟</div><div class="line">    return ani;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为CAAnimation相关的类已经实现了<code>&lt;CAAction&gt;</code>，所以可以直接返回CABasicAnimation对象。从下面的图中，我们可以看到同样的效果</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AnimationColor2.gif" alt="image"></p>
<p>当然我们还可以自定义对象，实现<code>&lt;CAAction&gt;</code>协议。</p>
<p>我们知道，每个UIView都有一个根Layer，UIView是根Layer的delegete。我们改变UIView的属性没有产生动画的原因就是这个方法默认返回NSNull对象。我们可以通过代码验证下：</p>
<p>将自定义view添加到UIViewController的view上，点击按钮改变背景色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MyCustomView *view = [[MyCustomView alloc] initWithFrame:CGRectMake(100, 300, 100, 100)];</div><div class="line">view.backgroundColor = [UIColor redColor];</div><div class="line">[self.view addSubview:view];</div><div class="line">self.customView = view;</div><div class="line"></div><div class="line">- (IBAction)click1:(UIButton *)sender &#123;</div><div class="line">   self.customView.backgroundColor = sender.selected ? [UIColor 			redColor] : [UIColor blueColor];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>自定义UIView,重写这个delegate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface MyCustomView : UIView</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyCustomView</div><div class="line"></div><div class="line">- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123;</div><div class="line">    id value = [super actionForLayer:layer forKey:event];</div><div class="line">    NSLog(@&quot;value:%d&quot;,[value isKindOfClass:[NSNull class]]);</div><div class="line">    return value;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/Animation_value.png" alt="image"></p>
<p>从log中可以看到返回的对象就是NSNull类型的对象，即UIView默认关闭了根layer的隐式动画。</p>
<p>那么回到我们最开始我们讨论的这个问题，既然在UIView Block中改变view的属性产生了动画，那就这个代理方法就一定返回了一个实现<code>&lt;CAAction&gt;</code>的对象。我们通过代码验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;%@&quot;,[view.layer.delegate actionForLayer:view.layer </div><div class="line">forKey:@&quot;position&quot;]);</div><div class="line"></div><div class="line"> [UIView animateWithDuration:1 animations:^&#123;</div><div class="line">        view.center = CGPointMake(200, 200);</div><div class="line">        NSLog(@&quot;%@&quot;,[view.layer.delegate actionForLayer:view.layer forKey:@&quot;position&quot;]);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/Animation_resultpng.png" alt="image"><br>通过输出可以看到，在block外面，这个方法将返回一个NSNull，在block里面返回了一个叫做UIViewAdditiveAnimationAction类的对象，通过这个私有类的类名就可以猜到，这是一个实现了<code>&lt;CAAction&gt;</code>的对象，即会产生动画。</p>
<p>总结一下：<br>每个UIView对它关联的图层都扮演了一个委托，并且提供了actionForLayer：forKey：的实现方法。当不在一个动画块的中改变相应的属性值，UIView对所有图层行为返回NULL，这时候不会有动画效果产生；反之，它就返回一个CAAction协议对应的对象，然后进行动画处理。</p>
<h3 id="系统是如何知道的"><a href="#系统是如何知道的" class="headerlink" title="系统是如何知道的"></a>系统是如何知道的</h3><p>但是系统是怎么知道我们把改变view属性的这行代码写在了Block里，然后进行动画的呢？既我们开篇讲到的第一个问题。</p>
<p>Block动画写法是在 iOS 4.0 提出来的，在 iOS 4.0之前，我们写动画的方式是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIView beginAnimations:@&quot;...&quot; context:nil];</div><div class="line">...</div><div class="line">...</div><div class="line">[UIView commitAnimations];</div></pre></td></tr></table></figure>
<p>这个context是一个全局的参数，当我们在context这个环境下改变view属性时会被context所记录下来。在 执行完<code>commitAnimations</code> 后，系统检测context内的动画内容，然后渲染绘制进行动画。Block写法其实就是对这种复杂写法的一种封装，其本质也是有全局的系统变量进行监控，只是Block更优雅，更方便。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/05/关于AFURLSessionManager的几点疑问/" itemprop="url">
                  关于AFURLSessionManager的几点疑问
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-12-05T19:16:30+08:00" content="2017-12-05">
              2017-12-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/12/05/关于AFURLSessionManager的几点疑问/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/05/关于AFURLSessionManager的几点疑问/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/12/05/关于AFURLSessionManager的几点疑问/" class="leancloud_visitors" data-flag-title="关于AFURLSessionManager的几点疑问">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这两天花了点时间看了下<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>的源码，特别是对于 <code>AFURLSessionManager</code> 这个核心类研究的比较多，其中有几个疑问，所以写篇文章来记录下</p>
<h3 id="关于AFURLSessionManager的内存泄露"><a href="#关于AFURLSessionManager的内存泄露" class="headerlink" title="关于AFURLSessionManager的内存泄露"></a>关于AFURLSessionManager的内存泄露</h3><p>这个问题在<a href="https://github.com/AFNetworking/AFNetworking/issues" target="_blank" rel="external">issues</a>上被多次提到，就是说仅仅是写个简单的请求，也会出现内存泄露的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];</div><div class="line">[manager POST:urlStringparameters:paraDic progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">        </div><div class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line">        </div><div class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>当我们在 UIViewController 写上这段代码，因为 AFHTTPSessionManager 不是全局的类，不是单利类，理论上来说，当退出当前 UIViewController 时，AFHTTPSessionManager 类的 dealloc 方法应该执行，然后事实上却没有。</p>
<p>使用Instruments分析为：<br><img src="http://ocauxqtbu.bkt.clouddn.com/AFURLSessionManager01.png" alt="image"></p>
<p>意思就是 AFURLSessionManager 持有了 NSURLSession 对象，并且 NSURLSession 的delegate 对象 为AFURLSessionManager，造成了循环引用。其实就是这行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration </div><div class="line">delegate:self delegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>为什么会出现这个问题呢？我们来看下苹果开发文档对于这个方法的描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The session object keeps a strong reference to the delegate until your app</div><div class="line"> exits or explicitly invalidates the session. If you do not invalidate the </div><div class="line"> session by calling the invalidateAndCancel or finishTasksAndInvalidate </div><div class="line"> method, your app leaks memory until it exits.</div></pre></td></tr></table></figure>
<p>果然如此，NSURLSession 对象会强引用传入的 delegate 对象直到APP退出或者手动调用方法使 session 失效，否则会出现内存泄露的问题。</p>
<p>其实解决这个内存泄露的方法也很简单，官方文档也说了，手动使其失效。我们在 block 回调里调用一下 <code>invalidateAndCancel</code> 就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[manager POST:urlString parameters:dic progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line"></div><div class="line">        </div><div class="line">        &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line"></div><div class="line">            [manager.session invalidateAndCancel];</div><div class="line">        &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">            [manager.session invalidateAndCancel];</div><div class="line">        &#125;];</div></pre></td></tr></table></figure>
<p>但是 AFNetworking 的作者为什么没有这么做呢，而是任其内存泄露？我猜测可能是当一个界面存在多个网络请求时，我们用 manager 去请求，假如在一个请求回调里调用 <code>[manager.session invalidateAndCancel]</code> 方法，那么就使其他的请求终止了，故而发生错误。并且我们在页面下拉刷新时，由于 manager.session 已失效，也会出现错误。</p>
<h3 id="为什么在block回调里可以写-self-访问属性"><a href="#为什么在block回调里可以写-self-访问属性" class="headerlink" title="为什么在block回调里可以写 self. 访问属性"></a>为什么在block回调里可以写 <code>self.</code> 访问属性</h3><p>比如这样写当前 UIViewController 仍能释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong)AFHTTPSessionManager *manager;</div><div class="line"></div><div class="line">self.manager = [[AFHTTPSessionManager alloc]init];</div><div class="line">[manager POST:urlString parameters:dic progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line"></div><div class="line">        self.XX = XX</div><div class="line">        </div><div class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>这里Controller对象是强引用了manager，block强引用了Controller，那么manager强引用了block了吗？肯定是没有的，我们来看下</p>
<p>AFHTTPSessionManager有个字典属性:mutableTaskDelegatesKeyedByTaskIdentifier：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;</div></pre></td></tr></table></figure>
<p>字典里面放的是，key是NSURLSessionTask的唯一标识，value是AFURLSessionManagerTaskDelegate对象。</p>
<p>AFURLSessionManagerTaskDelegate这个类强引用了 AFURLSessionManager 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) AFURLSessionManager *manager;</div></pre></td></tr></table></figure>
<p>1.UIViewController对象      持有    AFHTTPSessionManager对象</p>
<p>2.AFHTTPSessionManager对象  持有    字典</p>
<p>3.字典                          持有    AF…TaskDelegate对象</p>
<p>4.AF…TaskDelegate对象     持有    AFHTTPSessionManager对象(weak) </p>
<p>5.AF…TaskDelegate对象     持有    completionHandler(回调的block)</p>
<p>6.completionHandler        持有    UIViewController对象</p>
<p>看着很乱，还是看图吧</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AFURLSessionManager03.png" alt="image"></p>
<p>那么AFNetworking是怎么处理的呢，怎么打破这种循环引用呢。</p>
<p>看下这个代理方法，这个方法是请求完成后调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error &#123;</div><div class="line"></div><div class="line"> [self removeDelegateForTask:task];</div><div class="line"> </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line">    [self.lock lock];</div><div class="line">    [delegate cleanUpProgressForTask:task];</div><div class="line">    [self removeNotificationObserverForTask:task];</div><div class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个回调方法里，把 AFURLSessionManagerTaskDelegate 对象从字典中移除了，就是说字典不再持有 AFURLSessionManagerTaskDelegate 对象，所以就不存在强引用了问题了。</p>
<h3 id="关于文件下载的操作"><a href="#关于文件下载的操作" class="headerlink" title="关于文件下载的操作"></a>关于文件下载的操作</h3><p>我们来看下 <code>NSURLSessionDownloadDelegate</code> 的这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        //调用自定义的block拿到文件存储的地址</div><div class="line">        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (fileURL) &#123;</div><div class="line">            delegate.downloadFileURL = fileURL;</div><div class="line">            NSError *error = nil;</div><div class="line">            //location是临时路径，我们把数据从临时的下载路径移动至我们需要的路径</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</div><div class="line">             //如果出错</div><div class="line">            if (error) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     //转发代理</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法我下载文件完成的时候调用。如果设置了 <code>downloadTaskDidFinishDownloadingBlock</code>，就去操作数据，把数据从临时的下载路径移动至我们需要的路径，然后 return，意思就是直接返回，不再执行。</p>
<p>如果没有设置block，就把这个代理转发到 AFURLSessionManagerTaskDelegate 自定义的代理里面。在自定义代理里做了同样的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    NSError *fileManagerError = nil;</div><div class="line">    self.downloadFileURL = nil;</div><div class="line"></div><div class="line">    //AF代理的自定义Block</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        //得到自定义下载路径</div><div class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (self.downloadFileURL) &#123;</div><div class="line">            //把下载路径移动到我们自定义的下载路径</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            //错误发通知</div><div class="line">            if (fileManagerError) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即：如果设置了 <code>downloadTaskDidFinishDownloadingBlock</code>，就去操作数据，把数据从临时的下载路径移动至我们需要的路径。这一步骤跟<code>NSURLSessionDownloadDelegate</code> 里的方法完全一样。并且，如果设置了block，操作文件后直接return了，不会再转发代理了。如果没设置block，转发代理后，在自己的代理方法里又判断了是否设置了block。</p>
<p>这个转发代理的步骤看起来多余了，AF的作者为什么这样做，让我不得解，难道还有其他的用处？</p>
<h3 id="其他的一些疑问"><a href="#其他的一些疑问" class="headerlink" title="其他的一些疑问"></a>其他的一些疑问</h3><p>1.当 AFURLSessionManagerTaskDelegate 这个类把 AFURLSessionManager 对象作为属性的时候用的是 weak</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, weak) AFURLSessionManager *manager;</div></pre></td></tr></table></figure>
<p>在自定义的代理方法里，因为这个属性是weak，所以进行了下面这一步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">    //强引用self.manager，防止被提前释放；因为self.manager声明为weak</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line">    .......</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>关于这个 weak 属性，我看了下，即使换成 strong 也不会出现内存泄露的问题，因为请求完成后 AFURLSessionManager 把 AFURLSessionManagerTaskDelegate 对象从字典中移除了。并且在上面的这个方法里，也不用多去操作一步。有点不明白，为什么用weak。</p>
<p>2.AFURLSessionManagerTaskDelegate 这个类在声明的时候同样遵循了 <code>NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate协议</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, </div><div class="line">NSURLSessionDataDelegate, </div><div class="line">NSURLSessionDownloadDelegate&gt;</div></pre></td></tr></table></figure>
<p>这里不遵循协议一样是可以的。可能是作者为了使这个类更规范一些，更像官方文档那样，所以这样写</p>
<p>3.在创建 NSURLSession 对象时，指定了回调代理的queque</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.operationQueue.maxConcurrentOperationCount = 1;</div><div class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration </div><div class="line">delegate:self delegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>这里我注意到了，设置了queue的最大operation并发个数为1，实现似于串行队列的效果。难道是作者为了节省内存资源这样做的，因为即使设置了并发个数为1，NSOperation也是可以同时执行多个任务的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/一次由performSelector引发的BUG/" itemprop="url">
                  一次由performSelector引发的BUG
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-12T12:15:01+08:00" content="2017-11-12">
              2017-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/12/一次由performSelector引发的BUG/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/12/一次由performSelector引发的BUG/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/11/12/一次由performSelector引发的BUG/" class="leancloud_visitors" data-flag-title="一次由performSelector引发的BUG">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们的APP在打包后测试过程过发现，所有的按钮点击效果不灵敏了，就是有时候按钮点击一次后再点就无效了，不会响应用户的操作。这个bug我觉得非常不可思议，并且我在模拟器上，即开发环境下没有任何问题。这篇文章就这个bug，来记录一下解决问题的过程。</p>
<h3 id="找到解决bug的原因"><a href="#找到解决bug的原因" class="headerlink" title="找到解决bug的原因"></a>找到解决bug的原因</h3><p>刚才说了，是所有的按钮，并且是在 Release 模式下会出现这个问题。由于是所有的按钮，所以想到了是全局的设置，比如我们可以一行代码全局设置APP内的导航栏效果等。我在我们APP工程里找了下，只有一个文件，就是 UIButton 的分类，这个分类的作用是防止按钮重复点击，比如控制APP内所有的按钮0.5秒内只能点击一次，可是这也不会出现导致点击一次后就无法点击的问题啊。我带着疑问去看这个分类的源码，并且我单独把这个分类拷贝出来，开一个Demo工程,然后分别在 Debug，Release模式下进行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        SEL selA = @selector(sendAction:to:forEvent:);</div><div class="line">        SEL selB = @selector(zj_sendAction:to:forEvent:);</div><div class="line">        Method methodA =   class_getInstanceMethod(self,selA);</div><div class="line">        Method methodB = class_getInstanceMethod(self, selB);</div><div class="line">        BOOL isAdd = class_addMethod(self, selA, method_getImplementation(methodB), method_getTypeEncoding(methodB));</div><div class="line">        if (isAdd) &#123;</div><div class="line">            class_replaceMethod(self, selB, method_getImplementation(methodA), method_getTypeEncoding(methodA));</div><div class="line">        &#125;else&#123;</div><div class="line">            method_exchangeImplementations(methodA, methodB);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)zj_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class="line">    </div><div class="line">    if (self.zj_ignoreEvent)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (self.zj_timeInterval &gt; 0) &#123;</div><div class="line">        </div><div class="line">        self.zj_ignoreEvent = YES;</div><div class="line">        </div><div class="line">        </div><div class="line">        [self performSelector:@selector(setZj_ignoreEvent:) withObject:@(NO) afterDelay:self.zj_timeInterval];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    [self zj_sendAction:action to:target forEvent:event];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/buttonTest.jpg" alt=""></p>
<p>我们在 load 方法里替换系统的 <code>sendAction:to:forEvent:</code>方法，改为自己定义的 <code>zj_sendAction:to:forEvent:</code> 方法。在自己的方法里去用点击的间隔时间来控制，这个点击是否有效。我在 Debug 模式下试了，没问题，可以在 Release 模式确实会出现点击一次后就无法点击的诡异问题。我们注意看这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (self.zj_ignoreEvent)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码是直接不响应用户的点击操作，直接返回。只有下一次点击时间的间隔，大于我们设置的 <code>zj_timeInterval</code>，方法才会继续执行。难道说，这个属性 <code>zj_zj_ignoreEvent</code> 被永久的设置为了YES，永远无法继续执行？我们通过打断点调试发现，事实确实是我们设想的那样，点击一次之后，这个属性一直都为YES。为什么呢？当时间过了间隔时间后，我们不是 <code>performSelector</code> 使这个属性设置为 NO 了吗</p>
<h3 id="诡异的-performSelector-方法"><a href="#诡异的-performSelector-方法" class="headerlink" title="诡异的 performSelector 方法"></a>诡异的 performSelector 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(setZj_ignoreEvent:) withObject:@(NO) afterDelay:self.zj_timeInterval];</div></pre></td></tr></table></figure>
<p>为此，专门测试了一下 <code>performSelector: withObject:</code>方法<br>比如我们在项目中写下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(test:) withObject:@(NO) afterDelay:1];</div><div class="line"></div><div class="line">-(void)test:(BOOL)boolTest &#123;</div><div class="line">    NSLog(@&quot;%d&quot;,boolTest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候，当 Debug 模式下，boolTest的值确实为0，但是 Release 模式下却为2，不为0，无论加不加延迟加载结果都是一样的。难道 <code>performSelector</code> 在开发环境下，和生产环境下对数据的处理完全不一样。所以，就是这个原因导致项目中<code>zj_zj_ignoreEvent</code> 被永久的设置为了YES，按钮无法正常响应用户点击操作。</p>
<p>我们去翻了下Runtime的源码，里面对这个方法的内部实现也没有过多的解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)performSelector:(SEL)sel &#123;</div><div class="line">    if (!sel) [self doesNotRecognizeSelector:sel];</div><div class="line">    return ((id(*)(id, SEL))objc_msgSend)(self, sel);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仅仅是调用 <code>objc_msgSend</code>，而 <code>objc_msgSend</code>内部是用汇编语言写的，查阅起来比较困难。<br>我现在的解决办法是，不是用这个 <code>performSelector</code> 方法，而是使用 GCD 延迟加载的方式来实现功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.zj_timeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">            self.zj_ignoreEvent = NO;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>将原来项目中的延迟调用方法，换成这种就OK了。</p>
<p>需要额外提一下，我在网上搜防止button重复点击的开源代码，大部分都是使用<code>performSelector</code> 来延迟设置属性，以此告诫大家，不能一味的拷贝别人的代码，我在这里就吃了一个亏，虽然知道了实现原理，却在实现方法上出了错，还是要多看看代码，检查一下代码的正确性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/04/APP的启动简单优化/" itemprop="url">
                  APP的启动简单优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-04T18:33:28+08:00" content="2017-11-04">
              2017-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/04/APP的启动简单优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/04/APP的启动简单优化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/11/04/APP的启动简单优化/" class="leancloud_visitors" data-flag-title="APP的启动简单优化">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>APP的启动是指从用户点击 APP 那一刻开始到用户看到第一个界面的整个过程</p>
<h3 id="一、APP的启动过程"><a href="#一、APP的启动过程" class="headerlink" title="一、APP的启动过程"></a>一、APP的启动过程</h3><h4 id="1-启动过程"><a href="#1-启动过程" class="headerlink" title="1.启动过程"></a>1.启动过程</h4><p>简单的来说就是 App 进行编译、汇编、链接、代码签名以及启动执行等操作</p>
<h5 id="1-1-解析Info-plist"><a href="#1-1-解析Info-plist" class="headerlink" title="1.1 解析Info.plist"></a>1.1 解析Info.plist</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.加载相关信息，例如如闪屏</div><div class="line"></div><div class="line">2.沙箱建立、权限检查</div></pre></td></tr></table></figure>
<h5 id="1-2-Mach-O加载"><a href="#1-2-Mach-O加载" class="headerlink" title="1.2 Mach-O加载"></a>1.2 Mach-O加载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1.如果是胖二进制文件，寻找合适当前CPU类别的部分</div><div class="line"></div><div class="line"> (由于需要支持不同CPU架构的iOS设备，所以我们编译打包出来的执行文件是一个Universal Binary格式文件，通用二进制文件，也称胖二进制文件)</div><div class="line"> </div><div class="line">2.加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）</div><div class="line"></div><div class="line">3.定位内部、外部指针引用，例如字符串、函数等</div><div class="line"></div><div class="line">4.执行声明为__attribute__((constructor))的C函数</div><div class="line"></div><div class="line">5.加载类扩展（Category）中的方法</div><div class="line"></div><div class="line">6.C++静态对象加载、调用ObjC的 +load 函数</div><div class="line"></div><div class="line">关于Mach-O文件的格式以及详细的加载过程，可看[这篇文章](http://www.jianshu.com/p/54d842db3f69)</div></pre></td></tr></table></figure>
<h5 id="1-3-程序执行"><a href="#1-3-程序执行" class="headerlink" title="1.3 程序执行"></a>1.3 程序执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1.main函数</div><div class="line"></div><div class="line">2.执行 UIApplicationMain 函数</div><div class="line"></div><div class="line">3.创建 UIApplication 对象</div><div class="line"></div><div class="line">4.创建UIApplicationDelegate对象</div><div class="line"></div><div class="line">5.读取配置文件info.plist，设置程序启动的一些属性</div><div class="line"></div><div class="line">6.创建应用程序的Main Runloop循环</div><div class="line"></div><div class="line">7.UIApplicationDelegate对象开始处理监听对象</div><div class="line"></div><div class="line">8.调用didFinishLaunchingWithOptions方法</div><div class="line"></div><div class="line">9.如果info.plist中配置了启动的storyBoard的文件名，加载storyboard文件，如果没有，创建UIWindow —&gt; rootViewController 显示</div></pre></td></tr></table></figure>
<h3 id="二、启动时间的计算"><a href="#二、启动时间的计算" class="headerlink" title="二、启动时间的计算"></a>二、启动时间的计算</h3><h4 id="2-1-main-函数之前"><a href="#2-1-main-函数之前" class="headerlink" title="2.1 main()函数之前"></a>2.1 main()函数之前</h4><p>苹果已经给出了方法来帮我们计算这部分的启动时间：<br>在Xcode的菜单中选择<code>Project</code> → <code>Scheme→Edit Scheme</code>，然后找到 <code>Run</code> →  <code>Environment Variables</code>，添加name为 <code>DYLD_PRINT_STATISTICS</code> 为1的环境变量，然后运行APP，会在控制台有一个输出。例如，我在之前的一个项目中加入以上设置后：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/blog_runTime.png" alt=""></p>
<p>1.main()函数之前总共使用了401.01ms</p>
<p>2.在401.01ms中，加载动态库用了112.08ms，指针重定位使用了161.83ms，ObjC类初始化使用了71.04ms，各种初始化使用了55.93ms。</p>
<p>3.在初始化耗费的55.93ms中，用时最多的三个初始化是libSystem.B.dylib、libMainThreadChecker.dylib以及XiaoBanBattery(自己的项目名称)。</p>
<h4 id="2-2-main-函数之后"><a href="#2-2-main-函数之后" class="headerlink" title="2.2 main()函数之后"></a>2.2 main()函数之后</h4><p>从main()函数开始至applicationWillFinishLaunching结束，再到完成数据的加载并展示相关信息给用户。</p>
<p>我们可以自己在这个过程中插入代码，从而获得这段时间。比如在didFinishLaunchingWithOptions获取一下时间，再在第一个主界面viewDidAppear获取一下时间，算出时间差。</p>
<h3 id="三、启动时间的优化"><a href="#三、启动时间的优化" class="headerlink" title="三、启动时间的优化"></a>三、启动时间的优化</h3><p>一个App完整的启动时间应该保证400ms之内,而若超过20s后还未完全启动App,那么App进程就会被系统杀死。那么如何来提升启动速度呢？</p>
<h4 id="1-移除不需要用到的动态库"><a href="#1-移除不需要用到的动态库" class="headerlink" title="1. 移除不需要用到的动态库"></a>1. 移除不需要用到的动态库</h4><p>每个App都进行动态库加载,其中系统级别的动态库占据了绝大数,而针对系统级别的动态库都是经过系统高度优化的,不用担心时间的花费.所以我们应该关注于自己集成到App的那些动态库,有些库集成进来了，但是没在代码中用到，一样会需要时间来加载它。所以移除移除不需要用到的动态库是很有必要的。</p>
<h4 id="2-移除不需要用到的类"><a href="#2-移除不需要用到的类" class="headerlink" title="2. 移除不需要用到的类"></a>2. 移除不需要用到的类</h4><p>日常代码的维护非常重要，如果一个业务去掉了，就应该在当时删掉相关的代码，否则的话无用的代码就会越来越多。日后，再去找这些无用的代码，应该没那么方便了。</p>
<h4 id="3-合并功能类似的类和分类"><a href="#3-合并功能类似的类和分类" class="headerlink" title="3. 合并功能类似的类和分类"></a>3. 合并功能类似的类和分类</h4><p>这样做主要是为了加快程序的整个动态链接, 在进行动态库的重定位和绑定过程中减少指针修正的使用,加快程序机器码的生成。所以要合并一些在工程、架构上没有太大意义的类和分类。</p>
<h4 id="4-使用initialize方法进行必要的初始化工作"><a href="#4-使用initialize方法进行必要的初始化工作" class="headerlink" title="4. 使用initialize方法进行必要的初始化工作"></a>4. 使用initialize方法进行必要的初始化工作</h4><p>如果不是非必须的，我们要用+initialize方法替换调用原先在OC的+load方法中执行初始代码工作,从而加快所有类文件的加载速度。</p>
<h4 id="5-压缩资源图片"><a href="#5-压缩资源图片" class="headerlink" title="5. 压缩资源图片"></a>5. 压缩资源图片</h4><p>启动的时候加载图片，图片小了，IO操作量就小了，启动当然就会快了，但是还是要以图片的质量，清晰度为前提下。</p>
<h4 id="6-优化rootViewController加载"><a href="#6-优化rootViewController加载" class="headerlink" title="6. 优化rootViewController加载"></a>6. 优化rootViewController加载</h4><p>在didFinishLaunchingWithOptions方法里，我们一般进行初始化第三方SDK、自己的一些工具类的初始化、然后再到第一个界面的渲染。其实这些东西也可以分开来做：</p>
<p>1.最先配置的事件，比如日志，统计等可以在没有设置rootViewController前进行初始化。</p>
<p>2.第三方SDK，比如推送，支付SDk，直播SDk的集成，可以在设置rootViewController后进行初始化，这样不会影响第一个视图的加载，毕竟人的视觉看到视图出现很快，就会觉得加载很快。</p>
<p>3.工具类的初始化配置。比如集成了IQKeyboardManager,需要启动的时候进行全局设置，这个操作可以放在第一个界面的viewDidAppear，这里完全不会影响到启动时间。</p>
<p>本文只是简单简述了APP的启动，比如点击APP图标后，动态库是如何链接到内存中的，代码的二进制文件是如何加载的等这些过程还需更深层次的探究。对于优化启动时间这个方面，我们只能做的就是写出更好的代码，优化项目。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/24/三次握手及四次挥手/" itemprop="url">
                  三次握手及四次挥手
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-24T18:25:39+08:00" content="2017-10-24">
              2017-10-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/24/三次握手及四次挥手/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/24/三次握手及四次挥手/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/10/24/三次握手及四次挥手/" class="leancloud_visitors" data-flag-title="三次握手及四次挥手">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们向服务器发送HTTP请求，获取数据、修改信息时，为实现数据的可靠传输，都需要建立TCP连接，包括三次握手，四次挥手。在理解三次握手，四次挥手之前，我们先了解TCP首部包含的数据及各个字段的含义，因为连接与断开连接要用到其中的字段</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/TCPConnect1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">源端口号：Source Port,发送数据的源进程端口</div><div class="line"></div><div class="line">目的端口号：Destination Port,接收数据的进程端口</div><div class="line"></div><div class="line">序号：Sequence Number,在一个TCP连接中传送的字节流中每一个字节都是按顺序编号的，</div><div class="line">这里的序号是指发送的时候本报文段的第一个字节的序,当ACK标志位为1时才生效</div><div class="line"></div><div class="line">确认序列号：Acknowledgement Number,是期望收到下一个报文段的第一个数据字节的序号</div><div class="line"></div><div class="line">首部长度：Data Offset,也称为数据偏移，其代表的意思是本报文的数据起始处距离本报文段的起始处有多远，因为TCP首部中存在可选字段，所以首部长度不固定</div><div class="line"></div><div class="line">保留位：Reserved,目前未使用，置0</div><div class="line"></div><div class="line">控制位：Control Flag,其实是有6个控制位，其中包括：</div><div class="line"></div><div class="line">  SYN:表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，</div><div class="line">  当连接请求的时候，SYN=1，ACK=0。连接被响应的时候，SYN=1，</div><div class="line">  ACK=1。这个标志的数据包经常被用来进行端口扫描。扫描者发送一个</div><div class="line">  只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台</div><div class="line">  主机存在这个端口。但是由于这种扫描方式只是进行TCP三次握手的第一</div><div class="line">  次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的</div><div class="line">  主机将会强制要求一个连接严格的进行TCP的三次握手</div><div class="line">		</div><div class="line">  ACK: 此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在</div><div class="line">  TCP数据包中。有两个取值: 0和1，为1的时候表示应答域有效，反之为0</div><div class="line">		</div><div class="line">  FIN:表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有</div><div class="line">  数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个</div><div class="line">  标志的数据包也经常被用于进行端口扫描</div><div class="line">		</div><div class="line">  URG:为紧急序号，URG=1是紧急指针有效；</div><div class="line">		</div><div class="line">  PSH:指示接收方立即将数据提交给应用层，而不是等待缓冲区满；</div><div class="line">		</div><div class="line">  RST:重置连接。</div><div class="line">		</div><div class="line"></div><div class="line">  窗口大小：Window Size ,也就是有名的滑动窗口，用来进行流量控制</div><div class="line"></div><div class="line">  校验和：Checksum,用来校验首部和数据部分</div><div class="line"></div><div class="line">  紧急指针：Urgent Pointer,只有在URG位=1的时候才有效,紧急指</div><div class="line">  针的值与序号的相加值为紧急数据的最后一个字节位置。用于发送紧急数据</div></pre></td></tr></table></figure>
<p>关于连接和断开连接，直接上图，下面再文字解释</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/TCPConnect2.png" alt=""></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>1.第一次握手：客户端发送连接请求报文段，将SYN位置为1，Sequence Number为X(由操作系统动态随机选取一个32位长的序列号)；然后，客户端进入SYN_SEND状态，等待服务器的确认</p>
<p>2.第二次握手: 服务器收到客户端的SYN报文段。需要对这个SYN报文段进行确认，设置确认序列号Ack为X+1。同时，自己还要发送SYN请求信息，将SYN位置为1，ACK为1，序号Seq为K(由操作系统动态随机选取一个32位长的序列号)。服务器端将上述所有信息一并发送给客户端，此时服务器进入SYN_RECV状态</p>
<p>3.第三次握手: 客户端收到服务器的报文段。确认序列号Ack为K+1，序号Seq为X+1(第二次握手中的Ack值)，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手</p>
<h4 id="那么为什么要三次握手呢，两次不就够了吗？"><a href="#那么为什么要三次握手呢，两次不就够了吗？" class="headerlink" title="那么为什么要三次握手呢，两次不就够了吗？"></a>那么为什么要三次握手呢，两次不就够了吗？</h4><p>因为要防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，比如：<br>client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>1.第一次挥手: 主动关闭方(可以是客户端，也可以是服务端，这里假设为客户端)，将FIN置为1，ACK置为1，序号Seq设置为J，即上一次对方传送过来的Ack值，Ack设置为K,即为上一次对方传过来的Seq的值+1。设置好以上值后，将数据发送至被动关闭方。主动关闭方进入FIN_WAIT_1状态。</p>
<p>2.第二次挥手：服务端收到了客户端发送的FIN报文段，向客户端回复，将ACK置为1，确认序号Ack设置为J+1,即第一次挥手中的Seq值+1，Seq设置为K，即第一次挥手中的Ack值。然后服务端进入CLOSE_WAIT状态，客户端收到服务端的回复后，进入FIN_WAIT_2状态。</p>
<p>3.第三次挥手：服务端再次向客户端发送报文，将FIN置为1，ACK置为1，Ack设置为J+1,即第二次挥手中的Ack值，序号Seq设置为K,第二次挥手中的Seq值。然后服务端进入LAST_ACK状态</p>
<p>4.第四次挥手：客户端收到服务端发送的FIN报文段，向服务端回复，将ACK置为1，Ack设置为K+1,，序号Seq设置为J+1,即第三次挥手中的Ack值。然后客户端进入TIME_WAIT状态，服务端在收到报文后进入CLOSED状态，客户端在发送完报文等待了2MSL时间后进入CLOSED状态。至此，断开连接。</p>
<h4 id="为什么客户端在发送最后一次报文后，等待2MSL之后才关闭连接呢？"><a href="#为什么客户端在发送最后一次报文后，等待2MSL之后才关闭连接呢？" class="headerlink" title="为什么客户端在发送最后一次报文后，等待2MSL之后才关闭连接呢？"></a>为什么客户端在发送最后一次报文后，等待2MSL之后才关闭连接呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">因为这个ACK报文段有可能丢失，因而使处在LAST_ACK状态的服务端收不到对自己已发送的FIN+ACK</div><div class="line">报文段的确认，所以的服务端会超时重传这个FIN+ACK报文段。而客户端就能在2MSL时间内收到这个</div><div class="line">重传的FIN+ACK报文段。接着客户端重传一次确认，最后两者都正常进入到CLOSED状态。如果客户端</div><div class="line">在TIME_WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到服务</div><div class="line">端重传的FIN+ACK报文段，因而也不会在发送一次确认报文段。这样，服务端就无法按照正常步骤进入</div><div class="line">CLOSED状态。</div></pre></td></tr></table></figure>
<h4 id="为什么断开连接是四次挥手呢？像开始连接一样，三次不行吗？"><a href="#为什么断开连接是四次挥手呢？像开始连接一样，三次不行吗？" class="headerlink" title="为什么断开连接是四次挥手呢？像开始连接一样，三次不行吗？"></a>为什么断开连接是四次挥手呢？像开始连接一样，三次不行吗？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TCP四次挥手中的第二次、第三次挥手都是向客户端发送数据，那么这两次能否也能合为一次呢？答案</div><div class="line">是不行的。当开始连接时，服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把</div><div class="line">ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当服务端收</div><div class="line">到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了，服务端可能还存在着需要发送给客户</div><div class="line">端但是未发送的数据。所以，再发送FIN报文给对方来表示同意现在可以关闭连接了，所以它这里的</div><div class="line">ACK报文和FIN报文多数情况下都是分开发送的。</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/06/crash分析/" itemprop="url">
                  Crash分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-08-06T10:06:55+08:00" content="2017-08-06">
              2017-08-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/08/06/crash分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/08/06/crash分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/08/06/crash分析/" class="leancloud_visitors" data-flag-title="Crash分析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、-Crash文件的获取"><a href="#一、-Crash文件的获取" class="headerlink" title="一、 Crash文件的获取"></a>一、 Crash文件的获取</h3><p>在开发的过程中，难免会遇到应用crash的发生，了解为何会发生crash，对我们以后写代码的稳定有非常大的作用。应用的每一次闪退，手机会自动的把这次闪退记录下来，以文件的形式保存到手机上。Crash文件的获取分两种情况，一种是在测试阶段，一种是线上APP。</p>
<h4 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h4><p>在测试阶段，假如测试人员专业的话，应用奔溃时，会告诉你什么时候崩溃了，点击哪个按钮崩溃了。但是不专业的话，可能告诉你的信息就不那么全了。但是我们可以通过分析crash文件，来定位闪退的原因。通过打AdHoc包将APP安装到手机上，假如发生闪退了，可以把手机拿过来，通过iTunes连接，将crash信息同步到电脑上</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_tongbu.png" alt="image"></p>
<p>点击同步后，电脑上这个文件夹下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Logs/CrashReporter/MobileDevice</div></pre></td></tr></table></figure>
<p>就能找到对应设备的crash文件了</p>
<h4 id="线上APP"><a href="#线上APP" class="headerlink" title="线上APP"></a>线上APP</h4><p>APP上线以后，crash文件的获取在Xcode - Windwo - Organizer - Crashes<br>这里面列出了每个APP版本的闪退信息，通过Show in Finder也能获取到crash文件。但注意的是，这个Xcode，必须是上传时用的Xcode。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_list.png" alt="image"></p>
<p>之前有人说，通过开发者中心，iTunes Connect，也能获取到，我去看了下，好像没有这个选项了。另外，假如苹果在审核的时候，发生闪退，被打了回来，审核团队也会提供一份crash文件，我们可以直接用来分析。</p>
<h3 id="二、-Crash文件的分析"><a href="#二、-Crash文件的分析" class="headerlink" title="二、 Crash文件的分析"></a>二、 Crash文件的分析</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>文件分析需要四样东西，crash文件，symbolicatecrash分析工具，闪退APP的打包后的.APP文件，以及此包对应的.dSYM符号表文件。我们在桌面上新建一个文件夹，命名为crash文件分析，一样一样准备就行了。</p>
<p>获取crash文件我们上面已经了解到了，symbolicatecrash分析工具是Xcode自带的，我们只需要拿来用就行，打开终端，输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find /Applications/Xcode.app -name symbolicatecrash -type f</div></pre></td></tr></table></figure>
<p>过几秒钟，symbolicatecrash分析工具的路径就会显示出来，我们进入这个路径中，将symbolicatecrash分析工具拷贝到桌面上刚才创建的crash文件分析的文件夹中</p>
<p>.APP及.dSYM符号表文件的获取：</p>
<p>在Organizer - Archives里显示的有打过的包，找到crash发生对应的那个版本包，然后 Show in Finder,显示包内容,.dSYM文件在dSYMs文件夹下，.APP文件在Products - Applications文件夹下。分别拷贝他们到桌面的crash文件分析的文件夹中</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_dsym.png" alt="image"></p>
<h4 id="dSYM符号表是什么？"><a href="#dSYM符号表是什么？" class="headerlink" title=".dSYM符号表是什么？"></a>.dSYM符号表是什么？</h4><p>符号表就是指在Xcode项目编译后，在编译生成的二进制文件.app的同级目录下生成的同名的.dSYM文件。.dSYM文件其实是一个目录，在子目录中包含了一个16进制的保存函数地址映射信息的中转文件，所有Debug的symbols都在这个文件中(包括文件名、函数名、行号等)，所以也称之为调试符号信息文件。一般地，Xcode项目每次编译后，都会生成一个新的.dSYM文件。因此，App的每一个发布版本，都需要备份一个对应的.dSYM文件，以便后续调试定位问题。</p>
<p>符号表有什么用<br>符号表的作用是把崩溃中的函数地址解析为函数名等信息。如果开发者能够获取到崩溃的函数地址信息，就可以利用符号表分析出具体的出错位置。<br> 在Xcode开发调试App时，一旦遇到崩溃问题，开发者可以直接使用Xcode的调试器定位分析。<br> 但如果App发布上线，开发者不可能进行调试，只能通过分析系统记录的崩溃日志来定位问题，在这份崩溃日志文件中，会指出App出错的函数内存地址，而这些函数地址是可以在.dSYM文件中找到具体的文件名、函数名和行号信息的，这正是符号表的重要作用所在，也是为什么要进行符号表进行管理，并纪录这是哪个版本的符号表。</p>
<h4 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h4><p>打开终端，cd到刚才创建的文件夹下，输入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./symbolicatecrash /Users/用户名/Desktop/crash文件/watchnail-2017-08-03-143201.crash /Users/用户名/Desktop/crash文件/watchnail.app.dSYM &gt; result.crash</div></pre></td></tr></table></figure>
<p>这个时候可能会出现一个error</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</div></pre></td></tr></table></figure>
<p>不用怕，继续输入指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export DEVELOPER_DIR=&quot;/Applications/XCode.app/Contents/Developer&quot;</div></pre></td></tr></table></figure>
<p>然后再输入一遍刚开始的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./symbolicatecrash /Users/用户名/Desktop/crash文件/watchnail-2017-08-03-143201.crash /Users/用户名/Desktop/crash文件/watchnail.app.dSYM &gt; result.crash</div></pre></td></tr></table></figure>
<p>这个时候如果成功的话，文件夹下回多出一个文件，名字为result.crash文件</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_result.png" alt="image"></p>
<p>而这个文件就是我们最终需要的文件，直接打开，里面列出了闪退时的各种信息：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_wenjian.png" alt="image"></p>
<p><code>Incident Identifier</code>：崩溃报告的唯一标识符，不同的Crash日志该标示符也不同。</p>
<p><code>CrashReporter Key</code>：设备标识相对应的唯一键值(并非真正的设备的UDID，苹果为了保护用户隐私iOS6以后已经无法获取)。通常同一个设备上同一版本的App发生Crash时，该值都是一样的。</p>
<p><code>Hardware Model</code> ：代表发生Crash的设备类型。</p>
<p><code>Process</code>：代表系统Crash的进程名称，通常都是我们的App的名字, [ ]里面是当时进程的ID。</p>
<p><code>Path</code>：App的所在路径。</p>
<p><code>Identifier</code>：我们App的Indentifier，通常为“com.xxx.yyy”，xxx代表公司的域名，yyy代表某一个App标识。</p>
<p><code>AppVersion</code>：当前App的版本号，由Info.plist中的两个字段组成，CFBundleShortVersionString and CFBundleVersion。</p>
<p><code>Code Type</code>：当前App的CPU架构。<br><code>Role</code>:表示crash时，程序在前台运行还是在后台<br><code>Parent Process</code>：当前进程的父进程，由于iOS中App通常都是单进程的，一般父进程都是launchd。</p>
<p><code>Date/Time</code>：发生crash的时间</p>
<p><code>Launch Time</code>：启动App的时间</p>
<p><code>OS Version</code>：iOS系统固件版本</p>
<p><code>Report Version</code>：日志版本</p>
<p><code>Exception Type</code>： 异常的类型<br>常见的Exception Type异常类型的信息</p>
<p>EXC_BAD_ACCESS：此类型是最常见的crash, 通常用于访问了不该访问的内存导致的，野指针错误形式在Xcode中通常表现就为这个</p>
<p>SIGSEGV:通常由于重复释放对象导致, 一般在ARC以后很少见到</p>
<p>SIGABRT: 收到Abort信号退出,</p>
<p>SEGV(Segmentation Violation): 代表无效内存地址, 比如空指针, 未初始化指针, 栈溢出等.</p>
<p>SIGBUS:总栈错误, 与SIGSEGV不同的是, SIGSEGV访问的是无效的地址, 而SIGBUS访问的是有效的地址, 但是总栈访问异常(如地址对齐问题)</p>
<p><code>Exception Codes</code>:  异常出错的代码</p>
<p><code>Exception Note</code>:  异常通知</p>
<p><code>Triggered by Thread</code>： 问题发生的thread</p>
<p><code>Last Exception Backtrace</code>:     最后异常回溯，一般根据这个代码就能找到crash的具体问题</p>
<p>下面来看下我这个crash文件，没有处理前的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Last Exception Backtrace:</div><div class="line">(0x18bdaafd8 0x18a80c538 0x18bdb1ef4 0x18bdaef4c 0x18bcaad2c </div><div class="line">0x18c887bfc 0x18bd59a9c 0x18bd597a0 0x18bd59060 0x18bd56c84 0x18bc86d94 0x18d6f0074 0x191f38130 0x1001a34d8 0x18ac9559c)</div><div class="line"></div><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libsystem_kernel.dylib        	0x000000018ada5014 0x18ad86000 + 126996</div><div class="line">1   libsystem_pthread.dylib       	0x000000018ae6f334 0x18ae6a000 + 21300</div><div class="line">2   libsystem_c.dylib             	0x000000018ad199c4 0x18acb8000 + 399812</div><div class="line">3   libc++abi.dylib               	0x000000018a7e51b0 0x18a7e4000 + 4528</div><div class="line">4   libc++abi.dylib               	0x000000018a7fb5f0 0x18a7e4000 + 95728</div><div class="line">5   libc++abi.dylib               	0x000000018a7fb1a8 0x18a7e4000 + 94632</div><div class="line">6   libobjc.A.dylib               	0x000000018a80c6f8 0x18a804000 + 34552</div><div class="line">7   CoreFoundation                	0x000000018bc86e00 0x18bc7e000 + 36352</div><div class="line">8   GraphicsServices              	0x000000018d6f0074 0x18d6e4000 + 49268</div><div class="line">9   UIKit                         	0x0000000191f38130 0x191ec3000 + 479536</div><div class="line">10  watchnail                     	0x00000001001a34d8 0x100060000 + 1324248</div><div class="line">11  libdyld.dylib                 	0x000000018ac9559c 0x18ac91000 + 17820</div></pre></td></tr></table></figure>
<p>处理后的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Last Exception Backtrace:</div><div class="line">0   CoreFoundation                	0x18bdaafd8 __exceptionPreprocess + 124</div><div class="line">1   libobjc.A.dylib               	0x18a80c538 objc_exception_throw + 56</div><div class="line">2   CoreFoundation                	0x18bdb1ef4 -[NSObject(NSObject) doesNotRecognizeSelector:] + 140</div><div class="line">3   CoreFoundation                	0x18bdaef4c ___forwarding___ + 916</div><div class="line">4   CoreFoundation                	0x18bcaad2c _CF_forwarding_prep_0 + 92</div><div class="line">5   Foundation                    	0x18c887bfc __NSFireDelayedPerform + 408</div><div class="line">6   CoreFoundation                	0x18bd59a9c __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 28</div><div class="line">7   CoreFoundation                	0x18bd597a0 __CFRunLoopDoTimer + 856</div><div class="line">8   CoreFoundation                	0x18bd59060 __CFRunLoopDoTimers + 244</div><div class="line">9   CoreFoundation                	0x18bd56c84 __CFRunLoopRun + 1484</div><div class="line">10  CoreFoundation                	0x18bc86d94 CFRunLoopRunSpecific + 424</div><div class="line">11  GraphicsServices              	0x18d6f0074 GSEventRunModal + 100</div><div class="line">12  UIKit                         	0x191f38130 UIApplicationMain + 208</div><div class="line">13  watchnail                     	0x1001a34d8 main (main.m:14)</div><div class="line">14  libdyld.dylib                 	0x18ac9559c start + 4</div><div class="line"></div><div class="line"></div><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libsystem_kernel.dylib        	0x000000018ada5014 __pthread_kill + 8</div><div class="line">1   libsystem_pthread.dylib       	0x000000018ae6f334 pthread_kill + 112</div><div class="line">2   libsystem_c.dylib             	0x000000018ad199c4 abort + 140</div><div class="line">3   libc++abi.dylib               	0x000000018a7e51b0 __cxa_bad_cast + 0</div><div class="line">4   libc++abi.dylib               	0x000000018a7fb5f0 std::__terminate(void (*)()) + 44</div><div class="line">5   libc++abi.dylib               	0x000000018a7fb1a8 __cxa_rethrow + 144</div><div class="line">6   libobjc.A.dylib               	0x000000018a80c6f8 objc_exception_rethrow + 44</div><div class="line">7   CoreFoundation                	0x000000018bc86e00 CFRunLoopRunSpecific + 532</div><div class="line">8   GraphicsServices              	0x000000018d6f0074 GSEventRunModal + 100</div><div class="line">9   UIKit                         	0x0000000191f38130 UIApplicationMain + 208</div><div class="line">10  watchnail                     	0x00000001001a34d8 main (main.m:14)</div><div class="line">11  libdyld.dylib</div></pre></td></tr></table></figure>
<p>可以看出，原来的函数地址，都被还原成了函数名。我们通过<code>Triggered by Thread</code>得到问题发生的线程，再去找相应的线程模块，就可以找到问题所在了。</p>
<p>我这个测试demo中，crash发生在主线程，崩溃原因为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[NSObject(NSObject) doesNotRecognizeSelector:]</div></pre></td></tr></table></figure>
<p>意思是没有实现相应的方法。但是美中不足的是，只提示了是什么原因导致的crash，并没有提示是哪个类不识别这个方法，难道需要其他的方法，来定位crash时所在的类？</p>
<p>现在也有很多的第三方服务来专门收集crash，如友盟，Bugly等等，不只是crash，还有对卡顿，性能的检测等等。</p>
<h3 id="三、-常见的crash类型"><a href="#三、-常见的crash类型" class="headerlink" title="三、 常见的crash类型"></a>三、 常见的crash类型</h3><h4 id="unrecognized-selector-crash"><a href="#unrecognized-selector-crash" class="headerlink" title="unrecognized selector crash"></a>unrecognized selector crash</h4><p>这个原因通常是一个对象调用了一个不属于它方法的方法导致的。</p>
<p>预防：使用Runtime的消息转发来实现</p>
<ol>
<li>动态创建一个桩类</li>
<li>动态为桩类添加对应的Selector，用一个通用的返回0的函数来实现该SEL的IMP</li>
<li>将消息直接转发到这个桩类对象上。</li>
</ol>
<h4 id="KVO-crash"><a href="#KVO-crash" class="headerlink" title="KVO crash"></a>KVO crash</h4><ol>
<li>KVO的被观察者dealloc时仍然注册着KVO导致的crash</li>
<li>添加KVO重复添加观察者或重复移除观察者（KVO注册观察者与移除观察者不匹配）导致的crash</li>
</ol>
<p>预防：被观察对象持有一个KVO的delegate，所有和KVO相关的操作均通过delegate来进行管理，delegate通过建立一张map来维护KVO整个关系。</p>
<p>这里极力推荐一个facebook开源的关于管理KVO的开源库<a href="https://github.com/facebook/KVOController" target="_blank" rel="external">KVOController</a></p>
<h4 id="NSNotification-crash"><a href="#NSNotification-crash" class="headerlink" title="NSNotification crash"></a>NSNotification crash</h4><p>当一个对象添加了notification之后，如果dealloc的时候，仍然持有notification，就会出现NSNotification类型的crash。<br>所幸的是，苹果在iOS9之后专门针对于这种情况做了处理，所以在iOS9之后，即使开发者没有移除observer，Notification crash也不会再产生了。<br>不过针对于iOS9之前的用户，我们还是有必要做一下NSNotification Crash的防护的。</p>
<h4 id="NSTimer-crash"><a href="#NSTimer-crash" class="headerlink" title="NSTimer crash"></a>NSTimer crash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</div></pre></td></tr></table></figure>
<p>使用这个方法时，NSTimer会强引用target实例，所以需要在合适的时机invalidate定时器，否则就会由于定时器timer强引用target的关系导致target不能被释放，造成内存泄露，甚至在定时任务触发时导致crash。</p>
<h4 id="Container-crash"><a href="#Container-crash" class="headerlink" title="Container crash"></a>Container crash</h4><p>Container 类型的crash 指的是容器类的crash，常见的有NSArray／NSMutableArray／NSDictionary／NSMutableDictionary／NSCache的crash。 一些常见的越界、插入nil等错误操作均会导致此类crash发生</p>
<h4 id="野指针crash"><a href="#野指针crash" class="headerlink" title="野指针crash"></a>野指针crash</h4><p>在App的所有Crash中，访问野指针导致的Crash占了很大一部分</p>
<h4 id="非主线程刷UI类型crash"><a href="#非主线程刷UI类型crash" class="headerlink" title="非主线程刷UI类型crash"></a>非主线程刷UI类型crash</h4><p>非主线程刷UI将会导致app运行crash，所以一定要在主线程中进行UI操作</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/20/OC与JS的交互/" itemprop="url">
                  OC与JS的交互
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-20T22:00:41+08:00" content="2017-05-20">
              2017-05-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/20/OC与JS的交互/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/20/OC与JS的交互/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/05/20/OC与JS的交互/" class="leancloud_visitors" data-flag-title="OC与JS的交互">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在开发的过程中，免不了要与webView打交道，比如一个活动页面，或者一个比较复杂的界面，H5同事写好之后直接给安卓、iOS开发的人调用就行了，但这里就需要用到 Objective-C 与 JavaScript 交互的知识了，OC调用JS的方法，JS调用OC的方法，以及它们之间传值等。闲暇之余花了一些时间整理了一下，大致就一下三种方式来进行交互，相关代码已传至<a href="https://github.com/coderZhou10496/Objective-CInteractiveWithJS" target="_blank" rel="external">Github</a></p>
<h3 id="一、通过UIWebView代理方法，拦截URL的方法"><a href="#一、通过UIWebView代理方法，拦截URL的方法" class="headerlink" title="一、通过UIWebView代理方法，拦截URL的方法"></a>一、通过UIWebView代理方法，拦截URL的方法</h3><h4 id="OC调用JS"><a href="#OC调用JS" class="headerlink" title="OC调用JS"></a>OC调用JS</h4><p>OC调用js是通过这个方法，来实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;</div></pre></td></tr></table></figure>
<p>在 Demo 中，我们先通过这个方法注入js方法，当然这个js方法可以直接先写在html文件中，就不用注入了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-(void)webViewDidFinishLoad:(UIWebView *)webView</div><div class="line">&#123;</div><div class="line">    [self.webView stringByEvaluatingJavaScriptFromString:[self loadJsFile:@&quot;test&quot;]];</div><div class="line"></div><div class="line">&#125;</div><div class="line">- (NSString *)loadJsFile:(NSString*)fileName</div><div class="line">&#123;</div><div class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;js&quot;];</div><div class="line">    NSString *jsScript = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];</div><div class="line">    return jsScript;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在点击方法里调用这个js方法就行了，返回值即为js方法的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (IBAction)click:(id)sender</div><div class="line">&#123;</div><div class="line">    //     OC 调用 JS</div><div class="line">    //    在OC中通过代码调用JS中名为calculate的方法,并传入两个参数</div><div class="line">    NSString *string =  [self.webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@&quot;calculate(&apos;%d&apos;,&apos;%d&apos;)&quot;,1,2]];</div><div class="line">    </div><div class="line">    NSLog(@&quot;resultString: %@&quot;,string);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="JS调用OC"><a href="#JS调用OC" class="headerlink" title="JS调用OC"></a>JS调用OC</h4><p>JS调用OC通过这个方法来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:</div><div class="line">(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</div></pre></td></tr></table></figure>
<p>在这个方法里，我们能拿到urlString，通过这个url进行判断来调用原生OC方法，例如，在js中，方法为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    function scanClick() &#123;</div><div class="line">        window.location.href = &quot;MyAction://scanClickOperation&quot;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    function shakeClick() &#123;</div><div class="line">    window.location.href = &quot;MyAction://shakeClickOperation&quot;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>我们通过UIWebView的代理方法，进行拦截判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//    通过 scheme 来拦截是否是自定义的 URL</div><div class="line">    if([[request.URL scheme] isEqualToString:@&quot;myaction&quot;])</div><div class="line">    &#123;</div><div class="line">        if([[request.URL host] isEqualToString:@&quot;scanClickOperation&quot;])</div><div class="line">        &#123;</div><div class="line">            NSLog(@&quot;扫一扫&quot;);</div><div class="line">        &#125;</div><div class="line">        if([[request.URL host] isEqualToString:@&quot;shakeClickOperation&quot;])</div><div class="line">        &#123;</div><div class="line">            NSLog(@&quot;摇一摇&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">    </div><div class="line">////    也可以通过这种方式来</div><div class="line">//    if([request.URL.absoluteString rangeOfString:@&quot;scanClickOperation&quot;].location != NSNotFound)</div><div class="line">//    &#123;</div><div class="line">//        NSLog(@&quot;扫一扫&quot;);</div><div class="line">//    &#125;</div></pre></td></tr></table></figure>
<p>GitHub上demo给的很详细，大家可以下载下来看下。</p>
<h3 id="二、WebViewJavascriptBridge"><a href="#二、WebViewJavascriptBridge" class="headerlink" title="二、WebViewJavascriptBridge"></a>二、WebViewJavascriptBridge</h3><p><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>是一个用于OC与JS交互第三方库，在GitHub上有8000多的star，它的原理也是通过shouldStartLoadWithRequest 这个代理方法，对url进行判断来实现的。接下来我们看看这个库怎么用。</p>
<p>初始化UIWebView的时候，不要为UIWebView设置代理为self，这个库的内部会自动为其设置代理，假如我们还是想在本类调用UIWebView的代理方法，WebViewJavascriptBridge有专门的API来调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//这里不要为UIWebView设置代理 UIWebView的代理被赋值给WebViewJavascriptBridge。</div><div class="line">UIWebView *webView = [[UIWebView alloc] initWithFrame:self.view.bounds];</div><div class="line">[webView loadHTMLString:appHtml baseURL:url];</div><div class="line">[self.view addSubview:webView];</div><div class="line">self.webView = webView;</div><div class="line"></div><div class="line">WebViewJavascriptBridge *webViewBridge = [WebViewJavascriptBridge bridgeForWebView:webView];</div><div class="line">//将UIWebView的代理，从webViewBridge中再传递出来。意思是假如你要在控制器中实现UIWebView的代理方法时，添加下面这样代码</div><div class="line">[webViewBridge setWebViewDelegate:self];</div><div class="line">self.webViewBridge = webViewBridge;</div></pre></td></tr></table></figure>
<p>任何有关方法的调用，必须经过下面的js注册，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*这段代码是固定的，必须要放到js中*/</div><div class="line">function setupWebViewJavascriptBridge(callback) &#123;</div><div class="line">  if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</div><div class="line">  if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</div><div class="line">  window.WVJBCallbacks = [callback];</div><div class="line">  var WVJBIframe = document.createElement(&apos;iframe&apos;);</div><div class="line">  WVJBIframe.style.display = &apos;none&apos;;</div><div class="line">  WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</div><div class="line">  document.documentElement.appendChild(WVJBIframe);</div><div class="line">  setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比较蛋疼，也是特别要注意的地方。</p>
<h4 id="OC调用JS-1"><a href="#OC调用JS-1" class="headerlink" title="OC调用JS"></a>OC调用JS</h4><p>OC调用JS的方法比较简单，调用分几种：</p>
<p>1.直接调用，无参数无回调</p>
<p>2.有参数，有回调</p>
<p>3.有多个参数，有回调</p>
<p>Demo中都给出了这几种的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 不传参数，直接调用，无回调</div><div class="line">[self.webViewBridge callHandler:@&quot;myOperation&quot;];</div><div class="line"></div><div class="line">// 传参数 有回调</div><div class="line">[self.webViewBridge callHandler:@&quot;factorial&quot; data:@(4) responseCallback:^(id responseData) &#123;</div><div class="line">    NSLog(@&quot;OC端得到responseData: %@&quot;,responseData);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 传参数 有回调</div><div class="line">NSArray *array = @[@(1),@(2)];</div><div class="line">[self.webViewBridge callHandler:@&quot;calculate&quot; data:array responseCallback:^(id responseData) &#123;</div><div class="line">    NSLog(@&quot;OC端得到responseData: %@&quot;,responseData);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>因为这三个方法，在html文件中，js自己调用 setupWebViewJavascriptBridge 这个方法了，所有不需要在OC代码中进行register，注意这里的方法名，一定要和js中的方法名相同。</p>
<h4 id="JS调用OC-1"><a href="#JS调用OC-1" class="headerlink" title="JS调用OC"></a>JS调用OC</h4><p>使用 WebViewJavascriptBridge 这个类的 <code>registerHandler</code> 方法进行注册，在block里我们可以使用JS传给OC的参数，及再回调给JS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[self.webViewBridge registerHandler:@&quot;changeColor&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">    </div><div class="line">    //data就是JS传给OC的参数</div><div class="line">    NSDictionary *tempDic = data;</div><div class="line">    CGFloat r = [[tempDic objectForKey:@&quot;r&quot;] floatValue];</div><div class="line">    CGFloat g = [[tempDic objectForKey:@&quot;g&quot;] floatValue];</div><div class="line">    CGFloat b = [[tempDic objectForKey:@&quot;b&quot;] floatValue];</div><div class="line">    CGFloat a = [[tempDic objectForKey:@&quot;a&quot;] floatValue];</div><div class="line">    </div><div class="line">    self.webView.scrollView.backgroundColor = [UIColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:a];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line">[self.webViewBridge registerHandler:@&quot;JS调用OC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">    </div><div class="line">    //data就是JS传给OC的参数</div><div class="line">    NSLog(@&quot;data from JS ：%@&quot;, data);</div><div class="line">    </div><div class="line">    if (responseCallback) &#123;</div><div class="line">        </div><div class="line">        //OC反馈给JS</div><div class="line">        responseCallback(@&quot;我是OC传给JS的数据&quot;);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="二、JavaScriptCore"><a href="#二、JavaScriptCore" class="headerlink" title="二、JavaScriptCore"></a>二、JavaScriptCore</h3><p>JavaScriptCore框架是iOS 7中加入的，该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。在项目中引入JavaScriptCore后，链到头文件中，除了大段的Copyright注释可以看到里面只要引入了5个文件，每个文件里都定义跟文件名对应的类。总的来说，JavaScriptCore的使用相对简单，也很方便</p>
<p>JSContext是JavaScript的运行环境，通过jSCore执行的JS代码都得通过JSContext来执行，相当于HTML中&lt; JavaScript &gt;之间的内容。</p>
<p>JSValue是JSContext的返回结果，他对数据类型进行了封装，并且为JS和OC的数据类型之间的转换提供了方法。</p>
<p>JSManagedValue是JSValue的封装，用它可以解决JS和原生代码之间循环引用的问题。</p>
<p>JSVirtualMachine 管理JS运行时和管理JS暴露的OC对象的内存,是JSContext的容器，可以包含若干个JSContext，在一个进程中，你可以有多个JSVirtualMachine，里面包含着若干个JSContext，而JSContext中又有若干个JSValue</p>
<p>JSExport是一个协议，通过实现它可以把一个OC对象暴漏给JS，这样JS就可以调用这个对象暴露的方法。</p>
<p>JavaScriptCore对于JS与OC的交互有两种方式，一种是使用JSExport，另一种是使用block形式。下面只介绍了使用block来进行交互</p>
<h4 id="JS调用OC-2"><a href="#JS调用OC-2" class="headerlink" title="JS调用OC"></a>JS调用OC</h4><p>先在 <code>viewDidLoad</code> 方法里创建 JSContext 对象，注入JS方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 初始化 JSContext 对象</div><div class="line">self.OCCallJScontext = [[JSContext alloc] init];</div><div class="line"></div><div class="line">NSString *jsPath = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;js&quot;];</div><div class="line">NSString *jsScript = [NSString stringWithContentsOfFile:jsPath encoding:NSUTF8StringEncoding error:nil];</div><div class="line"> [self.OCCallJScontext evaluateScript:jsScript];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (IBAction)click:(id)sender</div><div class="line">&#123;</div><div class="line">    JSValue *function = [self.OCCallJScontext objectForKeyedSubscript:@&quot;calculate&quot;];</div><div class="line">    </div><div class="line">    // 3 + 4</div><div class="line">    JSValue *result = [function callWithArguments:@[@(3),@(4)]];</div><div class="line">    </div><div class="line">    NSLog(@&quot;通过js方法计算两数之和为 %@&quot;,[result toString]);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>calculate</code> 方法是和H5同事约定好的，调用方法的字符串。</p>
<h4 id="OC调用JS-2"><a href="#OC调用JS-2" class="headerlink" title="OC调用JS"></a>OC调用JS</h4><p>首先在<code>webViewDidFinishLoad</code> 方法里获取到 JSContext 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.JSCallOCcontext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</div></pre></td></tr></table></figure>
<p>假如我们在js中，对button绑定了一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button onclick=&quot;methodA()&quot;&gt;不传参数&lt;/button&gt;</div></pre></td></tr></table></figure>
<p>当我们点击网页中的这个button的时候，让它调用原生的方法，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">self.JSCallOCcontext[@&quot;methodA&quot;] =</div><div class="line">^()</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;直接调用不传参数&quot;);</div><div class="line">    // 可以写自己的方法</div><div class="line">    // [self customMethod];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法是不传参数给OC的，假如JS要传参数给OC，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button onclick=&quot;methodB(&apos;我是参数&apos;)&quot;&gt;传参数&lt;/button&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">self.JSCallOCcontext[@&quot;methodB&quot;] =</div><div class="line">^(NSString *str)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;得到JS的参数为 %@&quot;,str);</div><div class="line">    // 可以写自己的方法</div><div class="line">    // [self customMethod];</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在block里写对应的原生方法，假如要把结果回调给JS，可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button onclick=&quot;methodD(&apos;我是参数&apos;)&quot;&gt;有返回&lt;/button&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    // 并将值返回给js</div><div class="line">__weak ViewController *weakSelf = self;</div><div class="line">self.JSCallOCcontext[@&quot;methodD&quot;] =</div><div class="line">^(NSString *str)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;得到JS的参数为 %@&quot;,str);</div><div class="line">    str = [NSString stringWithFormat:@&quot;呵呵哒%@&quot;,str];</div><div class="line">    JSValue *callback = weakSelf.JSCallOCcontext[@&quot;callback&quot;];</div><div class="line">    [callback callWithArguments:@[str]];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里要注意循环引用问题。</p>
<p>三种交互方法对比：</p>
<p>如果仅仅是简单的交互，直接在UIWebVIew的代理方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:</div><div class="line">(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</div></pre></td></tr></table></figure>
<p>实现功能即可。如果交互比较复杂，建议使用JavaScriptCore，WebViewJavascriptBridge这个库用起来比较麻烦，我当时也是看了一段时间才看明白，JavaScriptCore用起来还是很方便的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/29/自定义转场动画/" itemprop="url">
                  自定义转场动画
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-29T21:02:39+08:00" content="2017-04-29">
              2017-04-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/29/自定义转场动画/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/29/自定义转场动画/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/04/29/自定义转场动画/" class="leancloud_visitors" data-flag-title="自定义转场动画">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近详细学习了关于转场动画的知识，通过一些API可以帮助我们实现炫酷的转场动画，先直接上Demo:<a href="https://github.com/coderZhou10496/TransitionDemo" target="_blank" rel="external">Github地址</a>，下面的转场动画都是自定义的动画</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB.gif" alt="image"></p>
<p>先来了解一下转场动画所需要的几个protocol</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/TransitionPic.png" alt="image"></p>
<p>我们一一简单了解下这些类是干嘛用的：</p>
<blockquote>
<p><code>UINavigationControllerDelegate</code></p>
</blockquote>
<p>这个delegate主要有一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                   animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                                fromViewController:(UIViewController *)fromVC</div><div class="line">                                                  toViewController:(UIViewController *)toVC</div></pre></td></tr></table></figure></p>
<p>自定义 push pop 动画时要实现这个方法，这个方法需要我们提供一个实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象。</p>
<blockquote>
<p><code>UIViewControllerTransitioningDelegate</code></p>
</blockquote>
<p>这个delegate 用于实现自定义的 present diss 动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:</div><div class="line">(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</div></pre></td></tr></table></figure>
<p>这个方法也需要我们提供一个实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象。</p>
<blockquote>
<p><code>UIViewControllerInteractiveTransitioning</code></p>
</blockquote>
<p>这个protocol是跟手势交互相关的。比如需要通过手势来返回到上一界面，就要返回实现了这个protocol的对象</p>
<blockquote>
<p><code>UIViewControllerAnimatedTransitioning</code> </p>
</blockquote>
<p> 这个protocol就是用于实现动画效果的protocol了，其中有两个必须实现的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</div><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</div></pre></td></tr></table></figure>
<p>第一个方法返回动画所需要的时间，第二个方法就是动画的具体实现</p>
<blockquote>
<p><code>UIViewControllerContextTransitioning</code></p>
</blockquote>
<p>这个protocol提供我们动画的具体实现所需要的元素，比如这些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)viewControllerForKey:(UITransitionContextViewControllerKey)</div><div class="line">- ( UIView *)viewForKey:(UITransitionContextViewKey)</div><div class="line">- (UIView *)containerView</div></pre></td></tr></table></figure>
<p>通过 UITransitionContextViewControllerKey 获得 动画所需要的 fromVc toVc，通过UITransitionContextViewKey 获得 动画所需要的 fromView toView 等等。</p>
<p>接下来就是实战了，主要是对一系列过程的封装。我采用了类别的方式，对 UINavigationController 增加了一个属性，即 push 的动画方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger,ZJNavigationTransitioningStyle)&#123;</div><div class="line">    ZJNavigationTransitioningStyleSystem,</div><div class="line">    ZJNavigationTransitioningStyleRound,</div><div class="line">    ZJNavigationTransitioningStyleScale,</div><div class="line">    ZJNavigationTransitioningStyleLeftSunken,</div><div class="line">    ZJNavigationTransitioningStyleRotate</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface UINavigationController (ZJTransitioning)</div><div class="line">@property (nonatomic,assign) ZJNavigationTransitioningStyle transitioningStyle;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当我们 push 的时候 ，只需为这个属性赋值就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ResultViewController *controller = [[ResultViewController alloc] init];</div><div class="line">self.navigationController.transitioningStyle = ZJNavigationTransitioningStyleSystem;</div><div class="line">[self.navigationController pushViewController:controller animated:YES];</div></pre></td></tr></table></figure>
<p>下面我们对其中一种动画方式 ZJNavigationTransitioningStyleScale ，详细描述实现过程 </p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/scale.gif" alt="image"></p>
<p>在 UINavigationController (ZJTransitioning) 这个类别的 .m 实现文件中，我们将 UINavigationController 的 delegate 方法用 ZJNavigationDelegateMediator 这个类来接收，意思就是 <code>@protocol UINavigationControllerDelegate &lt;NSObject&gt;</code>里的方法，在 ZJNavigationDelegateMediator 类里面来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">-(void)viewDidLoad</div><div class="line">&#123;</div><div class="line">//    将delegate 设置为 ZJNavigationDelegateMediator 对象，在 ZJNavigationDelegateMediator 类里实现</div><div class="line">//    UINavigationControllerDelegate的方法</div><div class="line">    self.delegate = self.mediator;</div><div class="line">&#125;</div><div class="line">-(ZJNavigationTransitioningStyle)transitioningStyle</div><div class="line">&#123;</div><div class="line">    return self.mediator.transitioningStyle;</div><div class="line">&#125;</div><div class="line">-(void)setTransitioningStyle:(ZJNavigationTransitioningStyle)transitioningStyle</div><div class="line">&#123;</div><div class="line">    self.mediator.transitioningStyle = transitioningStyle;</div><div class="line">&#125;</div><div class="line">-(ZJNavigationDelegateMediator *)mediator</div><div class="line">&#123;</div><div class="line">    ZJNavigationDelegateMediator *mediator = objc_getAssociatedObject(self, &amp;ZJTransitioningMediator_key);</div><div class="line">    if(mediator == nil)</div><div class="line">    &#123;</div><div class="line">        mediator = [[ZJNavigationDelegateMediator alloc] init];</div><div class="line">        self.mediator = mediator;</div><div class="line">    &#125;</div><div class="line">    return mediator;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)setMediator:(ZJNavigationDelegateMediator *)mediator</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(self, &amp;ZJTransitioningMediator_key, mediator, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ZJNavigationDelegateMediator 类里也定义了一个 ZJNavigationTransitioningStyle 的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface ZJNavigationDelegateMediator : NSObject&lt;UINavigationControllerDelegate&gt;</div><div class="line">@property (nonatomic,assign) ZJNavigationTransitioningStyle transitioningStyle;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>设置完<code>self.navigationController.transitioningStyle</code>后，所有的操作都转交给 ZJNavigationDelegateMediator，返回的动画方式的对象，以及动画对象的管理，也是在这个类里实现。</p>
<p>下面是实现 UINavigationControllerDelegate 的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                  animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                               fromViewController:(UIViewController *)fromVC</div><div class="line">                                                 toViewController:(UIViewController *)toVC</div><div class="line">&#123;</div><div class="line">    self.operation = operation;</div><div class="line">    if(self.transitioningStyle == ZJNavigationTransitioningStyleRound)</div><div class="line">    &#123;</div><div class="line">        return self.roundTransitioning;</div><div class="line">    &#125;</div><div class="line">    else if (self.transitioningStyle == ZJNavigationTransitioningStyleScale)</div><div class="line">    &#123;</div><div class="line">        return self.scaleTransitioning;</div><div class="line">    &#125;</div><div class="line">    else if (self.transitioningStyle == ZJNavigationTransitioningStyleLeftSunken)</div><div class="line">    &#123;</div><div class="line">        return self.leftSunkenTransitioning;</div><div class="line">    &#125;</div><div class="line">    else if (self.transitioningStyle == ZJNavigationTransitioningStyleRotate)</div><div class="line">    &#123;</div><div class="line">        return self.rotateTransitioning;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>选择了哪种动画方式，就返回相应的 AnimatedTransitioning 对象，并将以何种方式进行页面切换 即是 push 还是 pop 也传到 AnimatedTransitioning 对象里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(ZJScaleAnimatedTransitioning *)scaleTransitioning</div><div class="line">&#123;</div><div class="line">    if(_scaleTransitioning == nil)</div><div class="line">    &#123;</div><div class="line">        _scaleTransitioning = [[ZJScaleAnimatedTransitioning alloc] init];</div><div class="line">    &#125;</div><div class="line">    _scaleTransitioning.operation = self.operation;</div><div class="line">    return _scaleTransitioning;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的动画对象，都继承自 ZJBaseAnimatedTransitioning，这个类 实现 <code>@protocol UIViewControllerAnimatedTransitioning &lt;NSObject&gt;</code>这个动画 protocol。</p>
<p>由于 动画方式 为 ZJNavigationTransitioningStyleScale 的时候，需要得到 push 前图片的位置信息，以及 push 后图片的位置信息 ，所以我声明了protocol，用来得到这些信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 此协议是为了得到push方式为 ZJNavigationTransitioningStyleRound 和 ZJNavigationTransitioningStyleScale 的图片的相关信息</div><div class="line"> */</div><div class="line">@protocol ZJTransitioningProtocol &lt;NSObject&gt;</div><div class="line">-(NSDictionary *)getTransitioningInfoWithTransitioning:(id &lt;UIViewControllerAnimatedTransitioning&gt;)transitioning;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在 <code>@protocol UIViewControllerAnimatedTransitioning &lt;NSObject&gt;</code> 实现方法里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</div></pre></td></tr></table></figure>
<p>我们去写实际动画相关的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</div><div class="line">UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</div><div class="line">UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey];</div><div class="line">UIView *containerView = [transitionContext containerView];</div></pre></td></tr></table></figure>
<p>在本例中，当为 push 操作时，fromVC 为 TableViewController，toVC 为 ImageViewController。而当为 pop 操作时，fromVC 为 ImageViewController，toVC 为 TableViewController，这一点千万要注意，是相反的。</p>
<p>先通过自己定义的 ZJTransitioningProtocol 得到图片的位置信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">UIImageView *fromImageView = nil;</div><div class="line">UIImageView *toImageView = nil;</div><div class="line">CGRect fromRect = CGRectZero ;</div><div class="line">CGRect ToRect = CGRectZero;</div><div class="line">if([fromVC respondsToSelector:@selector(getTransitioningInfoWithTransitioning:)])</div><div class="line">&#123;</div><div class="line">    NSDictionary *dic = [(id &lt;ZJTransitioningProtocol&gt;)fromVC getTransitioningInfoWithTransitioning:self];</div><div class="line">    fromImageView = dic[@&quot;imageView&quot;];</div><div class="line">    fromRect = CGRectFromString(dic[@&quot;frame&quot;]);</div><div class="line"> &#125;</div><div class="line">  if([toVC respondsToSelector:@selector(getTransitioningInfoWithTransitioning:)])</div><div class="line"> &#123;</div><div class="line">     NSDictionary *dic = [(id &lt;ZJTransitioningProtocol&gt;)toVC getTransitioningInfoWithTransitioning:self];</div><div class="line">     toImageView = dic[@&quot;imageView&quot;];</div><div class="line">     oRect = CGRectFromString(dic[@&quot;frame&quot;]);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 将 toView 加入到 containerView 的时候，当为 pop 操作时，注意为</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[containerView insertSubview:toView belowSubview:fromView];</div></pre></td></tr></table></figure>
<p> 上面都是准备操作，下面到了实际的动画操作</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIImageView *imageView = [self copyOfImageView:toImageView];</div><div class="line">imageView.frame = fromRect;</div><div class="line">[[UIApplication sharedApplication].keyWindow addSubview:imageView];</div><div class="line">fromImageView.hidden = YES;</div><div class="line">toImageView.hidden = YES;</div></pre></td></tr></table></figure>
<p>加一个过渡的imageView 加在 window 上 ，用imageView的坐标的变化实现动画效果，动画结束后移除此过渡imageView，并将先将原来的fromImageView toImageView隐藏.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0.0 options:UIViewAnimationOptionCurveEaseOut animations: ^&#123;</div><div class="line">   // 动画阴影效果</div><div class="line">    maskViewForFromView.alpha = maskViewAlpha;</div><div class="line">    maskViewForToView.alpha = 0.0;</div><div class="line">    </div><div class="line">    toView.frame = finalFrameForToVC;</div><div class="line">    if (self.operation == UINavigationControllerOperationPush)</div><div class="line">    &#123;</div><div class="line">        CGRect frame = fromView.frame;</div><div class="line">        frame.origin.x = frame.origin.x - frame.size.width / 3.0;</div><div class="line">        fromView.frame = frame;</div><div class="line">    &#125;</div><div class="line">    else if (self.operation == UINavigationControllerOperationPop)</div><div class="line">    &#123;</div><div class="line">        CGRect frame = fromView.frame;</div><div class="line">        frame.origin.x = frame.origin.x + frame.size.width;</div><div class="line">        fromView.frame = frame;</div><div class="line">    &#125;</div><div class="line">    imageView.frame = ToRect;</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">    [maskViewForFromView removeFromSuperview];</div><div class="line">    [maskViewForToView removeFromSuperview];</div><div class="line"></div><div class="line">    fromImageView.hidden = NO;</div><div class="line">    toImageView.hidden = NO;</div><div class="line">    [imageView removeFromSuperview];</div><div class="line">    [transitionContext completeTransition:!transitionContext.transitionWasCancelled];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>代码很好理解，在 fromView toView 上都加了过渡的阴影view，动画的过程中将 maskViewForFromView 的 alpha 增加，将 maskViewForToView 的 alpha 减小至0，动画结束后移除此阴影view。切换方式为 push pop时，分别设置 fromView.frame ，完成动画效果。最后，一定不要忘了设置这句代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[transitionContext completeTransition:!transitionContext.transitionWasCancelled];</div></pre></td></tr></table></figure>
<p>这是为了告诉系统，动画已经完成，这是系统为自动帮我们移除 fromView.</p>
<p>关于其他动画方式的具体实现，有兴趣的可以到Github上下载，都有注释，很好理解</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/zhoujian_headerImage.jpeg"
               alt="Zhou Jian" />
          <p class="site-author-name" itemprop="name">Zhou Jian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coderZhou10496" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"coderzhou"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Bw40KBIPanRkt0iqTr7NLT6I-gzGzoHsz", "MQjFPSYkEazqnUv2rS7TOsui");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
