<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="main函数是程序的启动入口，但是系统为程序的启动又做了哪些准备呢，二进制文件又是怎样加载进内存的呢？这两天花了点时间深入了了解了一下。
Mach-O格式简单介绍Mach则是苹果操作系统内核，在Mach上，一种可执行的文件格是就是Mach-O（Mach Object file format），这是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。Mach-O 文件一般都有">
<meta property="og:type" content="article">
<meta property="og:title" content="程序的启动链接过程">
<meta property="og:url" content="http://coderzhou.com/2018/03/16/程序的启动链接过程/index.html">
<meta property="og:site_name" content="Jianless的博客">
<meta property="og:description" content="main函数是程序的启动入口，但是系统为程序的启动又做了哪些准备呢，二进制文件又是怎样加载进内存的呢？这两天花了点时间深入了了解了一下。
Mach-O格式简单介绍Mach则是苹果操作系统内核，在Mach上，一种可执行的文件格是就是Mach-O（Mach Object file format），这是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。Mach-O 文件一般都有">
<meta property="og:image" content="http://ocauxqtbu.bkt.clouddn.com/link_mach-o.png">
<meta property="og:image" content="http://ocauxqtbu.bkt.clouddn.com/link_mach-o_header.png">
<meta property="og:image" content="http://ocauxqtbu.bkt.clouddn.com/link_objc_init.png">
<meta property="og:updated_time" content="2018-07-06T03:08:53.659Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序的启动链接过程">
<meta name="twitter:description" content="main函数是程序的启动入口，但是系统为程序的启动又做了哪些准备呢，二进制文件又是怎样加载进内存的呢？这两天花了点时间深入了了解了一下。
Mach-O格式简单介绍Mach则是苹果操作系统内核，在Mach上，一种可执行的文件格是就是Mach-O（Mach Object file format），这是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。Mach-O 文件一般都有">
<meta name="twitter:image" content="http://ocauxqtbu.bkt.clouddn.com/link_mach-o.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coderzhou.com/2018/03/16/程序的启动链接过程/"/>

  <title> 程序的启动链接过程 | Jianless的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Jianless的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">专注于iOS开发</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                程序的启动链接过程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-16T10:32:04+08:00" content="2018-03-16">
              2018-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/16/程序的启动链接过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/16/程序的启动链接过程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/16/程序的启动链接过程/" class="leancloud_visitors" data-flag-title="程序的启动链接过程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>main函数是程序的启动入口，但是系统为程序的启动又做了哪些准备呢，二进制文件又是怎样加载进内存的呢？这两天花了点时间深入了了解了一下。</p>
<h3 id="Mach-O格式简单介绍"><a href="#Mach-O格式简单介绍" class="headerlink" title="Mach-O格式简单介绍"></a>Mach-O格式简单介绍</h3><p>Mach则是苹果操作系统内核，在Mach上，一种可执行的文件格是就是Mach-O（Mach Object file format），这是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。Mach-O 文件一般都有一个 Header ，各种 Load Commands 以及多个 Segment：<br><img src="http://ocauxqtbu.bkt.clouddn.com/link_mach-o.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.Header：保存了Mach-O的一些基本信息，包括了平台、文件类型、LoadCommands的个数等等。</div><div class="line">2.LoadCommands：这一段紧跟Header，加载Mach-O文件时会使用这里的数据来确定内存的分布。</div><div class="line">3.Data：每一个segment的具体数据都保存在这里，这里包含了具体的代码、数据等等。</div></pre></td></tr></table></figure>
<p>####Header<br><img src="http://ocauxqtbu.bkt.clouddn.com/link_mach-o_header.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Magic Number:			该文件是64位平台文件还是32位平台文件。值为0xFEEDFACF表示64位，0xFEEDFACE表示32位；</div><div class="line">CPU Type,CPU subType:	确定CPU的平台与版本；</div><div class="line">File Type:				该文件的类型。MH_EXECUTE表示这是一个可执行文件；</div><div class="line">Number of 				Load Commands:Load Commands的个数；</div><div class="line">Size of Load Commands:	Load Commands的长度；</div><div class="line">Flags:					dylb加载时需要的标志位；</div><div class="line">Reserved:				只有64位的时候才存在的字段，暂时没用</div></pre></td></tr></table></figure>
<p>####Load Commands<br>Load Commands表示的是加载命令，不同的字段就是表示不同的命令，通过解析LoadCommand来加载接下来的数据。举几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LC_MAIN：整个程序的入口地址，保证进程启动后能够正常的开始整个应用程序的运行</div><div class="line">LC_UUID：唯一ID</div><div class="line">LC_LOAD_DYLINKER：获得动态加载器地址,调用dylb程序</div><div class="line">LC_CODE_SIGNATURE：进行数字签名.</div></pre></td></tr></table></figure>
<p>等等</p>
<p>####Segment &amp; Section<br>Data表示原始数据,可以拥有多个段（segment），每个段可以拥有零个或多个区域（section）。每一个段（segment）都拥有一段虚拟地址映射到进程的地址空间。<br>加载数据时，主要加载的就是<code>LC_SEGMENT</code>或者<code>LC_SEGMENT_64</code>。这里大部分的数据是用来帮助内核将Segment映射到虚拟内存。<code>LC_SEGMENT_64</code>的数据结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT_64 */</div><div class="line">	uint32_t	cmdsize;	/* load command的大小 */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint64_t	vmaddr;		/* 段的虚拟内存地址 */</div><div class="line">	uint64_t	vmsize;		/*  段的虚拟内存大小 */</div><div class="line">	uint64_t	fileoff;	/* 段在文件中偏移量 */</div><div class="line">	uint64_t	filesize;	/* 段在文件中的大小 */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* 标示了Segment中有多少secetion */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Section的数据结构为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct section &#123; /* for 32-bit architectures */</div><div class="line">    char        sectname[16];   /* name of this section */</div><div class="line">    char        segname[16];    /* segment this section goes in */</div><div class="line">    uint32_t    addr;       /* memory address of this section */</div><div class="line">    uint32_t    size;       /* size in bytes of this section */</div><div class="line">    uint32_t    offset;     /* file offset of this section */</div><div class="line">    uint32_t    align;      /* 字节大小对齐 */</div><div class="line">    uint32_t    reloff;     /* file offset of relocation entries */</div><div class="line">    uint32_t    nreloc;     /* number of relocation entries */</div><div class="line">    uint32_t    flags;      /* flags (section type and attributes)*/</div><div class="line">    uint32_t    reserved1;  /* reserved (for offset or index) */</div><div class="line">    uint32_t    reserved2;  /* reserved (for count or sizeof) */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>__PAGEZERO</code>是第一个段，它的大小在 32 位系统是 4KB+，而在 64 位系统是 4GB+。位于虚拟内存从 0x000000 到 App 真实起始位置之间，都是被标记为不可读写和不可执行。因为里面并没有数据，所以 file size 为 0。主要的作用是为了捕获 NULL 指针使用和指针截断错误，防止引起系统崩溃。开发中常见的 EXC_BAD_ACCESS 异常都是因为错误访问到这里了。</p>
</li>
<li><p><code>__TEXT</code> 段包含了 Mach 头部，被执行的代码和只读常量，它被只读和可执行的方式映射。以下是几个常见的 section：</p>
</li>
<li><p><code>__text</code> 里就是程序编译后的机器码。</p>
</li>
<li><code>__stubs</code> 和 <code>__stub_helper</code> 是给动态链接器（dyld）使用的。</li>
<li><code>__const</code> 包含常量变量，所有不需要重定向的常量数据都会被编译器放在这里。</li>
<li><code>__cstring</code> 包含硬编码的字符串常量。</li>
<li><code>__DATA</code> 段包含了可读写的内容，全局变量和静态变量等，以可读写和不可执行的方式映射。常见的 section 有：<br><code>__nl_symbol_ptr</code> 和 <code>__la_symbol_ptr</code> 分别是 non-lazy 和 lazy 符号指针。lazy 符号指针用于可执行文件中调用未定义的函数，例如不包含在可执行文件中的函数，它们将会延迟加载。而针对 non-lazy 符号指针，当可执行文件被加载同时，也会被加载。</li>
<li><code>__const</code> 包含需要重定向的常量数据。</li>
<li><code>__bss</code> 包含没有被初始化的静态变量。</li>
<li><code>__LINKEDIT</code> 段它的作用是包含如何加载整个文件的「元数据」。例如符号表，字符串表和重定位表。代码签名后每页的加密散列值也会存储到这里。</li>
</ul>
<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>一个程序的编译过程简单分为预编译、编译、汇编、链接等过程。链接就是讲多个目标文件合并成一个可执行文件，静态库和动态库的区别就是在链接阶段如何处理库。在链接阶段，将汇编生成的目标文件与引用到的库一个链接打包到可执行文件中，因为对应的链接方式成为静态链接。而动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。使用动态库的好处有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.代码共用：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份</div><div class="line">2.易于维护：由于被依赖的 lib 是程序执行时才 link 的，所以这些 lib 很容易做更新</div><div class="line">3.减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多</div></pre></td></tr></table></figure>
<p>但是同样的，加载动态库，就需要动态连接器dylb。动态链接加载器在系统中以一个用户态的可执行文件形式存在，一般应用程序会在Mach-O文件部分指定一个LC_LOAD_DYLINKER的加载命令，此加载命令指定了dyld的路径，通常它的默认值是“/usr/lib/dyld”。系统内核在加载Mach-O文件时，会使用该路径指定的程序作为动态库的加载器来加载dylib。不过dylb是<a href="https://github.com/opensource-apple/dyld" target="_blank" rel="external">开源</a>的。</p>
<p>###mach-o文件加载</p>
<p>####dyld自身如何加载</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/link_objc_init.png" alt="image"><br>我们在程序中设个断点，断在<code>_objc_init</code>，我们看到了栈底的<code>_dylb_start</code>方法，那么问题来了,既然各种二进制都是走dyld加载的，那么dyld自身是如何加载进来的呢？<br>系统在解析Mach-O文件时，<code>_dylb_start</code> 的方法地址的是在 <code>LC_UNIXTHREAD</code> 段中解析出来的，然后通过 <code>LC_LOAD_DYLINKER</code> 这个字段来启动这个二进制加载器。从下面dylb的这段源码可以看到，启动前还要做一些准备引导工作，到最后才是调用<code>dyld::_main</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</div><div class="line">//  In dyld we have to do this manually.</div><div class="line">//</div><div class="line">uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], </div><div class="line">				intptr_t slide, const struct macho_header* dyldsMachHeader,</div><div class="line">				uintptr_t* startGlue)</div><div class="line">&#123;</div><div class="line">	// if kernel had to slide dyld, we need to fix up load sensitive locations</div><div class="line">	// we have to do this before using any global variables</div><div class="line">	if ( slide != 0 ) &#123;</div><div class="line">		rebaseDyld(dyldsMachHeader, slide);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// allow dyld to use mach messaging</div><div class="line">	mach_init();</div><div class="line"></div><div class="line">	// kernel sets up env pointer to be just past end of agv array</div><div class="line">	const char** envp = &amp;argv[argc+1];</div><div class="line">	</div><div class="line">	// kernel sets up apple pointer to be just past end of envp array</div><div class="line">	const char** apple = envp;</div><div class="line">	while(*apple != NULL) &#123; ++apple; &#125;</div><div class="line">	++apple;</div><div class="line"></div><div class="line">	// set up random value for stack canary</div><div class="line">	__guard_setup(apple);</div><div class="line"></div><div class="line">#if DYLD_INITIALIZER_SUPPORT</div><div class="line">	// run all C++ initializers inside dyld</div><div class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</div><div class="line">#endif</div><div class="line"></div><div class="line">	// now that we are done bootstrapping dyld, call dyld&apos;s main</div><div class="line">	uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader);</div><div class="line">	return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><p>有兴趣的同学可以下载源码看下，<code>dyld::_main</code>main方法做的主要事情有</p>
<ul>
<li>设置运行环境，环境变量</li>
<li>实例化Image</li>
<li>加载共享缓存</li>
<li>动态库的版本化重载</li>
<li>加载插入的动态库</li>
<li>link主程序</li>
<li>link插入的动态库</li>
<li>weakBind弱符号绑定</li>
<li>initialize</li>
<li>查找入口点并返回</li>
</ul>
<p>在所有的动态库做好符号重定位和初始化工作之后，也就是 dyld::_main 临近末尾的时候，dyld 会获取 main 函数的地址返回给 dyld，dyld 紧接着调用 main 函数，将控制权交换给主程序，程序开始真正的执行。<br>下面是<code>dyld::_main</code>方法的部分源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</div><div class="line">// sets up some registers and call this function.</div><div class="line">//</div><div class="line">// Returns address of main() in target program which __dyld_start jumps to</div><div class="line">//</div><div class="line">uintptr_t</div><div class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </div><div class="line">		int argc, const char* argv[], const char* envp[], const char* apple[], </div><div class="line">		uintptr_t* startGlue) &#123;</div><div class="line">		...</div><div class="line">		//实例化Image</div><div class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</div><div class="line">		&#125;</div><div class="line">		...</div><div class="line">		//		加载共享缓存</div><div class="line">		checkSharedRegionDisable();</div><div class="line">		...</div><div class="line">			#if DYLD_SHARED_CACHE_SUPPORT</div><div class="line">//		动态库的版本化重载</div><div class="line">		if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion )</div><div class="line">			mapSharedCache();</div><div class="line">	#endif</div><div class="line"></div><div class="line">		// Now that shared cache is loaded, setup an versioned dylib overrides</div><div class="line">	#if SUPPORT_VERSIONED_PATHS</div><div class="line">		checkVersionedPaths();</div><div class="line">	#endif</div><div class="line">//加载插入的动态库</div><div class="line">		// load any inserted libraries</div><div class="line">		if	( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;</div><div class="line">			for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) </div><div class="line">				loadInsertedDylib(*lib);</div><div class="line">		&#125;</div><div class="line">		// record count of inserted libraries so that a flat search will look at </div><div class="line">		// inserted libraries, then main, then others.</div><div class="line">		sInsertedDylibCount = sAllImages.size()-1;</div><div class="line"></div><div class="line">//		link主程序</div><div class="line">		// link main executable</div><div class="line">		gLinkContext.linkingMainExecutable = true;</div><div class="line">		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL));</div><div class="line">		sMainExecutable-&gt;setNeverUnloadRecursive();</div><div class="line">		if ( sMainExecutable-&gt;forceFlat() ) &#123;</div><div class="line">			gLinkContext.bindFlat = true;</div><div class="line">			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>我们来看一下实例化image的过程,Runtime的初始化过程就是在这里进行的。这个image不是图片的意思，它大概表示一个二进制文件，<code>instantiateFromLoadedImage</code>这个方法就是实例化的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// The kernel maps in main executable before dyld gets control.  We need to </div><div class="line">// make an ImageLoader* for the already mapped in main executable.</div><div class="line">static ImageLoader* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)</div><div class="line">&#123;</div><div class="line">	// try mach-o loader</div><div class="line">	if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123; //检测macho文件是否符合条件,意思是该手机能否处理此mach-o文件</div><div class="line">//		初始化实例：方法内部通过判断mach-o文件是否是压缩过的，然后选择相应的类进行实例化</div><div class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</div><div class="line">//		添加image到管理的模块中</div><div class="line">		addImage(image);</div><div class="line">		return image;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	throw &quot;main executable not a known format&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>isCompatibleMachO</code>方法部分源码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// This is used to validate if a non-fat (aka thin or raw) mach-o file can be used</div><div class="line">// on the current processor. //</div><div class="line">bool isCompatibleMachO(const uint8_t* firstPage, const char* path)</div><div class="line">&#123;</div><div class="line">#if CPU_SUBTYPES_SUPPORTED</div><div class="line">	// It is deemed compatible if any of the following are true:</div><div class="line">	//  1) mach_header subtype is in list of compatible subtypes for running processor</div><div class="line">	//  2) mach_header subtype is same as running processor subtype</div><div class="line">	//  3) mach_header subtype runs on all processor variants</div><div class="line">	const mach_header* mh = (mach_header*)firstPage;</div><div class="line">	...</div><div class="line">	...</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>从注释中，可以看出，要满足以下三个条件，手机才能处理此mach-o文件</p>
<ul>
<li>mach_header中的subtype支持当前CPU版本。</li>
<li>mach_header中的subtype和当前正在运行的CPU版本相同。</li>
<li>mach_header中的subtype在该CPU的所有版本都可以处理。</li>
</ul>
<p><code>instantiateMainExecutable</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// create image for main executable</div><div class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	//dyld::log(&quot;ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n&quot;,</div><div class="line">	//	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</div><div class="line">	bool compressed;</div><div class="line">	unsigned int segCount;</div><div class="line">	unsigned int libCount;</div><div class="line">	const linkedit_data_command* codeSigCmd;</div><div class="line">	const encryption_info_command* encryptCmd;</div><div class="line">//	判断mach-o文件是否是压缩过</div><div class="line">	sniffLoadCommands(mh, path, false, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</div><div class="line">	// instantiate concrete class based on content of load commands</div><div class="line">//	通过是否压缩，用不同的方法来处理</div><div class="line">	if ( compressed )</div><div class="line">		return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">	else</div><div class="line">#if SUPPORT_CLASSIC_MACHO</div><div class="line">		return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">#else</div><div class="line">		throw &quot;missing LC_DYLD_INFO load command&quot;;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先判断mach-o文件是否压缩过，然后再用不用的方式处理此文件。两个方法的处理方式大同小异，<code>ImageLoaderMachOClassic::instantiateMainExecutable</code>方法里又调用了<code>ImageLoaderMachOClassic::instantiateStart</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// construct ImageLoaderMachOClassic using &quot;placement new&quot; with SegmentMachO objects array at end</div><div class="line">ImageLoaderMachOClassic* ImageLoaderMachOClassic::instantiateStart(const macho_header* mh, const char* path,</div><div class="line">																		unsigned int segCount, unsigned int libCount)</div><div class="line">&#123;</div><div class="line">	size_t size = sizeof(ImageLoaderMachOClassic) + segCount * sizeof(uint32_t) + libCount * sizeof(ImageLoader*);</div><div class="line">	ImageLoaderMachOClassic* allocatedSpace = static_cast&lt;ImageLoaderMachOClassic*&gt;(malloc(size));</div><div class="line">	if ( allocatedSpace == NULL )</div><div class="line">		throw &quot;malloc failed&quot;;</div><div class="line">	uint32_t* segOffsets = ((uint32_t*)(((uint8_t*)allocatedSpace) + sizeof(ImageLoaderMachOClassic)));</div><div class="line">	bzero(&amp;segOffsets[segCount], libCount*sizeof(void*));	// zero out lib array</div><div class="line">	return new (allocatedSpace) ImageLoaderMachOClassic(mh, path, segCount, segOffsets, libCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法内主要是申请内存，然后调用<code>ImageLoaderMachOClassic</code>方法，根据mach-o文件segments的规则将数据加载到内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ImageLoaderMachO::ImageLoaderMachO(const macho_header* mh, const char* path, unsigned int segCount, </div><div class="line">																uint32_t segOffsets[], unsigned int libCount)</div><div class="line"> : ImageLoader(path, libCount), fCoveredCodeLength(0), fMachOData((uint8_t*)mh), fLinkEditBase(NULL), fSlide(0),</div><div class="line">......</div><div class="line">&#123;</div><div class="line">	fIsSplitSeg = ((mh-&gt;flags &amp; MH_SPLIT_SEGS) != 0);        </div><div class="line"></div><div class="line">	// construct SegmentMachO object for each LC_SEGMENT cmd using &quot;placement new&quot; to put </div><div class="line">	// each SegmentMachO object in array at end of ImageLoaderMachO object</div><div class="line">	const uint32_t cmd_count = mh-&gt;ncmds;</div><div class="line">	const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)];</div><div class="line">	const struct load_command* cmd = cmds;</div><div class="line">	for (uint32_t i = 0, segIndex=0; i &lt; cmd_count; ++i) &#123;</div><div class="line">		if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</div><div class="line">			const struct macho_segment_command* segCmd = (struct macho_segment_command*)cmd;</div><div class="line">			// ignore zero-sized segments</div><div class="line">			if ( segCmd-&gt;vmsize != 0 ) &#123;</div><div class="line">				// record offset of load command</div><div class="line">				segOffsets[segIndex++] = (uint32_t)((uint8_t*)segCmd - fMachOData);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，这个方法就执行完了。然后就是最开始的调用<code>addimage</code>方法。这里涉及的源代码非常多，我只是粘贴了一部分。</p>
<p>####Runtime是在哪个过程中初始化的？</p>
<p>从上面的那个<code>_objc_init</code>调用栈可以看出，<code>initializeMainExecutable</code>内会进行Runtime的初始化</p>
<ul>
<li>initializeMainExecutable()</li>
<li>ImageLoader::runInitializers()</li>
<li>…</li>
<li>doModInitFunctions()</li>
<li>libdispatch_init</li>
<li>_os_object_init</li>
</ul>
<p>最终的，在<code>_os_object_init</code>这个方法内调用了<code>_objc_init()</code>方法，Runtime 接手后调用，调用map_images 做解析和处理，把 Category 的实例方法、协议以及属性添加到类上，把 Category 的类方法和协议添加到类的 metaclass 上；接下来 <code>load_images</code> 中调用 <code>call_load_methods</code> 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 load 方法和其 Category 的 load 方法。</p>
<p>本文只是简单介绍了dylb加载mach-o文件的简单流程，具体方法内部如何加载并没有过多探究，比如符号绑定，延迟加载等每一个知识点都可以写一篇文章来阐述。如有错误，请指正</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/19/容器类型数据防Crash处理/" rel="next" title="容器类型数据防Crash处理">
                <i class="fa fa-chevron-left"></i> 容器类型数据防Crash处理
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/06/我的产品体会/" rel="prev" title="我的产品体会">
                我的产品体会 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/03/16/程序的启动链接过程/"
           data-title="程序的启动链接过程" data-url="http://coderzhou.com/2018/03/16/程序的启动链接过程/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/zhoujian_headerImage.jpeg"
               alt="Zhou Jian" />
          <p class="site-author-name" itemprop="name">Zhou Jian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coderZhou10496" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mach-O格式简单介绍"><span class="nav-number">1.</span> <span class="nav-text">Mach-O格式简单介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态链接库"><span class="nav-number">2.</span> <span class="nav-text">动态链接库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接过程"><span class="nav-number">3.</span> <span class="nav-text">链接过程</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"coderzhou"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Bw40KBIPanRkt0iqTr7NLT6I-gzGzoHsz", "MQjFPSYkEazqnUv2rS7TOsui");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
