<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Jianless的博客">
<meta property="og:url" content="http://coderzhou.com/index.html">
<meta property="og:site_name" content="Jianless的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jianless的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coderzhou.com/"/>

  <title> Jianless的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Jianless的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">专注于iOS开发</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/02/YYCache中的细节/" itemprop="url">
                  YYCache中的细节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-02T22:36:33+08:00" content="2018-08-02">
              2018-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/02/YYCache中的细节/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/02/YYCache中的细节/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/08/02/YYCache中的细节/" class="leancloud_visitors" data-flag-title="YYCache中的细节">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近花了点时间看了下<a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>的源码，觉得其中的一些代码细节非常好，遂记录之，虽然这些知识可能被别人写烂了，但自己总结下总归是好的。</p>
<h3 id="dispatch-semaphore与-pthread-mutex-lock的使用"><a href="#dispatch-semaphore与-pthread-mutex-lock的使用" class="headerlink" title="dispatch_semaphore与 pthread_mutex_lock的使用"></a><code>dispatch_semaphore</code>与 <code>pthread_mutex_lock</code>的使用</h3><p>作者在YYMemoryCache中使用了C语言中的<code>pthread_mutex_t</code>来加锁解锁保证线程安全，而在YYDiskCache中使用<code>dispatch_semaphore信号量</code>，<code>dispatch_semaphore</code>不算锁，但可以实现锁的功能。</p>
<p>YYMemoryCache中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (id)objectForKey:(id)key &#123;</div><div class="line">    if (!key) return nil;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key));</div><div class="line">    if (node) &#123;</div><div class="line">        node-&gt;_time = CACurrentMediaTime();</div><div class="line">        [_lru bringNodeToHead:node];</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    return node ? node-&gt;_value : nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>YYDiskCache中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123;</div><div class="line">    if (!key) return nil;</div><div class="line">    dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER);</div><div class="line">    YYKVStorageItem *item = [_kv getItemForKey:key];</div><div class="line">    dispatch_semaphore_signal(self-&gt;_lock);</div><div class="line">    if (!item.value) return nil;</div><div class="line">    </div><div class="line">    id object = nil;</div><div class="line">    if (_customUnarchiveBlock) &#123;</div><div class="line">        object = _customUnarchiveBlock(item.value);</div><div class="line">    &#125; else &#123;</div><div class="line">        @try &#123;</div><div class="line">            object = [NSKeyedUnarchiver unarchiveObjectWithData:item.value];</div><div class="line">        &#125;</div><div class="line">        @catch (NSException *exception) &#123;</div><div class="line">            // nothing to do...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (object &amp;&amp; item.extendedData) &#123;</div><div class="line">        [YYDiskCache setExtendedData:item.extendedData toObject:object];</div><div class="line">    &#125;</div><div class="line">    return object;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在YYMemoryCache中，作者原先是使用自旋锁OSSpinLock来实现线程安全的，原理就是do while 忙等，缺点是等待时间会消耗大量 CPU 资源，所以它不适用于较长时间的任务，固在YYDiskCache中用<code>dispatch_semaphore</code>，<code>dispatch_semaphore</code>优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>
<p>但是由于OSSpinLock有安全问题，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。具体见<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">不再安全的 OSSpinLock</a>。所以就换成了<code>pthread_mutex_lock</code>互斥锁。</p>
<h3 id="GCD中使用-weak"><a href="#GCD中使用-weak" class="headerlink" title="GCD中使用__weak"></a>GCD中使用__weak</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)_trimRecursively &#123;</div><div class="line">    __weak typeof(self) _self = self;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</div><div class="line">        __strong typeof(_self) self = _self;</div><div class="line">        if (!self) return;</div><div class="line">        [self _trimInBackground];</div><div class="line">        [self _trimRecursively];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是YYDiskCache中的一段代码，目的是循环调用<code>_trimInBackground</code>方法来检查磁盘中的存储是否大于限制，大于限制的话就删除数据直到符合限制。这里作者使用了<code>__weak</code>来防止Block持有self。刚开始看到这句代码，我也不理解为什么要使用<code>__weak</code>，按理来说GCD中Block执行完后会释放self，不会存在内存泄露，在<a href="https://github.com/ibireme/YYKit/issues/41" target="_blank" rel="external">issues</a>也有关于这个问题的讨论。看了issues中的讨论，后来想了想，因为这是个递归调用，自己调用自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (!self) return;</div></pre></td></tr></table></figure>
<p>假如block中的self一直有值，那么这个循环会一直调用下去。那什么情况下block中self为nil呢。请看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">YYCache *cache = [[YYCache alloc] initWithPath:path];</div><div class="line">[cache setObject:@&quot;ZhangSan&quot; forKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>假如我们在ViewController中使用YYCache进行存储数据，但ViewController并没有持有YYCache实例，那么这两行代码执行完，cache这个对象就释放了，这是完美的结果。</p>
<p>但是假如在上述的源码里，没有使用<code>__weak</code>，而是直接使用了self，即使ViewController没有持有YYCache实例，cache这个对象也不会释放，YYDiskCache中的dealloc方法一直不会调用。因为Block一直在持有cache对象，并且这个方法是递归方法，所以就发生了“假的内存泄露”。</p>
<p>既然我们在ViewController中没有强引用cache，就希望使用它后自己释放掉，所以使用了<code>__weak</code>。假如在ViewController中强引用cache对象，那么使不使用<code>__weak</code>都是无关紧要的了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) YYCache *cache;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>另外提一点，因为YYCache中可以自己控制内存占用大小，磁盘占用大小，即超过限制自动删除尾部数据。假如我们不需要这个功能的时候，即对缓存大小无限制，可以注释掉相关检查操作的代码，因为它每隔一段时间(YYDiskCache默认为60s，YYMemoryCache默认为5s)会调用方法自动检查并操作数据，算是一个小优化吧。</p>
<h3 id="UIAppliaction对象"><a href="#UIAppliaction对象" class="headerlink" title="UIAppliaction对象"></a>UIAppliaction对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static UIApplication *_YYSharedApplication() &#123;</div><div class="line">    static BOOL isAppExtension = NO;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class cls = NSClassFromString(@&quot;UIApplication&quot;);</div><div class="line">        if(!cls || ![cls respondsToSelector:@selector(sharedApplication)]) isAppExtension = YES;</div><div class="line">        if ([[[NSBundle mainBundle] bundlePath] hasSuffix:@&quot;.appex&quot;]) isAppExtension = YES;</div><div class="line">    &#125;);</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</div><div class="line">    return isAppExtension ? nil : [UIApplication performSelector:@selector(sharedApplication)];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码是获得当前UIAppliaction对象，里面判断了当在App Extension里返回nil。假如是我们自己设计一个SDK给别人使用，会不会注意到这些细节呢？</p>
<h3 id="指定queue中子线程中释放对象"><a href="#指定queue中子线程中释放对象" class="headerlink" title="指定queue中子线程中释放对象"></a>指定queue中子线程中释放对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *holder = [NSMutableArray new];</div><div class="line">while (!finish) &#123;</div><div class="line">    if (pthread_mutex_trylock(&amp;_lock) == 0) &#123;</div><div class="line">        if (_lru-&gt;_tail &amp;&amp; (now - _lru-&gt;_tail-&gt;_time) &gt; ageLimit) &#123;</div><div class="line">            _YYLinkedMapNode *node = [_lru removeTailNode];</div><div class="line">            if (node) [holder addObject:node];</div><div class="line">        &#125; else &#123;</div><div class="line">            finish = YES;</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_unlock(&amp;_lock);</div><div class="line">    &#125; else &#123;</div><div class="line">        usleep(10 * 1000); //10 ms</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">if (holder.count) &#123;</div><div class="line">    dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        [holder count]; // release in queue</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在当前线程中创建一个NSMutableArray，然后将要删除释放的对象添加到数组中，再在子线程中调用count方法，这样就达到了在子线程中释放对象的目的了。</p>
<p>原因：当把将要删除的对象添加到array中，此时array不会释放，array中的对象也不会释放，因为在另外的线程中又调用了count方法，持有了array。当block执行完，就会释放持有的array，也达到了释放删除对象的目的，即在指定的queue中子线程释放对象。(说实话，看源码之前从来没有想到过这个需求，在指定的queue中释放对象，汗颜!)</p>
<h3 id="双向链表的选择"><a href="#双向链表的选择" class="headerlink" title="双向链表的选择"></a>双向链表的选择</h3><p>在YYMemoryCache中使用了双向链表来实现LRU的策略缓存，不止iOS平台，在其他平台，安卓，Linux等实现LRU算法都是使用双向链表+Map的方法。使用Map是为了更快找到要删除或移动的节点，链表是将经常使用的数据放到头部节点，删除的时候删除尾部节点的数据。一开始我想，这个明明用单向链表+Map就能实现，为什么要使用更加复杂的双线链表呢？</p>
<p>后来我又对比了双向链表与单向链表的的不同，单向链表每个节点只知道下个节点的内存地址，而不知道它上个节点的地址，双向链表既知道下个节点的地址，也知道上个节点的地址。正是因为这个原因，当我们要移动某个节点，比如移动中间的节点使它作为头部节点，假如用的是单向链表，因为它不知道它的上一个节点，所以还要遍历整个链表，找到上个节点，然后才能衔接起来。而双向链表不用遍历整个链表，它自己就知道它的上个节点地址。虽然双向链表更加复杂了一点，但是带来的好处，对性能的提升也是不言而喻的。</p>
<h3 id="接口的设计"><a href="#接口的设计" class="headerlink" title="接口的设计"></a>接口的设计</h3><p>YYCache里的接口及架构设计可以说是简洁明了，YYCache持有YYMemoryCache和YYDiskCache，两者分别负责内存缓存及磁盘缓存，两者之间互不影响。再来看下相关的api</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@interface YYCache : NSObject</div><div class="line"></div><div class="line">@property (copy, readonly) NSString *name</div><div class="line">@property (strong, readonly) YYMemoryCache *memoryCache</div><div class="line">@property (strong, readonly) YYDiskCache *diskCache</div><div class="line"></div><div class="line">- (nullable instancetype)initWithName:(NSString *)name</div><div class="line">- (nullable instancetype)initWithPath:(NSString *)path</div><div class="line">+ (nullable instancetype)cacheWithName:(NSString *)name</div><div class="line"></div><div class="line">- (BOOL)containsObjectForKey:(NSString *)key</div><div class="line">- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block</div><div class="line"> </div><div class="line">- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key</div><div class="line">- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block</div><div class="line"> </div><div class="line">- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key</div><div class="line">- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block</div><div class="line">- (void)removeObjectForKey:(NSString *)key</div><div class="line">- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block</div><div class="line">- (void)removeAllObjects</div><div class="line">- (void)removeAllObjectsWithBlock:(void(^)(void))block</div><div class="line">- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress</div><div class="line">                                 endBlock:(nullable void(^)(BOOL error))end</div></pre></td></tr></table></figure>
<p>可以说不用看注释，看方法名就可以直接知道该方法的作用，并且没有一个多余的方法。哪些方法该放在<code>.h</code>文件里声明给外部调用，哪些方法该放在<code>.m</code>文件里私有操作，都控制的完美无瑕。</p>
<p>YYCache里的接口及架构设计可以说是作为一个SDK的典范，并且代码也对每一个细节追求到极致。正因为设计的这么漂亮，源码读起来才会通俗易懂，让人赞叹👍！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/26/dispatch_once线程安全/" itemprop="url">
                  dispatch_once线程安全
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-26T22:04:18+08:00" content="2018-07-26">
              2018-07-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/26/dispatch_once线程安全/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/26/dispatch_once线程安全/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/07/26/dispatch_once线程安全/" class="leancloud_visitors" data-flag-title="dispatch_once线程安全">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">   ...</div><div class="line">&#125;);</div><div class="line">return instance;</div></pre></td></tr></table></figure>
<p>说到单例，大家都会想到用<code>dispatch_once</code>实现，今天来探究一下<code>dispatch_once</code>内部如何操作的，如何保证线程安全的。</p>
<p><code>dispatch_once_t</code>实质就是个<code>long</code>类型的基本变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef long dispatch_once_t</div></pre></td></tr></table></figure>
<p><code>dispatch_once</code> 函数实现为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void  dispatch_once(dispatch_once_t *val, dispatch_block_t block) &#123;</div><div class="line"></div><div class="line">	dispatch_once_f(val, block, _dispatch_Block_invoke(block));</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将基本变量的指针及block传进去，<code>dispatch_block_t</code> 是自定义的 ，这个<code>block</code>就是我们要实现的初始化方法，无参数，无返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void (^dispatch_block_t)(void);</div></pre></td></tr></table></figure>
<p><code>_dispatch_Block_invoke</code>也是个宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define _dispatch_Block_invoke(bb) \</div><div class="line">		((dispatch_function_t)((struct Block_layout *)bb)-&gt;invoke)</div></pre></td></tr></table></figure>
<p>它的作用是获得<code>block</code>内部的<code>invoke</code>的函数指针，这个指针指向的具体的<code>block</code>实现函数的调用地址，就是我们自己在<code>dispatch_block_t</code>里写的那段代码的具体实现地址。</p>
<p>将变量地址，<code>block</code>，<code>invoke</code>三个参数传入<code>dispatch_once_f</code>方法里，下面继续分析<code>dispatch_once_f</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)</div><div class="line">&#123;</div><div class="line">#if !DISPATCH_ONCE_INLINE_FASTPATH</div><div class="line">	if (likely(os_atomic_load(val, acquire) == DLOCK_ONCE_DONE)) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">#endif // !DISPATCH_ONCE_INLINE_FASTPATH</div><div class="line">	return dispatch_once_f_slow(val, ctxt, func);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>DISPATCH_ONCE_INLINE_FASTPATH</code>是判断当前编译环境，是真机还是模拟器。最终实现方法来到了<code>dispatch_once_f_slow</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">dispatch_once_f_slow(dispatch_once_t *val, void *ctxt, dispatch_function_t func)</div><div class="line">&#123;</div><div class="line">#if DISPATCH_GATE_USE_FOR_DISPATCH_ONCE</div><div class="line">	dispatch_once_gate_t l = (dispatch_once_gate_t)val;</div><div class="line"></div><div class="line">	if (_dispatch_once_gate_tryenter(l)) &#123;</div><div class="line">		_dispatch_client_callout(ctxt, func);</div><div class="line">		_dispatch_once_gate_broadcast(l);</div><div class="line">	&#125; else &#123;</div><div class="line">		_dispatch_once_gate_wait(l);</div><div class="line">	&#125;</div><div class="line">#else</div><div class="line">	_dispatch_once_waiter_t volatile *vval = (_dispatch_once_waiter_t*)val;</div><div class="line">	struct _dispatch_once_waiter_s dow = &#123; &#125;;</div><div class="line">	_dispatch_once_waiter_t tail = &amp;dow, next, tmp;</div><div class="line">	dispatch_thread_event_t event;</div><div class="line"></div><div class="line">	if (os_atomic_cmpxchg(vval, NULL, tail, acquire)) &#123;</div><div class="line">		dow.dow_thread = _dispatch_tid_self();</div><div class="line">		_dispatch_client_callout(ctxt, func);</div><div class="line"></div><div class="line">		next = (_dispatch_once_waiter_t)_dispatch_once_xchg_done(val);</div><div class="line">		while (next != tail) &#123;</div><div class="line">			tmp = (_dispatch_once_waiter_t)_dispatch_wait_until(next-&gt;dow_next);</div><div class="line">			event = &amp;next-&gt;dow_event;</div><div class="line">			next = tmp;</div><div class="line">			_dispatch_thread_event_signal(event);</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		_dispatch_thread_event_init(&amp;dow.dow_event);</div><div class="line">		next = *vval;</div><div class="line">		for (;;) &#123;</div><div class="line">			if (next == DISPATCH_ONCE_DONE) &#123;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			if (os_atomic_cmpxchgv(vval, next, tail, &amp;next, release)) &#123;</div><div class="line">				dow.dow_thread = next-&gt;dow_thread;</div><div class="line">				dow.dow_next = next;</div><div class="line">				if (dow.dow_thread) &#123;</div><div class="line">					pthread_priority_t pp = _dispatch_get_priority();</div><div class="line">					_dispatch_thread_override_start(dow.dow_thread, pp, val);</div><div class="line">				&#125;</div><div class="line">				_dispatch_thread_event_wait(&amp;dow.dow_event);</div><div class="line">				if (dow.dow_thread) &#123;</div><div class="line">					_dispatch_thread_override_end(dow.dow_thread, val);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		_dispatch_thread_event_destroy(&amp;dow.dow_event);</div><div class="line">	&#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很长，逐段分析：</p>
<p>首先初始化了一系列的变量，<code>_dispatch_once_waiter_s</code>类似于链表中的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct _dispatch_once_waiter_s &#123;</div><div class="line">	volatile struct _dispatch_once_waiter_s *volatile dow_next; // 下一个节点</div><div class="line">	dispatch_thread_event_s dow_event; // 信号量</div><div class="line">	mach_port_t dow_thread; // 线程端口</div><div class="line">&#125; *_dispatch_once_waiter_t;</div></pre></td></tr></table></figure>
<p><code>if (os_atomic_cmpxchg(vval, NULL, tail, acquire))</code>这行代码展开为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (*vval == NULL) &#123;</div><div class="line">	*vval = tail = &amp;dow;</div><div class="line">	return true;</div><div class="line">&#125; else &#123;</div><div class="line">	return false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>意思是传入的<code>*vval == NULL</code>如果为nil，则赋值，并返回true，并且这个方法是原子操作的。当我们第一次进来，<code>val=0</code>接下来执行<code>if</code>里面的代码。</p>
<p><code>_dispatch_client_callout</code>表示执行<code>block</code>，然后将next标记为<code>DISPATCH_ONCE_DONE</code>。</p>
<p>假如整个过程只有一个线程，那么下面的while循环不会执行，执行到这里就结束了，。假如有其他线程进来，就会进入else分支里。</p>
<p>else分支里，是一个死循环，先判断<code>if (next == DISPATCH_ONCE_DONE)</code>，如果是，直接跳出循环。每进来一次，都会生成一个<code>_dispatch_once_waiter_s</code>的节点，添加到链表的尾部，然后调用信号量等待。而链表的头部是第一次进来的，进入到if代码段的那个节点。当if分支执行完后，会进入while循环遍历链表，依次发送信号将线程唤醒。</p>
<p>这就是全部的执行过程，用到的知识点主要是原子性操作、链表。由此可以看出大家都说<code>dispatch_once</code>只执行一次这种说话是不严谨的，它本质上可以执行多次，只是把每次执行请求放到了内部的链表里。<br>还是画个图吧。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/dispatch_once%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/10/iOS国际化/" itemprop="url">
                  iOS国际化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-10T20:19:13+08:00" content="2018-07-10">
              2018-07-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/10/iOS国际化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/10/iOS国际化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/07/10/iOS国际化/" class="leancloud_visitors" data-flag-title="iOS国际化">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目里添加了国际化及应用内语言切换功能，遂整理下。</p>
<h3 id="简单国际化"><a href="#简单国际化" class="headerlink" title="简单国际化"></a>简单国际化</h3><p>当我们创建一个新应用时，文件目录下会默认有一个 <code>Base.lproj</code> 文件，这个文件就是项目在英文语言环境下的默认本地化文件夹。当我们不做国际化时，这个文件没什么用。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/international_baselproj.png" alt="image"><br>假如我们想支持更多的语言，可以在项目里这里设置</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/international_addLanguage.png" alt="image"></p>
<p>添加完成之后项目文件目录就多了几个语言文件，比如我们新添加了两种：简体中文和繁体中文</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/international_wenjain.png" alt="image"></p>
<h4 id="应用名称国际化"><a href="#应用名称国际化" class="headerlink" title="应用名称国际化"></a>应用名称国际化</h4><p>创建InfoPlist.strings文件(InfoPlist.strings，名称不要写错…)<br><img src="http://ocauxqtbu.bkt.clouddn.com/international_strings.png" alt="image"><br>然后分别在 <code>InfoPlist.strings</code> 文件里添加不同语言的key value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFBundleDisplayName = &quot;international&quot;;// 英文</div><div class="line">CFBundleDisplayName = &quot;国际化Demo&quot;;// 中文</div></pre></td></tr></table></figure>
<p>不仅应用名称可以国际化，其他 <code>info.plist</code> 中的字段可以设置，比如隐私权限设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSPhotoLibraryUsageDescription = &quot;请点击&apos;好&apos;以允许访问。如果不允许,你将无法使用图片功能&quot;;</div><div class="line">NSCameraUsageDescription = &quot;请点击&apos;好&apos;以允许访问。如果不允许,你将无法使用拍摄功能&quot;;</div><div class="line">NSMicrophoneUsageDescription = &quot;请点击&apos;好&apos;以允许访问。如果不允许,你将无法使用麦克风功能&quot;;</div><div class="line">NSLocationWhenInUseUsageDescription = &quot;请点击&apos;好&apos;以允许访问。如果不允许,你将无法使用位置功能&quot;;</div></pre></td></tr></table></figure>
<p>添加完之后切换语言应用名称会跟着更换：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/international_test4.jpg" alt="image"></p>
<h4 id="应用内容国际化"><a href="#应用内容国际化" class="headerlink" title="应用内容国际化"></a>应用内容国际化</h4><p>创建一个strings文件来用作内容国际化，下面会有三个子文件分别用来操作对应语言的国际化内容<br><img src="http://ocauxqtbu.bkt.clouddn.com/international_localizable.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;LabelText&quot;=&quot;hello,world&quot;;//英文</div><div class="line">&quot;LabelText&quot;=&quot;你好,世界&quot;;//中文</div></pre></td></tr></table></figure>
<p>当我们在代码中这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 100, 30)];</div><div class="line">label.text = NSLocalizedStringFromTable(@&quot;LabelText&quot;, @&quot;Localizable&quot;, nil);</div><div class="line">[self.view addSubview:label];</div></pre></td></tr></table></figure>
<p>那么这个lable就会当前手机系统的语言环境，根据 <code>LabelText</code> 这个key去取对应语言的value，如果应用没有对手机系统的语言进行国际化，则取默认语言，比如英文。</p>
<p>以上就是对APP进行简单国际化，但是这样有一点不好，就是只能根据手机系统自适应处理，无法进行APP内语言的切换。所以语言的国际化和应用内切换语言要我们自己来实现。 </p>
<h3 id="国际化的本质"><a href="#国际化的本质" class="headerlink" title="国际化的本质"></a>国际化的本质</h3><p>国际化的本质就是根据指定的language，找到本地此语言对应的资源文件(bundle)，在文件中查找key对应的字符串。应用名称的国际化，和APP内容的国际化都是这一个原理，那么我们就从这个原理入手，简述一下实现流程</p>
<ul>
<li>1.启动应用后，先查看本地有没有上次保存的语言id，如果有，则设这个语言为当前APP语言</li>
<li>2.如果没有，证明为第一次打开，即从APPStore下载后第一次打开，此时获取手机系统语言，假如APP内对这个语言进行国际化了，则把这个语言设置APP内语言，如果没有，使用默认语言，比如英语。(比如手机系统里语言为德语，但是没有对这个语言进行国际化)</li>
<li>3.后续的APP名称及APP内界面内容都根据设置的语言来进行国际化处理</li>
<li>4.APP内切换语言,就是改变了查找的bundle文件。比如，之前是英语，翻译字符串value从英语环境下的bundle文件下查找，切换成中文后，从中文环境下的bundle文件中查找value。最后，保存切换后的语言id到本地，以便下次使用。</li>
</ul>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="自建-lproj文件"><a href="#自建-lproj文件" class="headerlink" title="自建 lproj文件"></a>自建 <code>lproj</code>文件</h4><p>刚才提到了，添加语言后会在项目目录下自动生成对应语言的 <code>lproj</code> 文件。在这里，我们可以手动创建 <code>lproj</code> 文件。然后将这些文件放到一个文件夹下，统一管理<br><img src="http://ocauxqtbu.bkt.clouddn.com/international_addlproj.png" alt="image"><br>切换语言后，将bundle路径换成切换后语言的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// self.currentLanguage 为 zh-hans 或 zh-Hant 或 en</div><div class="line">NSString *path = [[NSBundle mainBundle]pathForResource:self.currentLanguage ofType:@&quot;lproj&quot;];</div><div class="line">self.bundle = [NSBundle bundleWithPath:path];</div></pre></td></tr></table></figure>
<p>获取key对应的value时，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(NSString *)getStringForKey:(NSString *)key withTable:(NSString *)table</div><div class="line">&#123;</div><div class="line">    if (self.bundle)</div><div class="line">    &#123;</div><div class="line">        return NSLocalizedStringFromTableInBundle(key, table, self.bundle, @&quot;&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return NSLocalizedStringFromTable(key, table, @&quot;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>-(NSString *)getStringForKey:(NSString *)key withTable:(NSString *)table</code> 这个方法为语言管理单例类的public方法，在 <code>.h</code>文件中声明，value都是通过单例类调用这个方法来获得各个语言的value。</p>
<h4 id="和服务端的同步"><a href="#和服务端的同步" class="headerlink" title="和服务端的同步"></a>和服务端的同步</h4><p>当我们从APPStore下载APP后，第一次打开应用获得当前手机系统的语言，还要把这个语言同步到服务端，告诉服务端我们使用的是哪个语言，并且后续的接口调用都要用到这个语言id。</p>
<p>服务端保存一份手机系统上所有语言的字符串列表，分安卓和iOS，这个需要安卓开发人员和iOS开发人员提供给后台，比如我提供的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@&quot;zh-Hans&quot;  //简体中文</div><div class="line">@&quot;zh-Hant&quot; //繁体中文</div><div class="line">@&quot;en&quot; //英语</div><div class="line">@&quot;ja&quot; //日文</div></pre></td></tr></table></figure>
<p>第一次启动时，通过 <code>[NSLocale preferredLanguages].firstObject</code> 这个方法获得当前手机系统语言，调用服务端语言接口后，拿当前手机系统语言和接口数据对比，获得语言id，然后后续的接口调用都可以使用这个语言id了。</p>
<h4 id="第三方库的国际化"><a href="#第三方库的国际化" class="headerlink" title="第三方库的国际化"></a>第三方库的国际化</h4><p>项目里采用了 <code>MJRefresh</code> 第三方刷新库，控件里的刷新状态文字也要国际化。但是这个库的国际化是自己做的，当APP内切换语言后，控件上的文字还是之前语言的文字。看了下源码，最后通过 <code>NSBundle+MJRefresh</code> 文件里的这个方法来获得不同语言的value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)mj_localizedStringForKey:(NSString *)key value:(NSString *)value &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是通过当前语言，获得bundle资源文件，然后在资源文件里得到value后返回。因为它自己有bundle资源文件，我们只需要把bundle文件的路径换成当前语言的文件路径就可以了。</p>
<p>当然了，不只这个刷新控件，其他有使用道的第三方库，也要国际化一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/06/我的产品体会/" itemprop="url">
                  我的产品体会
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-06T11:18:04+08:00" content="2018-07-06">
              2018-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/读书与感悟/" itemprop="url" rel="index">
                    <span itemprop="name">读书与感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/06/我的产品体会/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/06/我的产品体会/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/07/06/我的产品体会/" class="leancloud_visitors" data-flag-title="我的产品体会">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>踏入互联网移动开发这个行业也有三年了，从当初的懵懵懂懂到现在略有思考，这里说思考有点夸大了，只是从码农的角度，对于产品有自己的一点体会。可能与其他程序员不同，其他从事技术的程序员，都想成为全栈工程师，学学后端，学学前端，但是自己在闲暇之余，更多的是思考如何做好一个产品，给用户更好的体验。最近自己也看了几本关于互联网及产品的书籍，结合自己的经验，说一下自己的拙见。<br>我觉得一个好产品，应该有以下几个特点：</p>
<ul>
<li>有用</li>
<li>好用</li>
<li>改进的能力</li>
<li>商业模式</li>
</ul>
<h3 id="对我有用"><a href="#对我有用" class="headerlink" title="对我有用"></a>对我有用</h3><p>有用，即你这个产品对于我到底有什么用处，我能从中得到什么方便，核心思想就是定位你的核心功能以及核心用户。比如，你向我介绍一个小说类APP，说它内容如何丰富，体验如何良好，但是我从来不看小说，何来用这个小说APP之说。在做产品的时候，开发一个功能的时候，尽量多想想这个功能是否对用户有用处，是否对产品的核心用户有好处。当要加入一个功能时，多听听核心用户的声音。</p>
<p>如何定位你的核心用户，用户是什么样的人，用户需要什么，用户喜欢什么，用户讨厌什么，对于不同的行业平台，要有不同的思考方式。比如对于知乎，简书，掘金这种注重内容的，那些能够产生高质的博客的用户，就是核心用户；对于打车类的APP而言，经常出差的用户就是核心用户；YY语音的核心用户是游戏玩家。</p>
<p>当你的核心功能定位以后，不要轻易转型，也可以说，想转型也不是那么容易的。</p>
<p>比如我现在做的这个美甲APP，它的核心功能就是视频教学，美图展示；它的核心用户就是那些有强烈的学习欲望，通过这个平台能够提升自己的能力，购买所需要的物品。</p>
<h3 id="好用"><a href="#好用" class="headerlink" title="好用"></a>好用</h3><p>好用，即你这个产品用起来是否方便，对比与同行的竞争品，有什么特别的地方吸引我。</p>
<p>我一直提倡的是，保证内容优质的情况下，界面越简洁越好。这里不得不说一下微信，微信自从上线以来，界面一直保持简洁清爽的风格，并且可控制界面的显示内容，比如发现页面的管理。这里就体现出界面设计师的重要性了，一个界面该显示什么，不该显示什么，显示的话，应该以怎样的方式去呈现，这些都应该是好好斟酌的东西。再比如我有时候会看一下游戏直播，虎牙，斗鱼，熊猫这些APP都用过，其中最喜欢虎牙APP的界面风格，很简洁，没有杂乱无章的内容。我就只是想简单的看个直播而已，其他APP确给我推荐了很多无用的信息。</p>
<p>这里举个例子，设置界面如何排版。设置界面包括对账号的管理、APP设置的管理以及其他辅助的小功能。这里要分清什么功能要归到账号管理类目下，什么功能归到APP设置管理类目下，内容定下来，呈现风格就按平台的风格来呈现。iOS APP的风格就按苹果手机本身设置里的风格来，安卓APP就按安卓手机本身的设置风格来，没必要完全统一。</p>
<p>这里额外提一点，尽量少用弹框，这是用户很反感的信息呈现形式。</p>
<h3 id="改进的能力"><a href="#改进的能力" class="headerlink" title="改进的能力"></a>改进的能力</h3><p>意思就是你的产品要有持续的改进等能力，不要一直原地踏步，比如其他APP上有一些优秀的交互设计，可以借鉴一下。但是有一点特别重要，如果只是一味的抄袭借鉴，那么永远也学不到它的精髓。</p>
<p>当你加入了一个功能时，比如社区等，用这个功能的人很少，这时就要思考这个功能对于你这个APP的意义是什么，是否真的给用户带来了好处？</p>
<p>当你的核心用户给你的产品提建议时，不要忽视它，因为这是真真正正使用你产品的人的想法。如果他的建议被采纳，下个版本中更新了他的建议，那么他肯定会认为这个产品是个不断成长的产品，他认可了这个产品，说不一定他还会向同事朋友去推销你的产品。</p>
<h3 id="商业模式"><a href="#商业模式" class="headerlink" title="商业模式"></a>商业模式</h3><p>商业模式，我理解的分为两个部分，一个推广模式，二是盈利模式。</p>
<p>对于如何推广，一味的砸钱是行不通的，只能解决得了一时。一个推广模式是否为好的推广模式，最简单的方法就是，不再砸钱了，看用户数是否还在增长。对于盈利模式，在找投资时，投资人都会问，你的产品将来怎么赢利，有没有找到好的盈利模式。在周鸿祎的《我的互联网方法论》中提到了互联网的盈利模式有三种：</p>
<p>1.在网上卖东西。卖真实的东西，衣服鞋子，这种叫电子商务；卖股票基金等理财产品，叫互联网金融；卖虚拟的服务，叫O2O.</p>
<p>2.依靠广告收入。</p>
<p>3.以网游为代表的增值服务。</p>
<p>这三种方式都很常见，而对于移动APP来说，最普遍的就是广告收入了，通过接入广告，来赚取利益。但是，接入广告也要有好的方法，不要让用户反感。</p>
<p>总的来说，一个产品要有一个好的想法，好的方向，是否能为大众群体提供方便，加上可靠的技术团队实力和推广手段。唉，这话说起来容易，实现起来何其难啊！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/16/程序的启动链接过程/" itemprop="url">
                  程序的启动链接过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-16T10:32:04+08:00" content="2018-03-16">
              2018-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/16/程序的启动链接过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/16/程序的启动链接过程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/03/16/程序的启动链接过程/" class="leancloud_visitors" data-flag-title="程序的启动链接过程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>main函数是程序的启动入口，但是系统为程序的启动又做了哪些准备呢，二进制文件又是怎样加载进内存的呢？这两天花了点时间深入了了解了一下。</p>
<h3 id="Mach-O格式简单介绍"><a href="#Mach-O格式简单介绍" class="headerlink" title="Mach-O格式简单介绍"></a>Mach-O格式简单介绍</h3><p>Mach则是苹果操作系统内核，在Mach上，一种可执行的文件格是就是Mach-O（Mach Object file format），这是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。Mach-O 文件一般都有一个 Header ，各种 Load Commands 以及多个 Segment：<br><img src="http://ocauxqtbu.bkt.clouddn.com/link_mach-o.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.Header：保存了Mach-O的一些基本信息，包括了平台、文件类型、LoadCommands的个数等等。</div><div class="line">2.LoadCommands：这一段紧跟Header，加载Mach-O文件时会使用这里的数据来确定内存的分布。</div><div class="line">3.Data：每一个segment的具体数据都保存在这里，这里包含了具体的代码、数据等等。</div></pre></td></tr></table></figure>
<p>####Header<br><img src="http://ocauxqtbu.bkt.clouddn.com/link_mach-o_header.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Magic Number:			该文件是64位平台文件还是32位平台文件。值为0xFEEDFACF表示64位，0xFEEDFACE表示32位；</div><div class="line">CPU Type,CPU subType:	确定CPU的平台与版本；</div><div class="line">File Type:				该文件的类型。MH_EXECUTE表示这是一个可执行文件；</div><div class="line">Number of 				Load Commands:Load Commands的个数；</div><div class="line">Size of Load Commands:	Load Commands的长度；</div><div class="line">Flags:					dylb加载时需要的标志位；</div><div class="line">Reserved:				只有64位的时候才存在的字段，暂时没用</div></pre></td></tr></table></figure>
<p>####Load Commands<br>Load Commands表示的是加载命令，不同的字段就是表示不同的命令，通过解析LoadCommand来加载接下来的数据。举几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LC_MAIN：整个程序的入口地址，保证进程启动后能够正常的开始整个应用程序的运行</div><div class="line">LC_UUID：唯一ID</div><div class="line">LC_LOAD_DYLINKER：获得动态加载器地址,调用dylb程序</div><div class="line">LC_CODE_SIGNATURE：进行数字签名.</div></pre></td></tr></table></figure>
<p>等等</p>
<p>####Segment &amp; Section<br>Data表示原始数据,可以拥有多个段（segment），每个段可以拥有零个或多个区域（section）。每一个段（segment）都拥有一段虚拟地址映射到进程的地址空间。<br>加载数据时，主要加载的就是<code>LC_SEGMENT</code>或者<code>LC_SEGMENT_64</code>。这里大部分的数据是用来帮助内核将Segment映射到虚拟内存。<code>LC_SEGMENT_64</code>的数据结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</div><div class="line">	uint32_t	cmd;		/* LC_SEGMENT_64 */</div><div class="line">	uint32_t	cmdsize;	/* load command的大小 */</div><div class="line">	char		segname[16];	/* segment name */</div><div class="line">	uint64_t	vmaddr;		/* 段的虚拟内存地址 */</div><div class="line">	uint64_t	vmsize;		/*  段的虚拟内存大小 */</div><div class="line">	uint64_t	fileoff;	/* 段在文件中偏移量 */</div><div class="line">	uint64_t	filesize;	/* 段在文件中的大小 */</div><div class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</div><div class="line">	vm_prot_t	initprot;	/* initial VM protection */</div><div class="line">	uint32_t	nsects;		/* 标示了Segment中有多少secetion */</div><div class="line">	uint32_t	flags;		/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Section的数据结构为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct section &#123; /* for 32-bit architectures */</div><div class="line">    char        sectname[16];   /* name of this section */</div><div class="line">    char        segname[16];    /* segment this section goes in */</div><div class="line">    uint32_t    addr;       /* memory address of this section */</div><div class="line">    uint32_t    size;       /* size in bytes of this section */</div><div class="line">    uint32_t    offset;     /* file offset of this section */</div><div class="line">    uint32_t    align;      /* 字节大小对齐 */</div><div class="line">    uint32_t    reloff;     /* file offset of relocation entries */</div><div class="line">    uint32_t    nreloc;     /* number of relocation entries */</div><div class="line">    uint32_t    flags;      /* flags (section type and attributes)*/</div><div class="line">    uint32_t    reserved1;  /* reserved (for offset or index) */</div><div class="line">    uint32_t    reserved2;  /* reserved (for count or sizeof) */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>__PAGEZERO</code>是第一个段，它的大小在 32 位系统是 4KB+，而在 64 位系统是 4GB+。位于虚拟内存从 0x000000 到 App 真实起始位置之间，都是被标记为不可读写和不可执行。因为里面并没有数据，所以 file size 为 0。主要的作用是为了捕获 NULL 指针使用和指针截断错误，防止引起系统崩溃。开发中常见的 EXC_BAD_ACCESS 异常都是因为错误访问到这里了。</p>
</li>
<li><p><code>__TEXT</code> 段包含了 Mach 头部，被执行的代码和只读常量，它被只读和可执行的方式映射。以下是几个常见的 section：</p>
</li>
<li><p><code>__text</code> 里就是程序编译后的机器码。</p>
</li>
<li><code>__stubs</code> 和 <code>__stub_helper</code> 是给动态链接器（dyld）使用的。</li>
<li><code>__const</code> 包含常量变量，所有不需要重定向的常量数据都会被编译器放在这里。</li>
<li><code>__cstring</code> 包含硬编码的字符串常量。</li>
<li><code>__DATA</code> 段包含了可读写的内容，全局变量和静态变量等，以可读写和不可执行的方式映射。常见的 section 有：<br><code>__nl_symbol_ptr</code> 和 <code>__la_symbol_ptr</code> 分别是 non-lazy 和 lazy 符号指针。lazy 符号指针用于可执行文件中调用未定义的函数，例如不包含在可执行文件中的函数，它们将会延迟加载。而针对 non-lazy 符号指针，当可执行文件被加载同时，也会被加载。</li>
<li><code>__const</code> 包含需要重定向的常量数据。</li>
<li><code>__bss</code> 包含没有被初始化的静态变量。</li>
<li><code>__LINKEDIT</code> 段它的作用是包含如何加载整个文件的「元数据」。例如符号表，字符串表和重定位表。代码签名后每页的加密散列值也会存储到这里。</li>
</ul>
<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>一个程序的编译过程简单分为预编译、编译、汇编、链接等过程。链接就是讲多个目标文件合并成一个可执行文件，静态库和动态库的区别就是在链接阶段如何处理库。在链接阶段，将汇编生成的目标文件与引用到的库一个链接打包到可执行文件中，因为对应的链接方式成为静态链接。而动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。使用动态库的好处有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.代码共用：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份</div><div class="line">2.易于维护：由于被依赖的 lib 是程序执行时才 link 的，所以这些 lib 很容易做更新</div><div class="line">3.减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多</div></pre></td></tr></table></figure>
<p>但是同样的，加载动态库，就需要动态连接器dylb。动态链接加载器在系统中以一个用户态的可执行文件形式存在，一般应用程序会在Mach-O文件部分指定一个LC_LOAD_DYLINKER的加载命令，此加载命令指定了dyld的路径，通常它的默认值是“/usr/lib/dyld”。系统内核在加载Mach-O文件时，会使用该路径指定的程序作为动态库的加载器来加载dylib。不过dylb是<a href="https://github.com/opensource-apple/dyld" target="_blank" rel="external">开源</a>的。</p>
<p>###mach-o文件加载</p>
<p>####dyld自身如何加载</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/link_objc_init.png" alt="image"><br>我们在程序中设个断点，断在<code>_objc_init</code>，我们看到了栈底的<code>_dylb_start</code>方法，那么问题来了,既然各种二进制都是走dyld加载的，那么dyld自身是如何加载进来的呢？<br>系统在解析Mach-O文件时，<code>_dylb_start</code> 的方法地址的是在 <code>LC_UNIXTHREAD</code> 段中解析出来的，然后通过 <code>LC_LOAD_DYLINKER</code> 这个字段来启动这个二进制加载器。从下面dylb的这段源码可以看到，启动前还要做一些准备引导工作，到最后才是调用<code>dyld::_main</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</div><div class="line">//  In dyld we have to do this manually.</div><div class="line">//</div><div class="line">uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], </div><div class="line">				intptr_t slide, const struct macho_header* dyldsMachHeader,</div><div class="line">				uintptr_t* startGlue)</div><div class="line">&#123;</div><div class="line">	// if kernel had to slide dyld, we need to fix up load sensitive locations</div><div class="line">	// we have to do this before using any global variables</div><div class="line">	if ( slide != 0 ) &#123;</div><div class="line">		rebaseDyld(dyldsMachHeader, slide);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// allow dyld to use mach messaging</div><div class="line">	mach_init();</div><div class="line"></div><div class="line">	// kernel sets up env pointer to be just past end of agv array</div><div class="line">	const char** envp = &amp;argv[argc+1];</div><div class="line">	</div><div class="line">	// kernel sets up apple pointer to be just past end of envp array</div><div class="line">	const char** apple = envp;</div><div class="line">	while(*apple != NULL) &#123; ++apple; &#125;</div><div class="line">	++apple;</div><div class="line"></div><div class="line">	// set up random value for stack canary</div><div class="line">	__guard_setup(apple);</div><div class="line"></div><div class="line">#if DYLD_INITIALIZER_SUPPORT</div><div class="line">	// run all C++ initializers inside dyld</div><div class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</div><div class="line">#endif</div><div class="line"></div><div class="line">	// now that we are done bootstrapping dyld, call dyld&apos;s main</div><div class="line">	uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader);</div><div class="line">	return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><p>有兴趣的同学可以下载源码看下，<code>dyld::_main</code>main方法做的主要事情有</p>
<ul>
<li>设置运行环境，环境变量</li>
<li>实例化Image</li>
<li>加载共享缓存</li>
<li>动态库的版本化重载</li>
<li>加载插入的动态库</li>
<li>link主程序</li>
<li>link插入的动态库</li>
<li>weakBind弱符号绑定</li>
<li>initialize</li>
<li>查找入口点并返回</li>
</ul>
<p>在所有的动态库做好符号重定位和初始化工作之后，也就是 dyld::_main 临近末尾的时候，dyld 会获取 main 函数的地址返回给 dyld，dyld 紧接着调用 main 函数，将控制权交换给主程序，程序开始真正的执行。<br>下面是<code>dyld::_main</code>方法的部分源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</div><div class="line">// sets up some registers and call this function.</div><div class="line">//</div><div class="line">// Returns address of main() in target program which __dyld_start jumps to</div><div class="line">//</div><div class="line">uintptr_t</div><div class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </div><div class="line">		int argc, const char* argv[], const char* envp[], const char* apple[], </div><div class="line">		uintptr_t* startGlue) &#123;</div><div class="line">		...</div><div class="line">		//实例化Image</div><div class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</div><div class="line">		&#125;</div><div class="line">		...</div><div class="line">		//		加载共享缓存</div><div class="line">		checkSharedRegionDisable();</div><div class="line">		...</div><div class="line">			#if DYLD_SHARED_CACHE_SUPPORT</div><div class="line">//		动态库的版本化重载</div><div class="line">		if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion )</div><div class="line">			mapSharedCache();</div><div class="line">	#endif</div><div class="line"></div><div class="line">		// Now that shared cache is loaded, setup an versioned dylib overrides</div><div class="line">	#if SUPPORT_VERSIONED_PATHS</div><div class="line">		checkVersionedPaths();</div><div class="line">	#endif</div><div class="line">//加载插入的动态库</div><div class="line">		// load any inserted libraries</div><div class="line">		if	( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;</div><div class="line">			for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) </div><div class="line">				loadInsertedDylib(*lib);</div><div class="line">		&#125;</div><div class="line">		// record count of inserted libraries so that a flat search will look at </div><div class="line">		// inserted libraries, then main, then others.</div><div class="line">		sInsertedDylibCount = sAllImages.size()-1;</div><div class="line"></div><div class="line">//		link主程序</div><div class="line">		// link main executable</div><div class="line">		gLinkContext.linkingMainExecutable = true;</div><div class="line">		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL));</div><div class="line">		sMainExecutable-&gt;setNeverUnloadRecursive();</div><div class="line">		if ( sMainExecutable-&gt;forceFlat() ) &#123;</div><div class="line">			gLinkContext.bindFlat = true;</div><div class="line">			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>我们来看一下实例化image的过程,Runtime的初始化过程就是在这里进行的。这个image不是图片的意思，它大概表示一个二进制文件，<code>instantiateFromLoadedImage</code>这个方法就是实例化的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// The kernel maps in main executable before dyld gets control.  We need to </div><div class="line">// make an ImageLoader* for the already mapped in main executable.</div><div class="line">static ImageLoader* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)</div><div class="line">&#123;</div><div class="line">	// try mach-o loader</div><div class="line">	if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123; //检测macho文件是否符合条件,意思是该手机能否处理此mach-o文件</div><div class="line">//		初始化实例：方法内部通过判断mach-o文件是否是压缩过的，然后选择相应的类进行实例化</div><div class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</div><div class="line">//		添加image到管理的模块中</div><div class="line">		addImage(image);</div><div class="line">		return image;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	throw &quot;main executable not a known format&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>isCompatibleMachO</code>方法部分源码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// This is used to validate if a non-fat (aka thin or raw) mach-o file can be used</div><div class="line">// on the current processor. //</div><div class="line">bool isCompatibleMachO(const uint8_t* firstPage, const char* path)</div><div class="line">&#123;</div><div class="line">#if CPU_SUBTYPES_SUPPORTED</div><div class="line">	// It is deemed compatible if any of the following are true:</div><div class="line">	//  1) mach_header subtype is in list of compatible subtypes for running processor</div><div class="line">	//  2) mach_header subtype is same as running processor subtype</div><div class="line">	//  3) mach_header subtype runs on all processor variants</div><div class="line">	const mach_header* mh = (mach_header*)firstPage;</div><div class="line">	...</div><div class="line">	...</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>从注释中，可以看出，要满足以下三个条件，手机才能处理此mach-o文件</p>
<ul>
<li>mach_header中的subtype支持当前CPU版本。</li>
<li>mach_header中的subtype和当前正在运行的CPU版本相同。</li>
<li>mach_header中的subtype在该CPU的所有版本都可以处理。</li>
</ul>
<p><code>instantiateMainExecutable</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// create image for main executable</div><div class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext&amp; context)</div><div class="line">&#123;</div><div class="line">	//dyld::log(&quot;ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n&quot;,</div><div class="line">	//	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</div><div class="line">	bool compressed;</div><div class="line">	unsigned int segCount;</div><div class="line">	unsigned int libCount;</div><div class="line">	const linkedit_data_command* codeSigCmd;</div><div class="line">	const encryption_info_command* encryptCmd;</div><div class="line">//	判断mach-o文件是否是压缩过</div><div class="line">	sniffLoadCommands(mh, path, false, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</div><div class="line">	// instantiate concrete class based on content of load commands</div><div class="line">//	通过是否压缩，用不同的方法来处理</div><div class="line">	if ( compressed )</div><div class="line">		return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">	else</div><div class="line">#if SUPPORT_CLASSIC_MACHO</div><div class="line">		return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</div><div class="line">#else</div><div class="line">		throw &quot;missing LC_DYLD_INFO load command&quot;;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先判断mach-o文件是否压缩过，然后再用不用的方式处理此文件。两个方法的处理方式大同小异，<code>ImageLoaderMachOClassic::instantiateMainExecutable</code>方法里又调用了<code>ImageLoaderMachOClassic::instantiateStart</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// construct ImageLoaderMachOClassic using &quot;placement new&quot; with SegmentMachO objects array at end</div><div class="line">ImageLoaderMachOClassic* ImageLoaderMachOClassic::instantiateStart(const macho_header* mh, const char* path,</div><div class="line">																		unsigned int segCount, unsigned int libCount)</div><div class="line">&#123;</div><div class="line">	size_t size = sizeof(ImageLoaderMachOClassic) + segCount * sizeof(uint32_t) + libCount * sizeof(ImageLoader*);</div><div class="line">	ImageLoaderMachOClassic* allocatedSpace = static_cast&lt;ImageLoaderMachOClassic*&gt;(malloc(size));</div><div class="line">	if ( allocatedSpace == NULL )</div><div class="line">		throw &quot;malloc failed&quot;;</div><div class="line">	uint32_t* segOffsets = ((uint32_t*)(((uint8_t*)allocatedSpace) + sizeof(ImageLoaderMachOClassic)));</div><div class="line">	bzero(&amp;segOffsets[segCount], libCount*sizeof(void*));	// zero out lib array</div><div class="line">	return new (allocatedSpace) ImageLoaderMachOClassic(mh, path, segCount, segOffsets, libCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法内主要是申请内存，然后调用<code>ImageLoaderMachOClassic</code>方法，根据mach-o文件segments的规则将数据加载到内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ImageLoaderMachO::ImageLoaderMachO(const macho_header* mh, const char* path, unsigned int segCount, </div><div class="line">																uint32_t segOffsets[], unsigned int libCount)</div><div class="line"> : ImageLoader(path, libCount), fCoveredCodeLength(0), fMachOData((uint8_t*)mh), fLinkEditBase(NULL), fSlide(0),</div><div class="line">......</div><div class="line">&#123;</div><div class="line">	fIsSplitSeg = ((mh-&gt;flags &amp; MH_SPLIT_SEGS) != 0);        </div><div class="line"></div><div class="line">	// construct SegmentMachO object for each LC_SEGMENT cmd using &quot;placement new&quot; to put </div><div class="line">	// each SegmentMachO object in array at end of ImageLoaderMachO object</div><div class="line">	const uint32_t cmd_count = mh-&gt;ncmds;</div><div class="line">	const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)];</div><div class="line">	const struct load_command* cmd = cmds;</div><div class="line">	for (uint32_t i = 0, segIndex=0; i &lt; cmd_count; ++i) &#123;</div><div class="line">		if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</div><div class="line">			const struct macho_segment_command* segCmd = (struct macho_segment_command*)cmd;</div><div class="line">			// ignore zero-sized segments</div><div class="line">			if ( segCmd-&gt;vmsize != 0 ) &#123;</div><div class="line">				// record offset of load command</div><div class="line">				segOffsets[segIndex++] = (uint32_t)((uint8_t*)segCmd - fMachOData);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，这个方法就执行完了。然后就是最开始的调用<code>addimage</code>方法。这里涉及的源代码非常多，我只是粘贴了一部分。</p>
<p>####Runtime是在哪个过程中初始化的？</p>
<p>从上面的那个<code>_objc_init</code>调用栈可以看出，<code>initializeMainExecutable</code>内会进行Runtime的初始化</p>
<ul>
<li>initializeMainExecutable()</li>
<li>ImageLoader::runInitializers()</li>
<li>…</li>
<li>doModInitFunctions()</li>
<li>libdispatch_init</li>
<li>_os_object_init</li>
</ul>
<p>最终的，在<code>_os_object_init</code>这个方法内调用了<code>_objc_init()</code>方法，Runtime 接手后调用，调用map_images 做解析和处理，把 Category 的实例方法、协议以及属性添加到类上，把 Category 的类方法和协议添加到类的 metaclass 上；接下来 <code>load_images</code> 中调用 <code>call_load_methods</code> 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 load 方法和其 Category 的 load 方法。</p>
<p>本文只是简单介绍了dylb加载mach-o文件的简单流程，具体方法内部如何加载并没有过多探究，比如符号绑定，延迟加载等每一个知识点都可以写一篇文章来阐述。如有错误，请指正</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/19/容器类型数据防Crash处理/" itemprop="url">
                  容器类型数据防Crash处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-19T19:32:07+08:00" content="2018-01-19">
              2018-01-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/01/19/容器类型数据防Crash处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/19/容器类型数据防Crash处理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/19/容器类型数据防Crash处理/" class="leancloud_visitors" data-flag-title="容器类型数据防Crash处理">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="容器类型处理"><a href="#容器类型处理" class="headerlink" title="容器类型处理"></a>容器类型处理</h3><p>当我们使用NSArray或NSDictionary,如果使用不当，很容易造成crash比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@1,@2,@3];</div><div class="line">array[3];</div><div class="line"></div><div class="line">id value = nil;</div><div class="line">NSDictionary *dic = @&#123;@&quot;key&quot;:value&#125;;</div></pre></td></tr></table></figure>
<p>数组越界和初始化NSDictionary时value为nil，都会crash.</p>
<p>防护措施就是hook系统方法，在自己的方法里先进行判断，然后再调用系统方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ZJSwizzleMethod(NSClassFromString(@&quot;__NSArrayI&quot;), @selector(objectAtIndex:), </div><div class="line">@selector(zj_objectAtIndex:));</div><div class="line"></div><div class="line">void ZJSwizzleMethod(Class c, SEL origSEL, SEL newSEL) &#123;</div><div class="line">    Method origMethod = class_getInstanceMethod(c, origSEL);</div><div class="line">    Method newMethod = nil;</div><div class="line">    if (!origMethod) &#123;</div><div class="line">        c = object_getClass(c);</div><div class="line">        return ZJSwizzleMethod(c, origSEL, newSEL);</div><div class="line">    &#125;else&#123;</div><div class="line">        newMethod = class_getInstanceMethod(c, newSEL);</div><div class="line">        if (!newMethod) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if(class_addMethod(c, origSEL, method_getImplementation(newMethod), </div><div class="line">    method_getTypeEncoding(newMethod)))&#123;</div><div class="line">            </div><div class="line">        class_replaceMethod(c, newSEL, method_getImplementation(origMethod),</div><div class="line">         method_getTypeEncoding(origMethod));</div><div class="line">    &#125;else&#123;</div><div class="line">            </div><div class="line">        method_exchangeImplementations(origMethod, newMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在交换的方法里判断index是否小于数组个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)zj_objectAtIndex:(NSUInteger)index &#123;</div><div class="line">    </div><div class="line">    if(index &gt;= self.count) &#123;</div><div class="line">        ZJSafeCollectionLog(@&quot;[%@ %@] index &#123;%zd&#125; beyond bounds [0...%zd]&quot;,NSStringFromClass([self class]),NSStringFromSelector(_cmd),index,MAX(self.count - 1, 0));</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [self zj_objectAtIndex:index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果越界，就在控制台输出日志，但是不会Crash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void ZJSafeCollectionLog(NSString*fmt,...) &#123;</div><div class="line">    if (ZJSafeCollectionLogEnabled)</div><div class="line">    &#123;</div><div class="line">        va_list ap;</div><div class="line">        va_start(ap, fmt);</div><div class="line">        NSString *content = [[NSString alloc] initWithFormat:fmt arguments:ap];</div><div class="line">        NSLog(@&quot;%@&quot;, content);</div><div class="line">        va_end(ap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例如刚才的这段代码，输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@1,@2,@3];</div><div class="line">array[3];</div><div class="line"></div><div class="line">[__NSArrayI objectAtIndexedSubscript:] index &#123;3&#125; beyond bounds [0...2]</div></pre></td></tr></table></figure>
<p>同样的，不仅仅是NSArray,对NSMutableArray，NSDictionary，NSMutableDictionary都hook了常用的方法，具体见<a href="https://github.com/coderZhou10496/ZJSafeCollectionDemo" target="_blank" rel="external">Github地址</a></p>
<h3 id="unrecognized-selector处理"><a href="#unrecognized-selector处理" class="headerlink" title="unrecognized selector处理"></a>unrecognized selector处理</h3><p>这个异常是未实现相应的方法，这个Crash防护措施是也是用Runtime进行消息转发。消息转发过程为：</p>
<ul>
<li><ol>
<li>调用resolveInstanceMethod:方法 (或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会响应这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。</li>
</ol>
</li>
<li><ol>
<li>调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</li>
</ol>
</li>
<li><ol>
<li>调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。在forwardInvocation里进行转发。</li>
</ol>
</li>
</ul>
<p>可以看出，我们可以在这三个过程中进行动态的添加方法，或对未实现的方法进行转发。</p>
<p>这种Crash类型分两种，一种是实例方法未实现，一种是类方法未实现。如果是实例方法，在这三步中任何一步进行补救就行，但是如果是类方法，只能在第一步中动态的添加方法来进行防护。</p>
<p>创建一个NSObject的分类，重写系统方法。但是如果用分类重写方法的话，就会出现一个问题，就是会拦截系统自带的方法，而这些是不需要我们处理的，系统会自动处理，所以我们只需要处理自己创建的类就行了，比如对类方法进行防护Crash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</div><div class="line">#warning &apos;ZJTestClass&apos; only test class</div><div class="line">    Class metaClass = object_getClass([ZJTestClass class]);</div><div class="line">    if([self isKindOfClass:[metaClass class]]) &#123;</div><div class="line">        class_addMethod(metaClass, sel, (IMP)remedyMethod, &quot;v@:&quot;);</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ZJTestClass为自己创建的class，实际项目中可以换成BaseModel或者BaseController.如果是类方法未实现，就会进入<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>方法里。因为是类方法，所以代码中的metaClass为元类，如果是自己创建的类，就会进入到if语句中，从而动态添加方法。</p>
<p>对于实例方法Crash的防护，我是在第二步进行的，具体原因在<a href="https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651113088&amp;idx=1&amp;sn=10b28d7fbcdf0def1a47113e5505728d" target="_blank" rel="external">这篇文章中</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.resolveInstanceMethod需要在类的本身上动态添加它本身不存在的方法，这些方法对于该类本身来说冗余的</div><div class="line">2.forwardInvocation可以通过NSInvocation的形式将消息转发给多个对象，但是其开销较大，需要</div><div class="line">创建新的NSInvocation对象，并且forwardInvocation的函数经常被使用者调用，来做多层消息转发</div><div class="line">选择机制，不适合多次重写</div><div class="line">3.forwardingTargetForSelector可以将消息转发给一个对象，开销较小，并且被重写的概率较低，适合重写</div></pre></td></tr></table></figure>
<p>具体代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void remedyMethod (id self,SEL _cmd)</div><div class="line">&#123;</div><div class="line">    if(ZJForwardingLogEnabled) &#123;</div><div class="line">        Class cs = object_getClass(self);</div><div class="line">        NSLog(@&quot;[%@ %@] unrecognized selector&quot;,NSStringFromClass(cs),NSStringFromSelector(_cmd));</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">#warning &apos;ZJTestClass&apos; only test class</div><div class="line">    if([self isKindOfClass:[UIResponder class]]|| [self isKindOfClass:[ZJTestClass class]] || [self isKindOfClass:[NSNull class]]) &#123;</div><div class="line">        Class ZJProtectorCls = NSClassFromString(@&quot;ZJProtector&quot;);</div><div class="line">        if(!ZJProtectorCls) &#123;</div><div class="line">            ZJProtectorCls = objc_allocateClassPair([NSObject class], &quot;ZJProtector&quot;, 0);</div><div class="line">            objc_registerClassPair(ZJProtectorCls);</div><div class="line">        &#125;</div><div class="line">        class_addMethod(ZJProtectorCls, aSelector, (IMP)remedyMethod, &quot;v@:&quot;);</div><div class="line"></div><div class="line">        Class ZJProtector = [ZJProtectorCls class];</div><div class="line">        id instance = [[ZJProtector alloc] init];</div><div class="line">        return instance;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>动态的创建了一个类<code>ZJProtector</code>，然后再对这个类添加方法<code>class_addMethod</code>。</p>
<p>最后消息会进入到remedyMethod方法里，方法里有日志输出。</p>
<h3 id="对NSNull的处理"><a href="#对NSNull的处理" class="headerlink" title="对NSNull的处理"></a>对NSNull的处理</h3><p>NSNull与nil不同，对nil发送任何方法都是无效的，不会Crash，但是NSNull就像平常使用的类一样，会Crash。GitHub上有一个<a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="external">NullSafe</a>库，是专门处理这个问题的。也是用消息转发处理的。其中有段代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//get class list </div><div class="line">int numClasses = objc_getClassList(NULL, 0);</div><div class="line">Class *classes = (Class *)malloc(sizeof(Class) * (unsigned long)numClasses);</div><div class="line">numClasses = objc_getClassList(classes, numClasses);</div><div class="line"></div><div class="line">//add to list for checking</div><div class="line">for (int i = 0; i &lt; numClasses; i++)</div><div class="line">&#123;</div><div class="line">    //determine if class has a superclass</div><div class="line">    Class someClass = classes[i];</div><div class="line">    Class superclass = class_getSuperclass(someClass);</div><div class="line">    while (superclass)</div><div class="line">    &#123;</div><div class="line">        if (superclass == [NSObject class])</div><div class="line">        &#123;</div><div class="line">            [classList addObject:someClass];</div><div class="line">            [classList removeObject:[someClass superclass]];</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        superclass = class_getSuperclass(superclass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码意思是获取项目中所有的类，然后遍历，如果是NSObject的子类，就添加到NSMutableSet里。我测试了下，即使为空工程，numClasses为11970，意思是要遍历11970次，非常耗时间。并且在转发时，还要遍历这个classList，判断里面的类是否能响应调用的方法，找到了一个类能响应，就停止遍历。比较耗时间，所以我感觉这样做不太合理。所以我在上面的<code>forwardingTargetForSelector</code>里也添加了对NSNull的判断。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSNull *nul = [NSNull null];</div><div class="line">[nul performSelector:@selector(testMethod)];</div></pre></td></tr></table></figure>
<p>这样写也不会Crash.但是如果仅仅是用了NullSafe这个库，是处理不了的，因为它仅仅是把消息转发给其他类，然而并没有一个类能响应这个方法，所以一样抛出异常。</p>
<p>具体Demo：<a href="https://github.com/coderZhou10496/ZJSafeCollectionDemo" target="_blank" rel="external">Github</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/04/UIView block动画原理分析/" itemprop="url">
                  UIView block动画原理浅析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-04T18:05:52+08:00" content="2018-01-04">
              2018-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/01/04/UIView block动画原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/04/UIView block动画原理分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/04/UIView block动画原理分析/" class="leancloud_visitors" data-flag-title="UIView block动画原理浅析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们在Xcode里写下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:1 animations:^&#123;</div><div class="line">        view.center = CGPointMake(200, 200);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>我们的view就会进行动画，那么我们今天来探究两个问题</p>
<p> 1.这行代码写在block里面跟写在外面到底有什么不一样，系统是怎么处理的？</p>
<p> 2.系统是怎么知道 <code>view.center = CGPointMake(200, 200)</code> 这行代码是写在 UIView block 中的？</p>
<h3 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h3><p>动画分为隐式动画和显示动画，隐式动画就是我们并没有指定任何动画的类型，仅仅是改变了一个属性，没有加动画特效，但它却默认有动画效果。区分隐式动画和显示动画是由由CoreAnimation中的CATransaction控制的。官方文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Core Animation supports two types of transactions: implicit transactions </div><div class="line">and explicit transactions. Implicit transactions are created automatically</div><div class="line">when the layer tree is modified by a thread without an active transaction </div><div class="line">and are committed automatically when the thread&apos;s runloop next iterates. </div><div class="line">Explicit transactions occur when the the application sends the </div><div class="line">CATransaction class a begin message before modifying the layer tree, and a </div><div class="line">commit message afterwards.</div></pre></td></tr></table></figure>
<p>意思是CoreAnimation支持两种事务，显式事务和隐式事务。<br>显式事务是调用[CATransaction begin]，然后是[CATransaction commit]。当没有实现这些时CoreAnimation自动创建隐式事务，它们在线程的运行循环下一次迭代时自动提交。</p>
<p>大家按住cmd点进CALayer的头文件中看的话，会发现很多的属性的注释中，最后会有一个词叫做Animatable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/** Geometry and layer hierarchy properties. **/</div><div class="line">/* The bounds of the layer. Defaults to CGRectZero. Animatable. */</div><div class="line"></div><div class="line">@property CGRect bounds;</div></pre></td></tr></table></figure>
<p>表示直接对layer的这个属性进行赋值，会产生隐式动画。</p>
<p>比如这段代码，点击按钮改变创建的layer的背景色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">self.layer = [CALayer layer];</div><div class="line">self.layer.frame = CGRectMake(130.0f, 200.0f, 100.0f, 100.0f);</div><div class="line">self.layer.backgroundColor = [UIColor blueColor].CGColor; </div><div class="line">[self.view.layer addSublayer:self.layer];</div><div class="line"></div><div class="line">- (IBAction)click:(UIButton *)sender &#123;</div><div class="line">    sender.selected = !sender.selected;</div><div class="line">    self.layer.backgroundColor = sender.selected ? [UIColor redColor].CGColor : [UIColor blueColor].CGColor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AnimationColor1.gif" alt="image"></p>
<p>可以看到，每一次改变颜色都有默认的很短的动画效果，这个动画就是隐式动画。</p>
<p>但是假如我们这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (IBAction)click:(UIButton *)sender &#123;</div><div class="line"></div><div class="line">	[CATransaction begin];</div><div class="line">	[CATransaction setAnimationDuration:1.0];</div><div class="line">    sender.selected = !sender.selected;</div><div class="line">    self.layer.backgroundColor = sender.selected ? [UIColor redColor].CGColor : [UIColor blueColor].CGColor;</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AnimationColor2.gif" alt="image"></p>
<p>这样就是显式动画，这样我们就可以看到动画效果了。</p>
<p>在iOS 4之前我们通过下面的方式进行动画，实际上在 <code>beginAnimations:context:</code> 和 <code>commitAnimations</code>之间所有视图或者图层属性的改变而做的动画都是由于设置了CATransaction的原因,另外Block动画方法也是一样，CATransaction 的<code>begin</code> 和 <code>commit</code> 会在block块中内部自动调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[UIView beginAnimations:@&quot;...&quot; context:nil];</div><div class="line">...</div><div class="line">...</div><div class="line">[UIView commitAnimations];</div></pre></td></tr></table></figure>
<h3 id="actionForLayer-forKey-方法"><a href="#actionForLayer-forKey-方法" class="headerlink" title="actionForLayer: forKey:方法"></a>actionForLayer: forKey:方法</h3><p>CALayer有个属性delegate，创建layer时，delegate默认为nil，动画效果就按默认的隐式动画呈现。如果对delegate赋值，并且这个delegate实现了delegate方法，那么动画效果就由delegate方法控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的返回值分以下三种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.返回实现了`&lt;CAAction&gt;`的对象,就按照对象的动画效果</div><div class="line"></div><div class="line">2.返回nil，意思等同于是没有实现这个方法，隐式动画。</div><div class="line"></div><div class="line">3.返回NSNull对象，表示结束，无隐式动画。</div></pre></td></tr></table></figure>
<p>那么这个方法什么时候调用呢？是当这个layer显示、不显示、和属性改变的时候调用，并且从CALayer的头文件可以看出显示和不显示的event参数值为 <code>onOrderIn</code> 和 <code>onOrderOut</code>，改变属性的时候参数值为属性值字符串。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/Animation_key.png" alt="image"></p>
<p>初始化layer的时候，我们可以把当前viewController作为delegate，实现一下这个delegate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123;</div><div class="line">	CABasicAnimation *ani = [[CABasicAnimation alloc] init];</div><div class="line">    ani.duration = 1.0;//设置动画时间为1秒钟</div><div class="line">    return ani;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为CAAnimation相关的类已经实现了<code>&lt;CAAction&gt;</code>，所以可以直接返回CABasicAnimation对象。从下面的图中，我们可以看到同样的效果</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AnimationColor2.gif" alt="image"></p>
<p>当然我们还可以自定义对象，实现<code>&lt;CAAction&gt;</code>协议。</p>
<p>我们知道，每个UIView都有一个根Layer，UIView是根Layer的delegete。我们改变UIView的属性没有产生动画的原因就是这个方法默认返回NSNull对象。我们可以通过代码验证下：</p>
<p>将自定义view添加到UIViewController的view上，点击按钮改变背景色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MyCustomView *view = [[MyCustomView alloc] initWithFrame:CGRectMake(100, 300, 100, 100)];</div><div class="line">view.backgroundColor = [UIColor redColor];</div><div class="line">[self.view addSubview:view];</div><div class="line">self.customView = view;</div><div class="line"></div><div class="line">- (IBAction)click1:(UIButton *)sender &#123;</div><div class="line">   self.customView.backgroundColor = sender.selected ? [UIColor 			redColor] : [UIColor blueColor];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>自定义UIView,重写这个delegate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface MyCustomView : UIView</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyCustomView</div><div class="line"></div><div class="line">- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123;</div><div class="line">    id value = [super actionForLayer:layer forKey:event];</div><div class="line">    NSLog(@&quot;value:%d&quot;,[value isKindOfClass:[NSNull class]]);</div><div class="line">    return value;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/Animation_value.png" alt="image"></p>
<p>从log中可以看到返回的对象就是NSNull类型的对象，即UIView默认关闭了根layer的隐式动画。</p>
<p>那么回到我们最开始我们讨论的这个问题，既然在UIView Block中改变view的属性产生了动画，那就这个代理方法就一定返回了一个实现<code>&lt;CAAction&gt;</code>的对象。我们通过代码验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;%@&quot;,[view.layer.delegate actionForLayer:view.layer </div><div class="line">forKey:@&quot;position&quot;]);</div><div class="line"></div><div class="line"> [UIView animateWithDuration:1 animations:^&#123;</div><div class="line">        view.center = CGPointMake(200, 200);</div><div class="line">        NSLog(@&quot;%@&quot;,[view.layer.delegate actionForLayer:view.layer forKey:@&quot;position&quot;]);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/Animation_resultpng.png" alt="image"><br>通过输出可以看到，在block外面，这个方法将返回一个NSNull，在block里面返回了一个叫做UIViewAdditiveAnimationAction类的对象，通过这个私有类的类名就可以猜到，这是一个实现了<code>&lt;CAAction&gt;</code>的对象，即会产生动画。</p>
<p>总结一下：<br>每个UIView对它关联的图层都扮演了一个委托，并且提供了actionForLayer：forKey：的实现方法。当不在一个动画块的中改变相应的属性值，UIView对所有图层行为返回NULL，这时候不会有动画效果产生；反之，它就返回一个CAAction协议对应的对象，然后进行动画处理。</p>
<h3 id="系统是如何知道的"><a href="#系统是如何知道的" class="headerlink" title="系统是如何知道的"></a>系统是如何知道的</h3><p>但是系统是怎么知道我们把改变view属性的这行代码写在了Block里，然后进行动画的呢？既我们开篇讲到的第一个问题。</p>
<p>Block动画写法是在 iOS 4.0 提出来的，在 iOS 4.0之前，我们写动画的方式是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIView beginAnimations:@&quot;...&quot; context:nil];</div><div class="line">...</div><div class="line">...</div><div class="line">[UIView commitAnimations];</div></pre></td></tr></table></figure>
<p>这个context是一个全局的参数，当我们在context这个环境下改变view属性时会被context所记录下来。在 执行完<code>commitAnimations</code> 后，系统检测context内的动画内容，然后渲染绘制进行动画。Block写法其实就是对这种复杂写法的一种封装，其本质也是有全局的系统变量进行监控，只是Block更优雅，更方便。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/05/关于AFURLSessionManager的几点疑问/" itemprop="url">
                  关于AFURLSessionManager的几点疑问
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-12-05T19:16:30+08:00" content="2017-12-05">
              2017-12-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/12/05/关于AFURLSessionManager的几点疑问/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/05/关于AFURLSessionManager的几点疑问/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/12/05/关于AFURLSessionManager的几点疑问/" class="leancloud_visitors" data-flag-title="关于AFURLSessionManager的几点疑问">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这两天花了点时间看了下<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>的源码，特别是对于 <code>AFURLSessionManager</code> 这个核心类研究的比较多，其中有几个疑问，所以写篇文章来记录下</p>
<h3 id="关于AFURLSessionManager的内存泄露"><a href="#关于AFURLSessionManager的内存泄露" class="headerlink" title="关于AFURLSessionManager的内存泄露"></a>关于AFURLSessionManager的内存泄露</h3><p>这个问题在<a href="https://github.com/AFNetworking/AFNetworking/issues" target="_blank" rel="external">issues</a>上被多次提到，就是说仅仅是写个简单的请求，也会出现内存泄露的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];</div><div class="line">[manager POST:urlStringparameters:paraDic progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">        </div><div class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line">        </div><div class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>当我们在 UIViewController 写上这段代码，因为 AFHTTPSessionManager 不是全局的类，不是单利类，理论上来说，当退出当前 UIViewController 时，AFHTTPSessionManager 类的 dealloc 方法应该执行，然后事实上却没有。</p>
<p>使用Instruments分析为：<br><img src="http://ocauxqtbu.bkt.clouddn.com/AFURLSessionManager01.png" alt="image"></p>
<p>意思就是 AFURLSessionManager 持有了 NSURLSession 对象，并且 NSURLSession 的delegate 对象 为AFURLSessionManager，造成了循环引用。其实就是这行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration </div><div class="line">delegate:self delegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>为什么会出现这个问题呢？我们来看下苹果开发文档对于这个方法的描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The session object keeps a strong reference to the delegate until your app</div><div class="line"> exits or explicitly invalidates the session. If you do not invalidate the </div><div class="line"> session by calling the invalidateAndCancel or finishTasksAndInvalidate </div><div class="line"> method, your app leaks memory until it exits.</div></pre></td></tr></table></figure>
<p>果然如此，NSURLSession 对象会强引用传入的 delegate 对象直到APP退出或者手动调用方法使 session 失效，否则会出现内存泄露的问题。</p>
<p>其实解决这个内存泄露的方法也很简单，官方文档也说了，手动使其失效。我们在 block 回调里调用一下 <code>invalidateAndCancel</code> 就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[manager POST:urlString parameters:dic progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line"></div><div class="line">        </div><div class="line">        &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line"></div><div class="line">            [manager.session invalidateAndCancel];</div><div class="line">        &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">            [manager.session invalidateAndCancel];</div><div class="line">        &#125;];</div></pre></td></tr></table></figure>
<p>但是 AFNetworking 的作者为什么没有这么做呢，而是任其内存泄露？我猜测可能是当一个界面存在多个网络请求时，我们用 manager 去请求，假如在一个请求回调里调用 <code>[manager.session invalidateAndCancel]</code> 方法，那么就使其他的请求终止了，故而发生错误。并且我们在页面下拉刷新时，由于 manager.session 已失效，也会出现错误。</p>
<h3 id="为什么在block回调里可以写-self-访问属性"><a href="#为什么在block回调里可以写-self-访问属性" class="headerlink" title="为什么在block回调里可以写 self. 访问属性"></a>为什么在block回调里可以写 <code>self.</code> 访问属性</h3><p>比如这样写当前 UIViewController 仍能释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong)AFHTTPSessionManager *manager;</div><div class="line"></div><div class="line">self.manager = [[AFHTTPSessionManager alloc]init];</div><div class="line">[manager POST:urlString parameters:dic progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line"></div><div class="line">        self.XX = XX</div><div class="line">        </div><div class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>这里Controller对象是强引用了manager，block强引用了Controller，那么manager强引用了block了吗？肯定是没有的，我们来看下</p>
<p>AFHTTPSessionManager 有个字典属性：mutableTaskDelegatesKeyedByTaskIdentifier：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;</div></pre></td></tr></table></figure>
<p>字典里面放的是，key是NSURLSessionTask的唯一标识，value是AFURLSessionManagerTaskDelegate对象。</p>
<p>AFURLSessionManagerTaskDelegate这个类强引用了 AFURLSessionManager 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) AFURLSessionManager *manager;</div></pre></td></tr></table></figure>
<p>1.UIViewController对象      持有    AFHTTPSessionManager对象</p>
<p>2.AFHTTPSessionManager对象  持有    字典</p>
<p>3.字典                          持有    AF…TaskDelegate对象</p>
<p>4.AF…TaskDelegate对象     持有    AFHTTPSessionManager对象(weak) </p>
<p>5.AF…TaskDelegate对象     持有    completionHandler(回调的block)</p>
<p>6.completionHandler        持有    UIViewController对象</p>
<p>看着很乱，还是看图吧</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AFURLSessionManager03.png" alt="image"></p>
<p>那么AFNetworking是怎么处理的呢，怎么打破这种循环引用呢。</p>
<p>看下这个代理方法，这个方法是请求完成后调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error &#123;</div><div class="line"></div><div class="line"> [self removeDelegateForTask:task];</div><div class="line"> </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line">    [self.lock lock];</div><div class="line">    [delegate cleanUpProgressForTask:task];</div><div class="line">    [self removeNotificationObserverForTask:task];</div><div class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个回调方法里，把 AFURLSessionManagerTaskDelegate 对象从字典中移除了，就是说字典不再持有 AFURLSessionManagerTaskDelegate 对象，所以就不存在强引用了问题了。</p>
<h3 id="关于文件下载的操作"><a href="#关于文件下载的操作" class="headerlink" title="关于文件下载的操作"></a>关于文件下载的操作</h3><p>我们来看下 <code>NSURLSessionDownloadDelegate</code> 的这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        //调用自定义的block拿到文件存储的地址</div><div class="line">        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (fileURL) &#123;</div><div class="line">            delegate.downloadFileURL = fileURL;</div><div class="line">            NSError *error = nil;</div><div class="line">            //location是临时路径，我们把数据从临时的下载路径移动至我们需要的路径</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</div><div class="line">             //如果出错</div><div class="line">            if (error) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     //转发代理</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法我下载文件完成的时候调用。如果设置了 <code>downloadTaskDidFinishDownloadingBlock</code>，就去操作数据，把数据从临时的下载路径移动至我们需要的路径，然后 return，意思就是直接返回，不再执行。</p>
<p>如果没有设置block，就把这个代理转发到 AFURLSessionManagerTaskDelegate 自定义的代理里面。在自定义代理里做了同样的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    NSError *fileManagerError = nil;</div><div class="line">    self.downloadFileURL = nil;</div><div class="line"></div><div class="line">    //AF代理的自定义Block</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        //得到自定义下载路径</div><div class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (self.downloadFileURL) &#123;</div><div class="line">            //把下载路径移动到我们自定义的下载路径</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            //错误发通知</div><div class="line">            if (fileManagerError) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即：如果设置了 <code>downloadTaskDidFinishDownloadingBlock</code>，就去操作数据，把数据从临时的下载路径移动至我们需要的路径。这一步骤跟<code>NSURLSessionDownloadDelegate</code> 里的方法完全一样。并且，如果设置了block，操作文件后直接return了，不会再转发代理了。如果没设置block，转发代理后，在自己的代理方法里又判断了是否设置了block。</p>
<p>这个转发代理的步骤看起来多余了，AF的作者为什么这样做，让我不得解，难道还有其他的用处？</p>
<h3 id="其他的一些疑问"><a href="#其他的一些疑问" class="headerlink" title="其他的一些疑问"></a>其他的一些疑问</h3><p>1.当 AFURLSessionManagerTaskDelegate 这个类把 AFURLSessionManager 对象作为属性的时候用的是 weak</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, weak) AFURLSessionManager *manager;</div></pre></td></tr></table></figure>
<p>在自定义的代理方法里，因为这个属性是weak，所以进行了下面这一步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">    //强引用self.manager，防止被提前释放；因为self.manager声明为weak</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line">    .......</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>关于这个 weak 属性，我看了下，即使换成 strong 也不会出现内存泄露的问题，因为请求完成后 AFURLSessionManager 把 AFURLSessionManagerTaskDelegate 对象从字典中移除了。并且在上面的这个方法里，也不用多去操作一步。有点不明白，为什么用weak。</p>
<p>2.AFURLSessionManagerTaskDelegate 这个类在声明的时候同样遵循了 <code>NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate协议</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, </div><div class="line">NSURLSessionDataDelegate, </div><div class="line">NSURLSessionDownloadDelegate&gt;</div></pre></td></tr></table></figure>
<p>这里不遵循协议一样是可以的。可能是作者为了使这个类更规范一些，更像官方文档那样，所以这样写</p>
<p>3.在创建 NSURLSession 对象时，指定了回调代理的queque</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.operationQueue.maxConcurrentOperationCount = 1;</div><div class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration </div><div class="line">delegate:self delegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>这里我注意到了，设置了queue的最大operation并发个数为1，实现似于串行队列的效果。难道是作者为了节省内存资源这样做的，因为即使设置了并发个数为1，NSOperation也是可以同时执行多个任务的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/一次由performSelector引发的BUG/" itemprop="url">
                  一次由performSelector引发的BUG
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-12T12:15:01+08:00" content="2017-11-12">
              2017-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/12/一次由performSelector引发的BUG/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/12/一次由performSelector引发的BUG/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/11/12/一次由performSelector引发的BUG/" class="leancloud_visitors" data-flag-title="一次由performSelector引发的BUG">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们的APP在打包后测试过程过发现，所有的按钮点击效果不灵敏了，就是有时候按钮点击一次后再点就无效了，不会响应用户的操作。这个bug我觉得非常不可思议，并且我在模拟器上，即开发环境下没有任何问题。这篇文章就这个bug，来记录一下解决问题的过程。</p>
<h3 id="找到解决bug的原因"><a href="#找到解决bug的原因" class="headerlink" title="找到解决bug的原因"></a>找到解决bug的原因</h3><p>刚才说了，是所有的按钮，并且是在 Release 模式下会出现这个问题。由于是所有的按钮，所以想到了是全局的设置，比如我们可以一行代码全局设置APP内的导航栏效果等。我在我们APP工程里找了下，只有一个文件，就是 UIButton 的分类，这个分类的作用是防止按钮重复点击，比如控制APP内所有的按钮0.5秒内只能点击一次，可是这也不会出现导致点击一次后就无法点击的问题啊。我带着疑问去看这个分类的源码，并且我单独把这个分类拷贝出来，开一个Demo工程,然后分别在 Debug，Release模式下进行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        SEL selA = @selector(sendAction:to:forEvent:);</div><div class="line">        SEL selB = @selector(zj_sendAction:to:forEvent:);</div><div class="line">        Method methodA =   class_getInstanceMethod(self,selA);</div><div class="line">        Method methodB = class_getInstanceMethod(self, selB);</div><div class="line">        BOOL isAdd = class_addMethod(self, selA, method_getImplementation(methodB), method_getTypeEncoding(methodB));</div><div class="line">        if (isAdd) &#123;</div><div class="line">            class_replaceMethod(self, selB, method_getImplementation(methodA), method_getTypeEncoding(methodA));</div><div class="line">        &#125;else&#123;</div><div class="line">            method_exchangeImplementations(methodA, methodB);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)zj_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class="line">    </div><div class="line">    if (self.zj_ignoreEvent)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (self.zj_timeInterval &gt; 0) &#123;</div><div class="line">        </div><div class="line">        self.zj_ignoreEvent = YES;</div><div class="line">        </div><div class="line">        </div><div class="line">        [self performSelector:@selector(setZj_ignoreEvent:) withObject:@(NO) afterDelay:self.zj_timeInterval];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    [self zj_sendAction:action to:target forEvent:event];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/buttonTest.jpg" alt=""></p>
<p>我们在 load 方法里替换系统的 <code>sendAction:to:forEvent:</code>方法，改为自己定义的 <code>zj_sendAction:to:forEvent:</code> 方法。在自己的方法里去用点击的间隔时间来控制，这个点击是否有效。我在 Debug 模式下试了，没问题，可以在 Release 模式确实会出现点击一次后就无法点击的诡异问题。我们注意看这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (self.zj_ignoreEvent)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码是直接不响应用户的点击操作，直接返回。只有下一次点击时间的间隔，大于我们设置的 <code>zj_timeInterval</code>，方法才会继续执行。难道说，这个属性 <code>zj_zj_ignoreEvent</code> 被永久的设置为了YES，永远无法继续执行？我们通过打断点调试发现，事实确实是我们设想的那样，点击一次之后，这个属性一直都为YES。为什么呢？当时间过了间隔时间后，我们不是 <code>performSelector</code> 使这个属性设置为 NO 了吗</p>
<h3 id="诡异的-performSelector-方法"><a href="#诡异的-performSelector-方法" class="headerlink" title="诡异的 performSelector 方法"></a>诡异的 performSelector 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(setZj_ignoreEvent:) withObject:@(NO) afterDelay:self.zj_timeInterval];</div></pre></td></tr></table></figure>
<p>为此，专门测试了一下 <code>performSelector: withObject:</code>方法<br>比如我们在项目中写下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(test:) withObject:@(NO) afterDelay:1];</div><div class="line"></div><div class="line">-(void)test:(BOOL)boolTest &#123;</div><div class="line">    NSLog(@&quot;%d&quot;,boolTest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候，当 Debug 模式下，boolTest的值确实为0，但是 Release 模式下却为2，不为0，无论加不加延迟加载结果都是一样的。难道 <code>performSelector</code> 在开发环境下，和生产环境下对数据的处理完全不一样。所以，就是这个原因导致项目中<code>zj_zj_ignoreEvent</code> 被永久的设置为了YES，按钮无法正常响应用户点击操作。</p>
<p>我们去翻了下Runtime的源码，里面对这个方法的内部实现也没有过多的解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)performSelector:(SEL)sel &#123;</div><div class="line">    if (!sel) [self doesNotRecognizeSelector:sel];</div><div class="line">    return ((id(*)(id, SEL))objc_msgSend)(self, sel);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仅仅是调用 <code>objc_msgSend</code>，而 <code>objc_msgSend</code>内部是用汇编语言写的，查阅起来比较困难。<br>我现在的解决办法是，不是用这个 <code>performSelector</code> 方法，而是使用 GCD 延迟加载的方式来实现功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.zj_timeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">            self.zj_ignoreEvent = NO;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>将原来项目中的延迟调用方法，换成这种就OK了。</p>
<p>需要额外提一下，我在网上搜防止button重复点击的开源代码，大部分都是使用<code>performSelector</code> 来延迟设置属性，以此告诫大家，不能一味的拷贝别人的代码，我在这里就吃了一个亏，虽然知道了实现原理，却在实现方法上出了错，还是要多看看代码，检查一下代码的正确性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/04/APP的启动简单优化/" itemprop="url">
                  APP的启动简单优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-04T18:33:28+08:00" content="2017-11-04">
              2017-11-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/04/APP的启动简单优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/04/APP的启动简单优化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/11/04/APP的启动简单优化/" class="leancloud_visitors" data-flag-title="APP的启动简单优化">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>APP的启动是指从用户点击 APP 那一刻开始到用户看到第一个界面的整个过程</p>
<h3 id="一、APP的启动过程"><a href="#一、APP的启动过程" class="headerlink" title="一、APP的启动过程"></a>一、APP的启动过程</h3><h4 id="1-启动过程"><a href="#1-启动过程" class="headerlink" title="1.启动过程"></a>1.启动过程</h4><p>简单的来说就是 App 进行编译、汇编、链接、代码签名以及启动执行等操作</p>
<h5 id="1-1-解析Info-plist"><a href="#1-1-解析Info-plist" class="headerlink" title="1.1 解析Info.plist"></a>1.1 解析Info.plist</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.加载相关信息，例如如闪屏</div><div class="line"></div><div class="line">2.沙箱建立、权限检查</div></pre></td></tr></table></figure>
<h5 id="1-2-Mach-O加载"><a href="#1-2-Mach-O加载" class="headerlink" title="1.2 Mach-O加载"></a>1.2 Mach-O加载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1.如果是胖二进制文件，寻找合适当前CPU类别的部分</div><div class="line"></div><div class="line"> (由于需要支持不同CPU架构的iOS设备，所以我们编译打包出来的执行文件是一个Universal Binary格式文件，通用二进制文件，也称胖二进制文件)</div><div class="line"> </div><div class="line">2.加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）</div><div class="line"></div><div class="line">3.定位内部、外部指针引用，例如字符串、函数等</div><div class="line"></div><div class="line">4.执行声明为__attribute__((constructor))的C函数</div><div class="line"></div><div class="line">5.加载类扩展（Category）中的方法</div><div class="line"></div><div class="line">6.C++静态对象加载、调用ObjC的 +load 函数</div><div class="line"></div><div class="line">关于Mach-O文件的格式以及详细的加载过程，可看[这篇文章](http://www.jianshu.com/p/54d842db3f69)</div></pre></td></tr></table></figure>
<h5 id="1-3-程序执行"><a href="#1-3-程序执行" class="headerlink" title="1.3 程序执行"></a>1.3 程序执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1.main函数</div><div class="line"></div><div class="line">2.执行 UIApplicationMain 函数</div><div class="line"></div><div class="line">3.创建 UIApplication 对象</div><div class="line"></div><div class="line">4.创建UIApplicationDelegate对象</div><div class="line"></div><div class="line">5.读取配置文件info.plist，设置程序启动的一些属性</div><div class="line"></div><div class="line">6.创建应用程序的Main Runloop循环</div><div class="line"></div><div class="line">7.UIApplicationDelegate对象开始处理监听对象</div><div class="line"></div><div class="line">8.调用didFinishLaunchingWithOptions方法</div><div class="line"></div><div class="line">9.如果info.plist中配置了启动的storyBoard的文件名，加载storyboard文件，如果没有，创建UIWindow —&gt; rootViewController 显示</div></pre></td></tr></table></figure>
<h3 id="二、启动时间的计算"><a href="#二、启动时间的计算" class="headerlink" title="二、启动时间的计算"></a>二、启动时间的计算</h3><h4 id="2-1-main-函数之前"><a href="#2-1-main-函数之前" class="headerlink" title="2.1 main()函数之前"></a>2.1 main()函数之前</h4><p>苹果已经给出了方法来帮我们计算这部分的启动时间：<br>在Xcode的菜单中选择<code>Project</code> → <code>Scheme→Edit Scheme</code>，然后找到 <code>Run</code> →  <code>Environment Variables</code>，添加name为 <code>DYLD_PRINT_STATISTICS</code> 为1的环境变量，然后运行APP，会在控制台有一个输出。例如，我在之前的一个项目中加入以上设置后：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/blog_runTime.png" alt=""></p>
<p>1.main()函数之前总共使用了401.01ms</p>
<p>2.在401.01ms中，加载动态库用了112.08ms，指针重定位使用了161.83ms，ObjC类初始化使用了71.04ms，各种初始化使用了55.93ms。</p>
<p>3.在初始化耗费的55.93ms中，用时最多的三个初始化是libSystem.B.dylib、libMainThreadChecker.dylib以及XiaoBanBattery(自己的项目名称)。</p>
<h4 id="2-2-main-函数之后"><a href="#2-2-main-函数之后" class="headerlink" title="2.2 main()函数之后"></a>2.2 main()函数之后</h4><p>从main()函数开始至applicationWillFinishLaunching结束，再到完成数据的加载并展示相关信息给用户。</p>
<p>我们可以自己在这个过程中插入代码，从而获得这段时间。比如在didFinishLaunchingWithOptions获取一下时间，再在第一个主界面viewDidAppear获取一下时间，算出时间差。</p>
<h3 id="三、启动时间的优化"><a href="#三、启动时间的优化" class="headerlink" title="三、启动时间的优化"></a>三、启动时间的优化</h3><p>一个App完整的启动时间应该保证400ms之内,而若超过20s后还未完全启动App,那么App进程就会被系统杀死。那么如何来提升启动速度呢？</p>
<h4 id="1-移除不需要用到的动态库"><a href="#1-移除不需要用到的动态库" class="headerlink" title="1. 移除不需要用到的动态库"></a>1. 移除不需要用到的动态库</h4><p>每个App都进行动态库加载,其中系统级别的动态库占据了绝大数,而针对系统级别的动态库都是经过系统高度优化的,不用担心时间的花费.所以我们应该关注于自己集成到App的那些动态库,有些库集成进来了，但是没在代码中用到，一样会需要时间来加载它。所以移除移除不需要用到的动态库是很有必要的。</p>
<h4 id="2-移除不需要用到的类"><a href="#2-移除不需要用到的类" class="headerlink" title="2. 移除不需要用到的类"></a>2. 移除不需要用到的类</h4><p>日常代码的维护非常重要，如果一个业务去掉了，就应该在当时删掉相关的代码，否则的话无用的代码就会越来越多。日后，再去找这些无用的代码，应该没那么方便了。</p>
<h4 id="3-合并功能类似的类和分类"><a href="#3-合并功能类似的类和分类" class="headerlink" title="3. 合并功能类似的类和分类"></a>3. 合并功能类似的类和分类</h4><p>这样做主要是为了加快程序的整个动态链接, 在进行动态库的重定位和绑定过程中减少指针修正的使用,加快程序机器码的生成。所以要合并一些在工程、架构上没有太大意义的类和分类。</p>
<h4 id="4-使用initialize方法进行必要的初始化工作"><a href="#4-使用initialize方法进行必要的初始化工作" class="headerlink" title="4. 使用initialize方法进行必要的初始化工作"></a>4. 使用initialize方法进行必要的初始化工作</h4><p>如果不是非必须的，我们要用+initialize方法替换调用原先在OC的+load方法中执行初始代码工作,从而加快所有类文件的加载速度。</p>
<h4 id="5-压缩资源图片"><a href="#5-压缩资源图片" class="headerlink" title="5. 压缩资源图片"></a>5. 压缩资源图片</h4><p>启动的时候加载图片，图片小了，IO操作量就小了，启动当然就会快了，但是还是要以图片的质量，清晰度为前提下。</p>
<h4 id="6-优化rootViewController加载"><a href="#6-优化rootViewController加载" class="headerlink" title="6. 优化rootViewController加载"></a>6. 优化rootViewController加载</h4><p>在didFinishLaunchingWithOptions方法里，我们一般进行初始化第三方SDK、自己的一些工具类的初始化、然后再到第一个界面的渲染。其实这些东西也可以分开来做：</p>
<p>1.最先配置的事件，比如日志，统计等可以在没有设置rootViewController前进行初始化。</p>
<p>2.第三方SDK，比如推送，支付SDk，直播SDk的集成，可以在设置rootViewController后进行初始化，这样不会影响第一个视图的加载，毕竟人的视觉看到视图出现很快，就会觉得加载很快。</p>
<p>3.工具类的初始化配置。比如集成了IQKeyboardManager,需要启动的时候进行全局设置，这个操作可以放在第一个界面的viewDidAppear，这里完全不会影响到启动时间。</p>
<p>本文只是简单简述了APP的启动，比如点击APP图标后，动态库是如何链接到内存中的，代码的二进制文件是如何加载的等这些过程还需更深层次的探究。对于优化启动时间这个方面，我们只能做的就是写出更好的代码，优化项目。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ocauxqtbu.bkt.clouddn.com/27563317749u=2381918280,2871499884&fm=21&gp=0.jpg"
               alt="Zhou Jian" />
          <p class="site-author-name" itemprop="name">Zhou Jian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coderZhou10496" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"coderzhou"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Bw40KBIPanRkt0iqTr7NLT6I-gzGzoHsz", "MQjFPSYkEazqnUv2rS7TOsui");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
