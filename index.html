<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Jianless的博客">
<meta property="og:url" content="http://coderzhou.com/index.html">
<meta property="og:site_name" content="Jianless的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jianless的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coderzhou.com/"/>

  <title> Jianless的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Jianless的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">专注于iOS开发</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/13/最近工作杂想/" itemprop="url">
                  最近工作杂想
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2020-07-13T00:39:41+08:00" content="2020-07-13">
              2020-07-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/07/13/最近工作杂想/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/13/最近工作杂想/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2020/07/13/最近工作杂想/" class="leancloud_visitors" data-flag-title="最近工作杂想">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好久没写博客了，一个字：忙！</p>
<p>今年是直播电商爆发的一年，各个大平台淘宝、京东、快手、抖音都上线了自己的直播卖货模式，我们公司也在追赶大公司的脚步，想在微信直播里分一杯羹，有兴趣的可以微信小程序搜索：爱逛</p>
<h1 id="关于团队"><a href="#关于团队" class="headerlink" title="关于团队"></a>关于团队</h1><p>电商直播是公司重点发力的一个项目，所以今年上半年团队快速扩张，整个项目团队扩张了一倍多，iOS团队从只有我自己独立负责主播端项目，到现在的6个人共同协作，并且新的用户端APP也在开发过程中，也算经历了团队迅速壮大的一个过程。 </p>
<p>能面试进来的，都是很优秀的小伙伴，技术水平也都OK。说实话，我并不怎么太注重小伙伴的技术水平，而很关注他能否能快速融入团队，团队合作意识是否OK。</p>
<p>今年的业务节奏超前的快，每周都要发一个版本，碰上大点的bug或明星直播，一周都可能发布两个版本，工作强度确实很高，甚至出现了后端一位新入职的小伙伴，干了两周后接了其他offer，离我们而去。其实也能理解，每个人有每个人的选择，没有谁对谁错，在快节奏，强压力中，更能锻炼一个人的成长。</p>
<h1 id="关于管理"><a href="#关于管理" class="headerlink" title="关于管理"></a>关于管理</h1><p>由于我是iOS团队的元老，所以入职的iOS新同学基本都是我带他们，并且承担了iOS项目负责人这一职。我经常在想，怎么让新同学快速融入团队，适应项目开发节奏。我做的基本围绕三点来：</p>
<ul>
<li><p>带他熟悉团队里的其他同事，了解每个人的做事风格</p>
</li>
<li><p>带他熟悉直播业务，看文档，看代码</p>
</li>
<li><p>在试用期内让他独立完成稍大的项目，培养他独立解决业务问题的能力。</p>
</li>
</ul>
<p>有了这三个基本方向之后，然后心里拟定一些action，平时对着做就行了。</p>
<h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>团队6个人，代码风格各异。我觉得其实没啥，每个人都有自己的书写习惯，一些普通的基本的规范一块遵守就行了，没有必要严格定死</p>
<h2 id="技术氛围"><a href="#技术氛围" class="headerlink" title="技术氛围"></a>技术氛围</h2><p>在我看来，团队的技术氛围不足，这应该是大部分技术团队都会遇到的事情，因为团队刚组建起来，业务也不是很稳定，大家都忙于业务的代码实现。不过现在陆续有了业务分享和技术分享，codereview等，平常也可以讨论一些技术相关的问题，比如问一个动画效果怎么实现，一个复杂的界面如何布局等等，希望能增加一些技术氛围吧</p>
<h2 id="分配任务"><a href="#分配任务" class="headerlink" title="分配任务"></a>分配任务</h2><p>产品同学给一个需求后，分配给谁来做呢？ 一是看需求复杂度， 二是看团队内部对这块业务的熟悉程度， 三是每个人的喜好。</p>
<p>这里说一下第三点，因为基本进来的都是新同学，他们本身对项目的熟悉度都不够，无论做什么项目需求对他来说，都是陌生的，如果分正好配给他感兴趣的东西，那么他做起来主动性会更强一些。</p>
<h1 id="关于个人成长"><a href="#关于个人成长" class="headerlink" title="关于个人成长"></a>关于个人成长</h1><h2 id="项目组件化"><a href="#项目组件化" class="headerlink" title="项目组件化"></a>项目组件化</h2><p>自己通过组件化的方式独立搭建了用户端APP，是通过子工程的方式集成，而没有通过业务普遍的cocoapods方式集成，其本质都是一样，最终都是编译成静态.a库，主工程依赖各个模块的静态库。</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/gongzuozaxiang/zujianhua.jpg" alt="image"></p>
<h2 id="算法和网络知识"><a href="#算法和网络知识" class="headerlink" title="算法和网络知识"></a>算法和网络知识</h2><p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/gongzuozaxiang/suanfa.png" alt="image"></p>
<p>之前对算法一窍不通，差不多从去年年底开始刷算法，又赶上了LeetCode的每日一题，现在基本上每天一两道题，都是在凌晨刷的，从没碰到的题需要花更多的时间去理解，经常刷完都1点多了。<br>没有算法基础，刚开始刷的时候很痛苦，基本都是看着题解过来的。比如看了题解说用BFS解答，然而都不知道啥是BFS，然后去查BFS相关知识。<br>现在很多题只刷了一遍，再次碰到的话还是有点懵逼，看来要多刷几次，形成记忆。这个刷题的习惯要一直坚持下去。</p>
<p>计算机网络知识，虽然没有系统的学习过，但看别人的技术博客，基本是过了一遍。<br>比如为什么要三次握手，为什么要四次挥手，HTTPS连接，TCP可靠传输的原理等等</p>
<h2 id="主动性"><a href="#主动性" class="headerlink" title="主动性"></a>主动性</h2><p>我现在的团队，当一个任务分配给组员后，能做到主动和我同步进度，跟我沟通完成任务过程遇到问题的人，就那么一两个，大部分都是自己瞒着头苦干，我经常还要自己追着他们问进度。<br>我觉得在工作中主动性是非常重要的，主动发现项目协作及团队中存在的问题，主动和leader沟通自己的项目进度，主动和别人沟通自己的所思所想等等。<br>我转岗来爱逛之前，在有赞零售团队的时候，有一次leader跟我说，天天看你工作这么晚，都不知道你在忙些什么，这句话我记忆尤深，这是个反面例子，所以一定要经常和<br>自己的上级主动沟通，不要等到leader和你沟通。</p>
<h1 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h1><p>最近喜欢上了打羽毛球，对羽毛球特别着迷，一有闲暇时间就去想打羽毛球，有时候还会去抖音搜一下羽毛球教学视频。</p>
<p>因为公司有两个羽毛球场地，下午6点吃饭的时候经常去打一会。但是整个公司喜欢打羽毛球的人很多，两个场地明显不够用啊，经常6-7点一个小时只有二十分钟是摸着球拍的。上次想预约一下外面的场地，比如黄龙体育馆，西湖文体中心，无奈都是爆满，预约不到！</p>
<p>水文一篇，over！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/06/05/fishhook/" itemprop="url">
                  fishhook探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-06-05T20:57:26+08:00" content="2019-06-05">
              2019-06-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/06/05/fishhook/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/06/05/fishhook/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/06/05/fishhook/" class="leancloud_visitors" data-flag-title="fishhook探究">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Objective-C 的方法之所以可以 hook 是因为它的运行时特性，Objective-C 的方法调用在底层都是 msg_send（id,SEL）的形式，这为我们提供了交换方法实现（IMP）的机会，但 C 函数在编译链接时就确定了函数指针的地址偏移量（Offset），这个偏移量在编译好的可执行文件中是固定的。既然 C 函数的指针地址是相对固定且不可修改的，那么 fishhook 又是怎么实现 对 C 函数的 hook 呢？其实自定义的 C 函数 fishhook 也 Hook 不了，它只能HOOK Mach-O 外部（共享缓存库中）的函数,而苹果的共享缓存库不会被编译进我们的 MachO 文件，而是在动态链接时才去重新绑定，所以给了我们 hook 系统 C 函数的机会。另外，理解fishhook需要大量的mach-o、编译链接知识、</p>
<h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>随机内存布局（ASLR）是操作系统为防止缓冲区溢出攻击而存在的内存保护机制。该机制通过在程序载入内存时，将地址进行随机偏移来实现,增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p>
<p>所以，Mach-O 文件每次加载进内存的时候地址都是不一样的，这个偏移量是每次程序启动时给出的随机值，可以通过 <code>_dyld_get_image_vmaddr_slide</code> 函数获得。</p>
<h3 id="PIC-Position-Indepent-Code"><a href="#PIC-Position-Indepent-Code" class="headerlink" title="PIC(Position Indepent Code)"></a>PIC(Position Indepent Code)</h3><p>动态链接将相关符号的绑定工作推迟到程序被加载到内存中执行的时候，这不仅减少了程序的编译时间，而且也使得库文件能够真正的被不同的程序所共享。此处的“共享”有两点含义：一是指库文件在操作系统中只存在一份，而不是像静态链接那样将库文件给每个程序都拷贝一份；二是指在程序运行的过程中，共享库的 text 段的内容可以被不同的进程所共享。</p>
<p>比如进程A加载了一个动态库，那么进程B也要加载这个动态库，这样麻烦就来了，动态库中符号的相关地址是基于进程A的，在进程B中是无法工作的，所以这个时候就用到了PIC技术。</p>
<p>PIC技术让动态库可以被加载到任何地址并正确运行。<br>使用PIC的Mach-O文件，在引用符号（比如 printf）的时候，并不是直接去找到符号的地址（编译期并不知道运行时printf的函数地址),而是通过在 <code>__DATA Segment</code> 上创建一个指针，等到启动的时候，dyld 动态的去做绑定（bind），这样 <code>__DATA Segment</code> 上的指针就指向了 printf 的实现。即：</p>
<p>当你的应用程序想要调用 Mach-O 文件外部的函数的时候，或者说如果 Mach-O 内部需要调用系统的库函数时，Mach-O 文件会：</p>
<ol>
<li>先在 Mach-O 文件的 _DATA 段中建立一个指针（8字节的数据，放的全是0），这个指针变量指向外部函数。</li>
<li>DYLD 会动态的进行绑定！将 Mach-O 中的 _DATA 段中的指针，指向外部函数</li>
</ol>
<h3 id="dyld-加载回调"><a href="#dyld-加载回调" class="headerlink" title="dyld 加载回调"></a>dyld 加载回调</h3><p>利用dyld相关接口，我们可以注册image装载的监听方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern void _dyld_register_func_for_add_image(void (func)(const struct mach_header mh, intptr_t vmaddr_slide));</div></pre></td></tr></table></figure>
<p>调用<code>_dyld_register_func_for_add_image</code>注册监听方法后，当前已经装载的image(动态库等)会立刻触发回调，<br>之后的image会在装载的时候触发回调。</p>
<p>在<code>__DATA</code>段中，有两个Sections和动态符号绑定有关：</p>
<p><code>__nl_symbol_ptr</code> 存储了non-lazily绑定的符号，这些符号在mach-o加载的时候绑定。<br><code>__la_symbol_ptr</code> 存储了lazy绑定的符号（方法），这些方法在第一调用的时候，</p>
<h3 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h3><p>程序启动的时候 Mach-O 文件会被 DYLD （动态加载器）加载进内存。加载完 Mach-O 后，DYLD接着会去加载 Mach-O 所依赖的动态库。</p>
<p>Mach-O文件分为三部分：</p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct mach_header_64 &#123;</div><div class="line">    uint32_t    magic;      /* mach magic number identifier */</div><div class="line">    cpu_type_t  cputype;    /* cpu specifier */</div><div class="line">    cpu_subtype_t   cpusubtype; /* machine specifier */</div><div class="line">    uint32_t    filetype;   /* 文件类型 */</div><div class="line">    uint32_t    ncmds;      /* load commadns的个数 */</div><div class="line">    uint32_t    sizeofcmds; /* load commands的总大小 */</div><div class="line">    uint32_t    flags;      /* 动态连接器标志*/</div><div class="line">    uint32_t    reserved;   /* 保留*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Load-commands"><a href="#Load-commands" class="headerlink" title="Load commands"></a>Load commands</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct load_command &#123;</div><div class="line">    uint32_t cmd;       /*  load command的类型 */</div><div class="line">    uint32_t cmdsize;   /*  command 的长度 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="LC-SEGMENT"><a href="#LC-SEGMENT" class="headerlink" title="LC_SEGMENT"></a>LC_SEGMENT</h4><p>LC_SEGMENT_64 命令表示将相应的 segment 映射到虚拟地址空间中。一个程序一般会分为多个段，不同类型的数据放入不同的段中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  struct segment_command_64 &#123; /* for 64-bit architectures */</div><div class="line">    uint32_t    cmd;        /* LC_SEGMENT_64 */</div><div class="line">    uint32_t    cmdsize;    /* includes sizeof section_64 structs */</div><div class="line">    char        segname[16];    /* 表示是段的名称。常见的有：__PAGEZERO、__LINKEDIT、__TEXT、__DATA */</div><div class="line">    uint64_t    vmaddr;     /* 当前segment加载的虚拟内存起始地址 */</div><div class="line">    uint64_t    vmsize;     /* 段所占的虚拟内存的大小  */</div><div class="line">    uint64_t    fileoff;    /* segment在文件中的偏移 */</div><div class="line">    uint64_t    filesize;   /* segment在文件中的长度 */</div><div class="line">    vm_prot_t   maxprot;    /* 最大的保护级别 */</div><div class="line">    vm_prot_t   initprot;   /* 初始化的保护级别 */</div><div class="line">    uint32_t    nsects;     /* 包含sections的个数  */</div><div class="line">    uint32_t    flags;      /* 标志位 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="PAGEZERO"><a href="#PAGEZERO" class="headerlink" title="__PAGEZERO"></a>__PAGEZERO</h5><p>__PAGEZERO 是在可执行文件有的，动态库里没有。这个段开始地址为0（NULL指针指向的位置），是一个不可读、不可写、不可执行的空间，能够在空指针访问时抛出异常</p>
<h5 id="TEXT"><a href="#TEXT" class="headerlink" title="__TEXT"></a>__TEXT</h5><p>__TEXT 是代码段，里面主要是存放代码的，该段是可读可执行，但是不可写。</p>
<h5 id="DATA"><a href="#DATA" class="headerlink" title="__DATA"></a>__DATA</h5><p>__DATA 是数据段，里面主要是存放数据，该段是可读可写，但不可执行</p>
<h5 id="LINKEDIT"><a href="#LINKEDIT" class="headerlink" title="__LINKEDIT"></a>__LINKEDIT</h5><p>__LINKEDIT 段用于存放签名信息，该段是只可读，不可写不可执行。</p>
<h4 id="LC-SYMTAB"><a href="#LC-SYMTAB" class="headerlink" title="LC_SYMTAB"></a>LC_SYMTAB</h4><p>LC_SYMTAB 是符号表和字符串表的偏移信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct symtab_command &#123;</div><div class="line">	uint32_t	cmd;		/* LC_SYMTAB */</div><div class="line">	uint32_t	cmdsize;	/* sizeof(struct symtab_command) */</div><div class="line">	uint32_t	symoff;		/* 表示符号表的偏移 */</div><div class="line">	uint32_t	nsyms;		/* 符号表条目的个数 */</div><div class="line">	uint32_t	stroff;		/* 字符串表在文件中的偏移 */</div><div class="line">	uint32_t	strsize;	/* 字符串表的大小 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_mach-o%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%BB%93%E6%9E%84.jpg" alt="image"></p>
<h3 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h3><p>Symbol Table: 即符号表。每个目标文件都有自己的符号表，记录了符号的映射。符号表的结构是一个连续的列表，其中的每一项都是一个 struct nlist。<br>符号表里的内容就是描述某个符号的名称、类型、地址、索引、连接方式等信息。通过符号表可以找到特定符号在指针表中的索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct nlist_64 &#123;</div><div class="line">    union &#123;</div><div class="line">        uint32_t  n_strx; /* index into the string table */</div><div class="line">    &#125; n_un;</div><div class="line">    uint8_t n_type;        /* type flag, see below */</div><div class="line">    uint8_t n_sect;        /* section number or NO_SECT */</div><div class="line">    uint16_t n_desc;       /* see &lt;mach-o/stab.h&gt; */</div><div class="line">    uint64_t n_value;      /* value of this symbol (or stab offset) */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中 n_strx 表示符号名在字符串表中的偏移量，用于表示函数名。</p>
<h3 id="String-Table"><a href="#String-Table" class="headerlink" title="String Table"></a>String Table</h3><p>在程序中，字符串的长度是不固定的，所以会将其放在 string table 中，然后存储它在 string table 中的偏移。如果其他部分想要引用某个字符串，那么他首先需要找到 string table 的起始地址，然后根据偏移量找到相应字符串的起始位置并向后读取字符，直到遇见 <code>\0</code>才会停止读取过程，最后返回读到的字符串。</p>
<p>这也是 <code>LC_SYMTAB</code>额外记录 string table 地址的原因，string table 通常用于是放置 Section 名、变量名、符号名的字符串表，字符串末尾自带的 \0 为分隔符（机器码00）。知道 strtab 的基地址（base），然后加上在 Symbol Table 中找到的该字符串的偏移量（offset）就可以找到这个字符串。</p>
<h3 id="fishhook解析"><a href="#fishhook解析" class="headerlink" title="fishhook解析"></a>fishhook解析</h3><p>对于程序引用的动态库中的函数，链接器会将它的地址放在 <code>__la_symbol_ptr</code>中，而对于动态库的全局数据，则是放在 <code>__nl_symbol_ptr</code>中，所以整个 fishhook 的核心工作就是替换 <code>__la_symbol_ptr</code>以及 <code>__nl_symbol_ptr</code>的内容。</p>
<p><code>fishhook.c</code> 简短的源码中，执行 rebind 逻辑的核心函数有两个：<code>rebind_symbols_for_image</code>和<code>perform_rebinding_with_section</code>；前者负责找到目标 section，后者在 section 里根据符号进行真正的 rebind</p>
<h4 id="rebind-symbols-for-image"><a href="#rebind-symbols-for-image" class="headerlink" title="rebind_symbols_for_image"></a>rebind_symbols_for_image</h4><p> <code>rebind_symbols_for_image</code>方法主要做了四件事：</p>
<ol>
<li>在 <code>load commands</code> 里找到 <code>linkedit_segment</code>、<code>symtab_cmd</code>、<code>dysymtab_cmd</code></li>
<li>通过 <code>linkedit_segment</code> 找到 <code>symtab、strtab</code></li>
<li>在 <code>load commands</code> 里找到 <code>__DATA,__la_symbol_ptr 和 __DATA,__nl_symbol_ptr</code></li>
<li>调用 <code>perform_rebinding_with_section</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// header的首地址+mach_header的内存大小</div><div class="line">    // 跳过 Mach-O 的 Header 结构，开始遍历 Load Commands,也就是直接到Load Commands的地址</div><div class="line">    uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t);</div><div class="line">    // 遍历Load Commondds 找到上面三个遍历</div><div class="line">    for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</div><div class="line">        cur_seg_cmd = (segment_command_t *)cur;</div><div class="line">        // 如果是LC_SEGMENT_64</div><div class="line">        if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</div><div class="line">            // 找到linkedit</div><div class="line">            if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) &#123;</div><div class="line">                linkedit_segment = cur_seg_cmd;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 如果是LC_SYMTAB,就找到了symtab_cmd</div><div class="line">        else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</div><div class="line">            symtab_cmd = (struct symtab_command*)cur_seg_cmd;</div><div class="line">        &#125;</div><div class="line">        // 如果是LC_DYSYMTAB,就找到了dysymtab_cmd</div><div class="line">        else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</div><div class="line">            dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先获得 <code>load commands</code> 的起始地址，可以配合 MachOView 查看更直观：</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_load_commands_1.jpg" alt="image"></p>
<p>首先我们在程序里打断点，可以直接看到起始地址为：4300685344</p>
<p>在控制台打印 <code>image list</code> 可以得到程序偏移地址为：0x0000000100574000</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_image_list.jpg" alt="image"></p>
<p>从 MachOView 中可以看到 <code>load commands</code> 相对于mach-o文件的偏移地址为：0x20</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_load_commands_2.jpg" alt="image"></p>
<p>0x0000000100574000 +  0x20 = 0x100574020</p>
<p>0x100574020 转换成16进制即为 4300685344。</p>
<p>所以fishhook的源码配合MachOView更容易理解。</p>
<p>从 <code>header-&gt;ncmds</code> 里获得 <code>load commands</code> 的数量，从 <code>cur_seg_cmd-&gt;cmdsize</code> 获得每一个segment的大小，逐次遍历，<br>直到找到 <code>linkedit_segment</code>、<code>symtab_cmd</code>、<code>dysymtab_cmd</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> MachO文件地址 = Linkedit虚拟地址 - 当前段在文件中的偏移量 + ASLR(slide)</div><div class="line"> **/</div><div class="line">uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</div><div class="line"></div><div class="line">// 获取symbol_table符号表的真实地址：符号表的地址 = 基址 + 符号表偏移量,实际上是一个nlist_t数组</div><div class="line">nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</div><div class="line"></div><div class="line">// 获取string_table字符串表的真实地址：字符串表的地址 = 基址 + 字符串表偏移量</div><div class="line">char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff);</div><div class="line"></div><div class="line">// 获取indirect_symtab间接符号表的真实地址：间接符号表地址 = 基址 + 动态符号表偏移量</div><div class="line">uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</div><div class="line"></div><div class="line">// 同样的，得到跳过mach_header的地址,得到Load Commonds的地址</div><div class="line">cur = (uintptr_t)header + sizeof(mach_header_t);</div><div class="line">// 遍历Load Commonds，找到对应符号进行重新绑定</div><div class="line">for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</div><div class="line">    cur_seg_cmd = (segment_command_t *)cur;</div><div class="line">    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</div><div class="line">        // 如果不是__DATA段，也不是__DATA_CONST段，直接跳过</div><div class="line">        if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp;</div><div class="line">            strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        // 遍历所有的segment</div><div class="line">        for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</div><div class="line">            section_t *sect =</div><div class="line">            (section_t *)(cur + sizeof(segment_command_t)) + j;</div><div class="line">            // 找懒加载表S_LAZY_SYMBOL_POINTERS</div><div class="line">            if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</div><div class="line">                // 重绑定的函数</div><div class="line">                perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</div><div class="line">            &#125;</div><div class="line">            // 找非懒加载表S_NON_LAZY_SYMBOL_POINTERS</div><div class="line">            if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</div><div class="line">                // 重绑定的函数</div><div class="line">                perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 <code>uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff</code> 这一行代码配合MachOView也挺容易理解的。</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_VM_Address_1.jpg" alt="image"></p>
<p>从程序断点中可以看到 <code>`linkedit_segment-&gt;vmaddr</code> 的值为 4295016448。这正好对应了MachOView的值</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_VM_Address_2.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</div></pre></td></tr></table></figure>
<p>slide的值，即为ASLR的值，可以通过 <code>_dyld_get_image_vmaddr_slide</code> 函数获得，可以通过程序断点得出为5718016。</p>
<p>slide = 5718016,</p>
<p>vmaddr = 4295016448</p>
<p>fileoff = 49152</p>
<p>所以：linkedit_base = 5718016 + 4295016448 - 49152 = 4300685312</p>
<p>4300685312 转换成 16进制为 0x0000000100574000，即mach-0的起始内存地址。</p>
<p>接下来，会在 <code>__DATA</code> 段中寻找类型为 <code>S_LAZY_SYMBOL_POINTERS</code> 以及 <code>S_NON_LAZY_SYMBOL_POINTERS</code> 的节，二者分别包含我们要替换的 <code>__la_symbol_ptr</code> 以及 <code>__nl_symbol_ptr</code>，然后调用 <code>perform_rebinding_with_section</code> 函数。</p>
<h4 id="perform-rebinding-with-section"><a href="#perform-rebinding-with-section" class="headerlink" title="perform_rebinding_with_section"></a>perform_rebinding_with_section</h4><p>找到<code>S_LAZY_SYMBOL_POINTERS</code>或<code>S_LAZY_SYMBOL_POINTERS</code>后会进入下面的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// sect为Section，symtab为符号表，strtab字符串表，indirect_symtab间接符号表</div><div class="line">static void perform_rebinding_with_section(struct rebindings_entry *rebindings,</div><div class="line">                                           section_t *section,</div><div class="line">                                           intptr_t slide,</div><div class="line">                                           nlist_t *symtab,//符号表</div><div class="line">                                           char *strtab, // 字符串表</div><div class="line">                                           uint32_t *indirect_symtab)  &#123; // 间接符号表</div></pre></td></tr></table></figure>
<p>然后就是遍历section，查找需要hook的符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">    for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123;</div><div class="line">        // symtab_index就是indirect_symbol中data的值,也是符号表的索引</div><div class="line">        uint32_t symtab_index = indirect_symbol_indices[i];</div><div class="line">        if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</div><div class="line">            symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 根据symtab_index(indirect_symbol中data的值)去访问symbol_table，获取到symbol_table中的偏移offset(即symbol_table中data的值，这个值也是字符串表中的偏移值)</div><div class="line">        uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx;</div><div class="line">        </div><div class="line">        // 访问string_table，根据strtab_offset获取symbol_name(函数名)</div><div class="line">        char *symbol_name = strtab + strtab_offset;</div><div class="line">        </div><div class="line">        // string_table中的所有函数名都是以&quot;_&quot;开始的，所以一个函数一定有两个字符</div><div class="line">        bool symbol_name_longer_than_1 = symbol_name[0] &amp;&amp; symbol_name[1];</div><div class="line">        </div><div class="line">        ///依次枚举struct rebindings_entry 结构，判断时候有和当前函数指针相等的带替换的函数。</div><div class="line">        struct rebindings_entry *cur = rebindings;</div><div class="line">        </div><div class="line">        while (cur) &#123;</div><div class="line">            // 循环每个entry中需要重绑定的函数</div><div class="line">            for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123;</div><div class="line">                // 判断symbol_name是否是一个正确的函数名</div><div class="line">                // 需要被重绑定的函数名是否与当前symbol_name相等</div><div class="line">                if (symbol_name_longer_than_1 &amp;&amp;</div><div class="line">                    strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123;</div><div class="line">                    // 判断replaced是否存在</div><div class="line">                    // 判断replaced和老的函数是否是一样的</div><div class="line">                    if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp;</div><div class="line">                        indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</div><div class="line">                        // 将原函数的地址给新函数replaced</div><div class="line">                        *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</div><div class="line">                        </div><div class="line">                    &#125;</div><div class="line">//                    rebindingSec++;</div><div class="line">//                    printf(&quot;rebindingSec%d\n&quot;,rebindingSec);</div><div class="line">                    // 将replacement赋值给刚刚找到的</div><div class="line">                    indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</div><div class="line">                    goto symbol_loop;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // 继续下一个需要绑定的函数</div><div class="line">            cur = cur-&gt;next;</div><div class="line">        &#125;</div><div class="line">    symbol_loop:;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>结合MachOView，以<code>NSLog</code>为例逐步分析下：</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_find_first.jpg" alt="image"></p>
<p>从<code>__la_symbol_ptr</code>这个section可以看到<code>NSLog</code>在第一列，mach-o有一个规律就是<code>__la_symbol_ptr</code>和<code>Indirect Symbols</code>是一一对应的，所以我们到<code>Indirect Symbols</code>第一行中，得到data = 0x7b，转成10进制为123</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_find_second_1.jpg" alt="image"></p>
<p>从程序里断点也可以看出得到的symtab_index也为123</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_find_second_2.jpg" alt="image"></p>
<p>然后到<code>Symbol Table</code>找到索引为123的那一行，可以得到value值为：0x9c</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_find_second_3.jpg" alt="image"></p>
<p>再到<code>String Table</code> 中找到偏移为0x9c的字符，即 0xCF0C + 0x9c = 0xCFAB，即找到了NSLog，然后进行替换</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_find_second_4.jpg" alt="image"></p>
<p>最后引用下官方流程图：</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/fishhook/fishhook_liucheng.png" alt="image"></p>
<ol>
<li>找到  <code>__DATA</code>段中<code>__la_symbol_ptr</code>section的位置，偏移为1061</li>
<li><code>Lazy Symbol Pointer Table</code>中第index行代表的函数和<code>Indirect Symbol Table</code>中第index行代表的函数是一样的，所以上图中 ‘Find entry with same index in indirect symbol table’，即1061也是间接符号表的偏移量</li>
<li>reserved1+1601的带的是间接符号表对应的section，间接符号表的value值16343即为<code>Symbol Table</code>的偏移值</li>
<li>找到<code>Symbol Table</code>的中对应16343的对象，其data值70026代表了符号在<code>String Table</code>的偏移值。</li>
<li><code>String Table</code>起始地址加上偏移值，即strtab+70026即找到了要替换的符号，然后进行替换。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/06/WebSocket/" itemprop="url">
                  WebSocket
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-04-06T21:42:48+08:00" content="2019-04-06">
              2019-04-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/04/06/WebSocket/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/06/WebSocket/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/04/06/WebSocket/" class="leancloud_visitors" data-flag-title="WebSocket">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目里的直播聊天系统使用了WebSocket进行通信，故了解了一番WebSocket的知识。</p>
<h3 id="WebSocket协议细解"><a href="#WebSocket协议细解" class="headerlink" title="WebSocket协议细解"></a>WebSocket协议细解</h3><p>WebSocket协议和HTTP协议一样，也是应用层协议，都是基于TCP的，可靠性的传输协议。不同点主要有两点：</p>
<ul>
<li><ol>
<li>WebSocket是双向通信协议，客户端与服务端都可以发送或接收信息</li>
</ol>
</li>
<li><ol>
<li>WebSocket的连接需要HTTP的一次握手</li>
</ol>
</li>
</ul>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>首先客户端发送一个请求，报文格式规定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">方法必须位GET方法</div><div class="line">HTTP版本不能低于1.1</div><div class="line">必须包含Upgrade头部，值必须为websocket</div><div class="line">必须包含Sec-WebSocket-Key头部，值是一个Base64编码的16字节随机字符串。</div><div class="line">必须包含Sec-WebSocket-Version头部，值必须为13</div></pre></td></tr></table></figure>
<p>其中Upgrade、Connection字段，就是告诉服务端，我要建立一个WebSocket的连接。即为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://example.com</div></pre></td></tr></table></figure>
<p>上面是建立WebSocket连接的一个请求头，类似HTTP的连接。</p>
<p>服务端验证客户端的握手包符合规范之后也会发送一个握手包给客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure>
<p>规范为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">必须包含Connection头部，值必须为Upgrade</div><div class="line">必须包含一个Upgrade头部，值必须为websocket</div><div class="line">必须包含一个Sec-Websocket-Accept头部</div></pre></td></tr></table></figure>
<p>Sec-WebSocket-Accept的值与Sec-WebSocket-Key是对应的，由计算方式计算而来:</p>
<ol>
<li>将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。</li>
<li>通过SHA1计算出摘要，并转成base64字符串。</li>
</ol>
<p>客户端收到服务端的握手包之后，验证Sec-Websocket-Accept的值，验证正确后连接成功，之后就跟HTTP协议没有什么关系了，数据传输完全就是WebSocket协议的内容。</p>
<h4 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h4><p>在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。从<a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="external">RFC文档</a>可以看出数据帧格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0                   1                   2                   3</div><div class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</div><div class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</div><div class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</div><div class="line">| |1|2|3|       |K|             |                               |</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|     Extended payload length continued, if payload len == 127  |</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|                               |Masking-key, if MASK set to 1  |</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">| Masking-key (continued)       |          Payload Data         |</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|                     Payload Data continued ...                |</div><div class="line">+---------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>FIN: 如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>
<p>RSV1, RSV2, RSV3：扩展使用，一般情况下全为0。</p>
<p>opcode：操作代码，Opcode的值决定了应该如何解析后续的数据（data payload）。如果操作代码是不认识的，那么接收端应该断开连接。代码如下</p>
<ul>
<li>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片</li>
<li>%x1：表示这是一个文本帧（frame）</li>
<li>%x2：表示这是一个二进制帧（frame）</li>
<li>%x3-7：保留的操作代码，用于后续定义的非控制帧。</li>
<li>%x8：表示连接断开。</li>
<li>%x9：表示这是一个ping操作。</li>
<li>%xA：表示这是一个pong操作。</li>
<li>%xB-F：保留的操作代码，用于后续定义的控制帧。</li>
</ul>
<p>Mask：表示是否要对数据（data payload）进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p>
<p>Payload length：数据的长度，单位是字节。</p>
<p>Payload Data：传输的数据。</p>
<p>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。<br>WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>
<p>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p>
<h4 id="连接保持-心跳"><a href="#连接保持-心跳" class="headerlink" title="连接保持(心跳)"></a>连接保持(心跳)</h4><p>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<ul>
<li>发送方-&gt;接收方：ping</li>
<li>接收方-&gt;发送方：pong</li>
</ul>
<p>ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。</p>
<h3 id="iOS端WebScoket实现"><a href="#iOS端WebScoket实现" class="headerlink" title="iOS端WebScoket实现"></a>iOS端WebScoket实现</h3><p>我们iOS客户端使用了FaceBook的<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="external">SocketRocket</a>来进行通信，SocketRocket内部实现了握手连接，发送与接收数据，发送ping，接收pong功能。我们使用暂时没有发现什么问题，唯一需要注意的是要自己实现心跳包及重连的代码。</p>
<p>建立连接方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)initWithURLRequest:(NSURLRequest *)request</div></pre></td></tr></table></figure>
<p>代理方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)webSocketDidOpen:(SRWebSocket *)webSocket;</div><div class="line">- (void)webSocket:(SRWebSocket *)webSocket didFailWithError:(NSError *)error;</div><div class="line">- (void)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(NSInteger)code reason:(NSString *)reason wasClean:(BOOL)wasClean;</div><div class="line">- (void)webSocket:(SRWebSocket *)webSocket didReceivePong:(NSData *)pongPayload;</div></pre></td></tr></table></figure>
<p>打开与关闭：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)open;</div><div class="line">- (void)close;</div></pre></td></tr></table></figure>
<p>发送数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)send:(id)data;</div></pre></td></tr></table></figure>
<p>发送ping:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)sendPing:(NSData *)data;</div></pre></td></tr></table></figure>
<p>基本上用这几个方法就能实现想要的功能。因为我们要自己维持心跳连接及重连，所以还要再封装一层，代码见<a href="https://github.com/coderZhou10496/ZJWebSocket" target="_blank" rel="external">Github</a>。</p>
<p>建立连接的时候，调用了SocketRocket的<code>- (void)setDelegateDispatchQueue:(dispatch_queue_t)queue</code>方法，用意是数据的接收全都在指定的队列里，放在子线程中进行，因为聊天功能要频繁的接收消息。所有我们创建了一个串行队列传给SocketRocket。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.delegateRecQueue = dispatch_queue_create(&quot;com.zj.socket.queue&quot;,DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">[self.webSocket setDelegateDispatchQueue:self.delegateRecQueue];</div></pre></td></tr></table></figure>
<p>判断是否重连的机制为：</p>
<p>当收到 <code>didFailWithError</code> 和 <code>didCloseWithCode</code>方法时，先判断是否是自己主动关闭了WebSocket连接，如果是自己主动关闭了连接，则不做处理；如果是未知错误而关闭了连接，则进行重连机制。重连的时候先判断是否有网，如果无网络的话，也没有重连的必要了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)reConnect &#123;</div><div class="line">    if(self.connectType == WebSocketConnect) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    [self webSocketClose];</div><div class="line">    </div><div class="line">    if (self.reConnectTime &gt;= 32) &#123;</div><div class="line">        self.reConnectTime = 1;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    __block NSInteger time = self.reConnectTime;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;重连&quot;);</div><div class="line">        time = time * 2;</div><div class="line">        self.reConnectTime = time;</div><div class="line">        [self webSocketOpen];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重连之前要确保在主线程中进行，并且确保之前的连接已经关闭了。</p>
<p>连接成功后创建心跳定时器，定时发送ping数据，调用SocketRocket的<code>sendPing</code>方法就行，这个方法内部是做数据处理，标记这个数据为ping数据：<br>，心跳的数据格式和服务端协商好就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#pragma mark - 心跳定时器</div><div class="line">- (void)createHeartBeat &#123;</div><div class="line">    dispatch_main_async_safe(^&#123;</div><div class="line">        [self cancelHeartBeat];</div><div class="line">        </div><div class="line">        self.heartBeat = [NSTimer timerWithTimeInterval:30 target:self selector:@selector(heartBeatFire) userInfo:nil repeats:YES];</div><div class="line">        </div><div class="line">        [[NSRunLoop currentRunLoop]addTimer:self.heartBeat forMode:NSRunLoopCommonModes];</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)sendPing &#123;</div><div class="line">    if([self netWorkReachable]) &#123;</div><div class="line">        NSDictionary *dicData = @&#123;&#125;;</div><div class="line">        NSData *data = [NSJSONSerialization dataWithJSONObject:dicData options:NSJSONWritingPrettyPrinted error:nil];</div><div class="line">        [self.webSocket sendPing:data];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在代码里我专门创建了一个用于接收消息的类<code>ZJMessageHandler</code>，WebSocket收到的消息都会交由这个类进行处理，处理后再交给上层不同的业务方。</p>
<p>详细代码见<a href="https://github.com/coderZhou10496/ZJWebSocket" target="_blank" rel="external">Github</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/16/自律以自救/" itemprop="url">
                  自律以自救
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-03-16T17:22:58+08:00" content="2019-03-16">
              2019-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/读书与感悟/" itemprop="url" rel="index">
                    <span itemprop="name">读书与感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/03/16/自律以自救/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/16/自律以自救/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/03/16/自律以自救/" class="leancloud_visitors" data-flag-title="自律以自救">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进入新公司已半年有余，不知道怎的，感觉每天时间过的特别快，什么都还没做一天时间就过去了。上个月更是独立负责一个新的项目，工作节奏也更加紧凑，接触新的工作环境，融入新的团队，也只有在今天周末的时候有时间写下最近的生活工作感想。</p>
<p>之前在小的公司工作，每天有大量的业余时间，每天六点下班，下班之后想干嘛干嘛，那个时候还订了个目标来约束自己:每个月看一本书，或技术类，或文学类，或职场类。工作状态对于现在的我简直天差地别，新的工作单位工作更加忙碌，压力也更加大。感触比较深的一点是，大公司的开发流程是如此的规范。</p>
<p>其实我有的时候在想，忙碌的工作真的让我成长了吗？</p>
<p>成长是什么？我觉得就是今天的你，比昨天的你更优秀。比如写代码，你学到了一个新的api，学到了更好的代码方法实现功能，你的技能得到了成长；你认识了一个新朋友，你的人脉得到了成长；你今天生活中遇到的一个事，让你悟到了一个道理，你的生活阅历得到了成长。</p>
<p>互联网公司人才辈出，发展也迅速，也可能是这个原因是我有了一种焦虑感，觉得自己付出的不够多，学到的不够多。其实我自己内心的想法很多，但真正能够付诸实践，坚持下来的却很少。我觉得生活就应该被”打鸡血”(为何此时想到了传销)，应该活的更加激情一些，更加有意义一些，许三多说过，生活就应该做很多有意义的事，尝试一下没有没有做过的生活。</p>
<p>有新的目标真的挺重要的。我之前在小公司，目标是进入稳定的大公司工作，为了这个目标，去学习底层知识，去重新看计算机，HTPP相关的知识，去刷算法题，至少技术方面收获了很多。现在在规模稍大的公司，目标是提高自我管理能力，项目把控能力，问题分析能力，团队沟通能力，。在一个技术行业三年后，就不应该纯粹的关注于技术了，自己的软实力同等重要。前段时间看了一篇文章讲的很好，说的是程序员的阶段:</p>
<p>第一阶段 – 三年：</p>
<p>这个阶段将会淘汰掉一批不适合写代码的人。这一阶段，我们走出校园，迈入社会，成为一名程序员，正式从书本上的内容迈向真正的企业级开发。我们知道如何团队协作、如何使用项目管理工具、项目版本如何控制、我们写的代码如何测试如何在线上运行等等，积累了一定的开发经验，也对代码有了一定深入的认识，是一个比较纯粹的Coder的阶段。</p>
<p>第二阶段 – 五年</p>
<p>有些人在三年里，除了完成工作，在空余时间基本不会研究别的东西，这些人永远就是个Coder，年纪大一些势必被更年轻的人给顶替；有些人在三年里，除了写代码之外，还热衷于研究各种技术实现细节、看了N多好书、写一些博客、在Github上分享技术，这些人在五年后必然具备在技术上独当一面的能力并且清楚自己未来的发展方向，从一个Coder逐步走向系统分析师或是架构师，成为项目组中不可或缺的人物</p>
<p>第三阶段 – 十年</p>
<p>十年又是另一个门槛了，转行或是继续做一名程序员就在这个节点上。如果在前几年就抱定不转行的思路并且为之努力的话，那么在十年的这个节点上，有些人必然成长为一名对行业有着深入认识、对技术有着深入认识、能从零开始对一个产品进行分析的程序员，这样的人在公司基本担任的都是CTO、技术专家、首席架构师等最关键的职位。</p>
<p>可以看出，越来越注重团队。自己毕业三年多了，感觉自己还是处于第一阶段，惭愧惭愧。</p>
<p>关于业务与技术，之前一直比较注重于技术，而忽略了业务同等重要。业务理解能力，应该是程序员除了技术之外，最具价值的能力。技术本身很难赚钱，业务落地才能赚钱。单纯的技术进步不难，难得是如何在业务中发现问题，解决问题。一切的技术都是为业务服务的。拿我的实际情况来说，公司内部会有技术分享，假如你分享的技术能够与当前的业务相结合，解决当前的技术难题，那么这就是一场很有价值的分享；假如分享的技术跟业务没有一点关系，就算再高深，再牛X，我觉得也是没有达到分享的标准。</p>
<p>本来有个小目标，每天刷一道算法题，刷《剑指Offer》,也是因为新项目而没能坚持下去，中断了。最近关于学习这方面有些怠慢了，也有可能是新项目压力比较大，工作上有些烦躁，所以写这篇感想来激励自己，自律以自救，严格要求自己，希望自己每天抽出时间，读会书，看会技术博客，充实下自己。</p>
<p>上帝是公平的，你付出什么，总会得到成果的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/" itemprop="url">
                  Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-21T20:36:51+08:00" content="2019-02-21">
              2019-02-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/" class="leancloud_visitors" data-flag-title="Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>闲暇时间用Metal撸了一个图片处理demo，也查阅参考了很多大佬的文章，demo代码已上传至<a href="https://github.com/coderZhou10496/Filter" target="_blank" rel="external">Github</a></p>
<h3 id="LUT滤镜"><a href="#LUT滤镜" class="headerlink" title="LUT滤镜"></a>LUT滤镜</h3><p>LUT是look up table，查找表的缩写，所有的颜色都可以在一张表(图片)上找到。我们知道R、G、B三种颜色分别有256种取值，所有的颜色组合就有256X256X256种情况，大约占48MB空间，占用很大的内存，但是有了LUT映射表后，我就可以对任意一张图片进行相同的滤镜变换。</p>
<p>我们遍历图片的像素点，对于每一个像素点，获得其 RGB 组合，在 LUT 表格中查找此 RGB 组合及其对应的 RGB 映射值，然后用 RGB 映射值替换原图的像素点，就可以完成滤镜变换了。但是如何在一张图片中存储三种颜色值的组合呢？</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/original.png" width="50%"><br></div>

<p><br></p>
<p>上图就是一张标准的颜色查找表。它在横竖方向上分成了 8X8 一共 64 个小方格，每一个小方格内的 B 分量为一个定值，总共就表示了 B 分量的 64 种可能值。同时对于每一个小方格，横竖方向又各自分为 64 个小格，横向小格的 R 分量依次增加，纵向小格的 G 分量依次增加。即：</p>
<ul>
<li>整体对每个小方块而言，从左上往右下 B 从 0 到 1 ，是 z 字型的顺序</li>
<li>单独对每个小方块而言，从左到右 R 从 0 到 1，代表 x</li>
<li>单独对每个小方块而言，从上到下 G 从 0 到 1，代表 y</li>
</ul>
<p>那么根据颜色查找表得到转换后的颜色步骤为：</p>
<p>1、用蓝色值R计算正方形的位置，假如一个像素点原来rgb是(0.1, 0.2, 0.4)，那么B = 0.4，则(0.4 <em> 63 = 25.6)/8 = 3，（25 - 3 </em> 8）= 1，即第3行第1列的那个大正方形，quad1.y = 3，quad1.x = 1.</p>
<p>2、根据红色值和绿色值计算对应位置在整个纹理的坐标。</p>
<p>texPos1.x = (quad1.x <em> 64 + rgb.r </em> 63 + 0.5)/512.0</p>
<p>texPos1.y = (quad1.y <em> 64 + rgb.g </em> 63 + 0.5)/512.0</p>
<p>这里，quad1.x * 64意思是：quad1.x和quad1.y是大正方形的坐标，每个大正方形是64格，所以乘以64；</p>
<p>rgb.r * 63意思是：每个大正方形是64格，即(0,63)；</p>
<p>加上0.5表示每个最小的小正方形的中心点；最后除以512.0是因为整个lut图片是512 * 512的，被放大了512倍。最后得到的是每个小正方格中心在整个lut大图中的坐标。</p>
<p>3、根据texPos1和texPos2读取映射结果，再用蓝色值的小数部分进行mix操作</p>
<p>shader代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">fragment float4</div><div class="line">lookUpTableShader(RasterizerData input [[stage_in]], // stage_in表示这个数据来自光栅化。（光栅化是顶点处理之后的步骤，业务层无法修改）</div><div class="line">               texture2d&lt;float&gt; normalTexture [[ texture(LYFragmentTextureIndexNormal) ]], // texture表明是纹理数据，LYFragmentTextureIndexNormal是索引</div><div class="line">               texture2d&lt;float&gt; lookupTableTexture [[ texture(LYFragmentTextureIndexLookupTable) ]]) // texture表明</div><div class="line">&#123;</div><div class="line">    constexpr sampler textureSampler (mag_filter::linear,</div><div class="line">                                      min_filter::linear); // sampler是采样器</div><div class="line">    float4 textureColor = normalTexture.sample(textureSampler, input.textureCoordinate); //正常的纹理颜色</div><div class="line">    </div><div class="line">    float blueColor = textureColor.b * 63.0; // 蓝色部分[0, 63] 共64种</div><div class="line">    </div><div class="line">    float2 quad1; // 第一个正方形的位置, 假如blueColor=22.5，则y=22/8=2，x=22-8*2=6，即是第2行，第6个正方形；（因为y是纵坐标）</div><div class="line">    quad1.y = floor(floor(blueColor) * 0.125);</div><div class="line">    quad1.x = floor(blueColor) - (quad1.y * 8.0);</div><div class="line">    </div><div class="line">    float2 quad2; // 第二个正方形的位置，同上。注意x、y坐标的计算，还有这里用int值也可以，但是为了效率使用float</div><div class="line">    quad2.y = floor(ceil(blueColor) * 0.125);</div><div class="line">    quad2.x = ceil(blueColor) - (quad2.y * 8.0);</div><div class="line">    </div><div class="line">    float2 texPos1; // 计算颜色(r,b,g)在第一个正方形中对应位置</div><div class="line">    texPos1.x = ((quad1.x * 64) +  textureColor.r*63 + 0.5)/512.0;</div><div class="line">    texPos1.y = ((quad1.y * 64) +  textureColor.g*63 + 0.5)/512.0;</div><div class="line">    </div><div class="line">    </div><div class="line">    float2 texPos2; // 同上</div><div class="line">    texPos2.x = ((quad2.x * 64) +  textureColor.r*63 + 0.5)/512.0;</div><div class="line">    texPos2.y = ((quad2.y * 64) +  textureColor.g*63 + 0.5)/512.0;</div><div class="line">    </div><div class="line">    float4 newColor1 = lookupTableTexture.sample(textureSampler, texPos1); // 正方形1的颜色值</div><div class="line">    float4 newColor2 = lookupTableTexture.sample(textureSampler, texPos2); // 正方形2的颜色值</div><div class="line">    </div><div class="line">    float4 newColor = mix(newColor1, newColor2, fract(blueColor)); // 根据小数点的部分进行mix</div><div class="line">    return float4(newColor.rgb, textureColor.w); //不修改alpha值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话我们就能从颜色查找表中得到了对应的转换后的颜色。</p>
<p>如果使用lut进行滤镜，那么每一种滤镜效果都对应着一张颜色查找表。上面给出的图片是原色的颜色查找表，所以使用这张查找表对要滤镜的图片进行处理的话，要滤镜的图片不会有任何变化。</p>
<p>而使用有滤镜效果的查找表进行处理，会有滤镜的效果</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_xiaoguo_1.jpg" width="70%" height="50%"><br></div>

<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_xiaoguo_2.jpg" width="70%" height="50%"><br></div>

<p><br></p>
<p>代码里，我封装了一个<code>ZJLookupTableImageFilter</code>工具类来进行lut滤镜，只需要传入一个MTKView和lut图片就可以进行lut滤镜</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface ZJLookupTableImageFilter : ZJBaseImageFilter</div><div class="line"></div><div class="line">+ (void)filterWithImageView:(ZJShaderLookupImageView *)imageView lookupTableImage:(UIImage *)lutImage;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的lookUpTableShader代码里传入了两个参数，一个是正常图片的texture，另一个是lut图片的texture，所以每选中一个lut图片对原图片进行滤镜处理时，需要得到lut图片的texture.这里我通过<code>ZJTextureProvider</code>这个工具类来获得一张图片的texture。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</div><div class="line">                                                                                             width:width</div><div class="line">                                                                                            height:height</div><div class="line">                                                                                         mipmapped:NO];</div><div class="line">textureDescriptor.usage = MTLTextureUsageShaderRead;</div><div class="line">id&lt;MTLTexture&gt; texture = [context.device newTextureWithDescriptor:textureDescriptor];</div><div class="line"></div><div class="line"></div><div class="line">MTLRegion region = &#123;&#123; 0, 0, 0 &#125;, &#123;image.size.width, image.size.height, 1&#125;&#125;; // 纹理上传的范围</div><div class="line">[texture replaceRegion:region mipmapLevel:0 withBytes:spriteData bytesPerRow:4 * image.size.width];</div><div class="line">free(spriteData);</div></pre></td></tr></table></figure>
<p>然后通过这行代码传入shader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[renderEncoder setFragmentTexture:self.lookupTableTexture</div><div class="line">                                  atIndex:1];</div></pre></td></tr></table></figure>
<p>注意这里index要传1，要和shader中的<code>LYFragmentTextureIndexLookupTable</code>对应</p>
<h3 id="颜色饱和度、模糊度"><a href="#颜色饱和度、模糊度" class="headerlink" title="颜色饱和度、模糊度"></a>颜色饱和度、模糊度</h3><p>模糊后的图片，可调节颜色饱和度及模糊度:</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_blur.jpg" width="50%" height="50%"><br></div>

<p><br></p>
<p>（本来是录制了一个视频的，但是有4M多，半天显示不出来，只好放图片了。）</p>
<p>无论是lut滤镜，还是模糊度调节，都是使用<code>MTLComputeCommandEncoder</code>来处理的。通过<code>computeCommandEncoder</code>方法来获得对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id&lt;MTLComputeCommandEncoder&gt; computeEncoder = [commandBuffer computeCommandEncoder]</div></pre></td></tr></table></figure>
<p>其中有一个地方要设置编码的线程组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[computeEncoder dispatchThreadgroups:self.groupCount</div><div class="line">                   threadsPerThreadgroup:self.groupSize];</div></pre></td></tr></table></figure>
<p>代码里使用<code>ZJShaderImageFilter</code>来进行饱和度模糊度调节，传入需要调节的图片及颜色饱和度value(0,1.0)，模糊度value(0,1.0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (void)shaderImageViewWithView:(ZJShaderImageView *)imageView </div><div class="line">   					saturationValue:(float)saturationValue </div><div class="line">   					blurRadiusValue:(float)blurRadiusValue</div></pre></td></tr></table></figure>
<p>两种效果的shader代码分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">kernel void adjust_saturation(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</div><div class="line">                              texture2d&lt;float, access::write&gt; outTexture [[texture(1)]],</div><div class="line">                              constant AdjustSaturationUniforms &amp;uniforms [[buffer(0)]],</div><div class="line">                              uint2 gid [[thread_position_in_grid]])</div><div class="line">&#123;</div><div class="line">    float4 inColor = inTexture.read(gid);</div><div class="line">    float value = dot(inColor.rgb, float3(0.299, 0.587, 0.114));</div><div class="line">    float4 grayColor(value, value, value, 1.0);</div><div class="line">    float4 outColor = mix(grayColor, inColor, uniforms.saturationFactor);</div><div class="line">    outTexture.write(outColor, gid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">kernel void gaussian_blur_2d(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</div><div class="line">                             texture2d&lt;float, access::write&gt; outTexture [[texture(1)]],</div><div class="line">                             texture2d&lt;float, access::read&gt; weights [[texture(2)]],</div><div class="line">                             uint2 gid [[thread_position_in_grid]])</div><div class="line">&#123;</div><div class="line">    int size = weights.get_width();</div><div class="line">    int radius = size / 2;</div><div class="line">    </div><div class="line">    float4 accumColor(0, 0, 0, 0);</div><div class="line">    for (int j = 0; j &lt; size; ++j)</div><div class="line">    &#123;</div><div class="line">        for (int i = 0; i &lt; size; ++i)</div><div class="line">        &#123;</div><div class="line">            uint2 kernelIndex(i, j);</div><div class="line">            uint2 textureIndex(gid.x + (i - radius), gid.y + (j - radius));</div><div class="line">            float4 color = inTexture.read(textureIndex).rgba;</div><div class="line">            float4 weight = weights.read(kernelIndex).rrrr;</div><div class="line">            accumColor += weight * color;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    outTexture.write(float4(accumColor.rgb, 1), gid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只需要处理texture，把最终的处理结果传给片元函数就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[renderEncoder setFragmentTexture:_texture</div><div class="line">                                  atIndex:0];</div></pre></td></tr></table></figure>
<p>即这里的_texture需要由外部控制，由<code>ZJShaderImageFilter</code>分别经过饱和度处理，模糊度处理后将最终需要传给shader的texture传入。</p>
<p>饱和度处理时，需要额外传入buffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct AdjustSaturationUniforms uniforms;</div><div class="line">    uniforms.saturationFactor = self.isDirty ? self.saturValue : 1.0;</div><div class="line">    id&lt;MTLBuffer&gt; buffer = [self.metalContext.device newBufferWithLength:sizeof(uniforms)</div><div class="line">                                                                 options:MTLResourceOptionCPUCacheModeDefault];</div><div class="line">    memcpy([buffer contents], &amp;uniforms, sizeof(uniforms));</div><div class="line">    </div><div class="line">    [computeEncoder setBuffer:buffer offset:0 atIndex:0];</div></pre></td></tr></table></figure>
<p>而对于模糊度处理，需要额外传入texture:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(self.blurTexture == nil) &#123;</div><div class="line">            [self configBlurTexture];</div><div class="line">        &#125;</div><div class="line">        [computeEncoder setTexture:self.blurTexture</div><div class="line">                           atIndex:2];</div></pre></td></tr></table></figure>
<p>当texture经过编码器(Command Encoder)分别经过饱和度处理和模糊处理时<br>我们是先处理饱和度，后处理模糊度，即饱和度的texture输出outputTexture,为模糊度的输入inputTexture,而模糊度的输出为shader的输入。所以一定要保证饱和度经过编码器(Command Encoder)处理后，再去进行模糊操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[commandBuffer waitUntilCompleted]</div></pre></td></tr></table></figure>
<p>最后一张简单的框架处理流程：</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_liucheng.jpg" width="100%"><br></div>

<p><br></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/21/Metal学习(一)：基本概念介绍/" itemprop="url">
                  Metal学习(一)：基本概念介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-21T20:13:10+08:00" content="2019-02-21">
              2019-02-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/21/Metal学习(一)：基本概念介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/21/Metal学习(一)：基本概念介绍/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/02/21/Metal学习(一)：基本概念介绍/" class="leancloud_visitors" data-flag-title="Metal学习(一)：基本概念介绍">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>断断续续的学习了<a href="https://developer.apple.com/documentation/metal?language=objc" target="_blank" rel="external">Metal</a>，整理下。</p>
<p>关于Metal的介绍，先引用官方文档的一句话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The Metal framework supports GPU-accelerated advanced 3D graphics rendering and data-parallel computation workloads. </div><div class="line">Metal provides a modern and streamlined API for fine-grained, low-level control of the organization, processing, </div><div class="line">and submission of graphics and computation commands, as well as the management of the associated data and resources </div><div class="line">for these commands. A primary goal of Metal is to minimize the CPU overhead incurred by executing GPU workloads.</div></pre></td></tr></table></figure>
<p>意思就是Metal框架提供了GPU加速的高级3D图形渲染功能和数据并行计算的功能，能够更有效地集成图形和计算任务，减小CPU消耗。</p>
<p>Metal优点：</p>
<ul>
<li>GPU 支持的 3D 渲染</li>
<li>和 CPU 并行处理数据 （深度学习）</li>
<li>提供低功耗接口</li>
<li>与 CPU 共享资源内存</li>
</ul>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/Metal_kuangjia.jpg" width="50%" height="50%"><br></div>



<p>Core Animation 依赖于 Metal 做 GPU 渲染，Core Graphics 做 CPU 渲染.</p>
<p>并且在iOS12中，苹果已经弃用了<a href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">OpenGL ES</a>对底层的支持，全面由Metal渲染。可见，苹果对于Metal框架越来越重视。研究Metal框架对于我们了解iOS系统是如何运作的，是怎么支持CoreAnimation框架进行渲染的有很大的帮助。并且用Metal能帮助我们实现一些很有意思的功能，比如图像处理，视频滤镜，高并发运算等。</p>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>在Metal架构中，<code>MTLDevice</code>协议定义了代表单个GPU的接口。与Metal交互所需的对象都来自于获取的<code>MTLDevice</code>。我们可以通过<code>MTLCreateSystemDefaultDevice</code>来获取所需要操作的GPU对象</p>
<h3 id="MLBuffer"><a href="#MLBuffer" class="headerlink" title="MLBuffer"></a>MLBuffer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A memory allocation for storing unformatted data that is accessible to the GPU.</div></pre></td></tr></table></figure>
<p>MLBuffer可以理解为一块连续的内存，它里面存储的数据，是没有格式、类型限制的，即可以存储任意类型的数据，是GPU可访问的专用容器，使图形渲染管道能够从中读取顶点数据。在Metal中用于存储顶点数据。</p>
<p>一般使用这个方法来创建MTLBuffer对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;MTLBuffer&gt;)newBufferWithBytes:(const void *)pointer </div><div class="line">									 length:(NSUInteger)length </div><div class="line">									 options:(MTLResourceOptions)options</div></pre></td></tr></table></figure>
<h3 id="MTLTexture"><a href="#MTLTexture" class="headerlink" title="MTLTexture"></a>MTLTexture</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A memory allocation for storing formatted image data that is accessible to the GPU.</div></pre></td></tr></table></figure>
<p>从开发者角度来看，texture 是一个名词，我们通常说的纹理，指的是一张二维的图片，把它像贴纸一样贴在视图上（采样），使得屏幕显示出我们想要的样子。</p>
<p>但在物理上， texture 指的是 GPU 显存中一段连续的空间，用来存放图像数据。</p>
<p>创建一个MTLTexture对象，需要用到MTLTextureDescriptor，即对纹理相关属性的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">MTLTextureDescriptor *textureDescriptor = [[MTLTextureDescriptor alloc] init];</div><div class="line"></div><div class="line">//  表明每个像素都有一个蓝色，绿色，红色和alpha通道，每个通道都是一个8位无符号标准化值</div><div class="line">textureDescriptor.pixelFormat = MTLPixelFormatBGRA8Unorm;</div><div class="line"></div><div class="line"> //设置纹理的像素尺寸</div><div class="line">textureDescriptor.width = image.width;</div><div class="line">textureDescriptor.height = image.height;</div><div class="line"></div><div class="line">// 通过 descriptor 创建纹理对象</div><div class="line">_texture = [_device newTextureWithDescriptor:textureDescriptor];</div><div class="line"></div><div class="line">// Calculate the number of bytes per row of our image.</div><div class="line">NSUInteger bytesPerRow = 4 * image.width;</div><div class="line"></div><div class="line">//MTLRegion结构用于识别纹理的特定区域。 此示例使用图像数据填充整个纹理; 因此，覆盖整个纹理的像素区域等于纹理的尺寸</div><div class="line">MTLRegion region = &#123;</div><div class="line">    &#123; 0, 0, 0 &#125;,                   // MTLOrigin</div><div class="line">    &#123;image.width, image.height, 1&#125; // MTLSize</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* 与存储多种自定义数据的MTLBuffer对象不同，MTLTexture对象专门用于存储格式化的图像数据。 尽管MTLTextureDescriptor对象指定足够的信息来分配纹理内存，但需要额外的信息来填充空纹理容器。 </div><div class="line">MTLTexture对象由replaceRegion：mipmapLevel：withBytes：bytesPerRow：方法填充图像数据。</div><div class="line">*/</div><div class="line">[_texture replaceRegion:region</div><div class="line">            mipmapLevel:0</div><div class="line">              withBytes:image.data.bytes</div><div class="line">            bytesPerRow:bytesPerRow];</div></pre></td></tr></table></figure>
<p>这里MTLRegion指的是texture中对应的图像区域，一般和图片大小保持一致。纹理坐标(0,0)默认在左下角，右上角为(1,1).</p>
<div align="center"><br><br><br><img src="https://docs-assets.developer.apple.com/published/a8fcc3ae6f/bd9ffd7d-01bf-45f2-8678-779fd47a7f9c.png" width="50%" height="50%"><br><br><br></div>


<h3 id="MTLLibrary"><a href="#MTLLibrary" class="headerlink" title="MTLLibrary"></a>MTLLibrary</h3><p>MTLLibrary负责加载定义在<code>.metal</code>文件中的着色器程序。通过MTLLibrary可以获得MTLFunction对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;MTLFunction&gt;) newFunctionWithName:(NSString *)functionName;</div></pre></td></tr></table></figure>
<h3 id="MTLCommandQueue，MTLCommandBuffer"><a href="#MTLCommandQueue，MTLCommandBuffer" class="headerlink" title="MTLCommandQueue，MTLCommandBuffer"></a>MTLCommandQueue，MTLCommandBuffer</h3><p>MTLCommandQueue由device创建，是整个app绘制的队列，而command buffer存放每次渲染的指令,即包含了每次渲染所需要的信息，直到指令被提交到GPU执行。Command queue用于创建和组织MTLCommandBuffer，其内部存在着多个command buffer，并且保证指令（command buffer）有序地发送到GPU。</p>
<p>command buffer是“一次性对象”，不支持重用。一旦command buffer被提交执行，唯一能做的是等待command buffer被调度或完成。</p>
<ul>
<li>Command buffers是从command queue里创建的</li>
<li>Command encoders将渲染指令command填充到command buffers</li>
<li>Command buffers将数据提交到GPU</li>
<li>GPU开始执行，呈现结果</li>
</ul>
<p><img src="https://docs-assets.developer.apple.com/published/6aedb538f8/b5ff0489-1079-441a-8a24-8f8c75dd2b1e.png" alt="MTLCommandBuffer"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">// Create a new command buffer for each render pass to the current drawable</div><div class="line">id&lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer];</div><div class="line">commandBuffer.label = @&quot;MyCommand&quot;;</div><div class="line">// Obtain a renderPassDescriptor generated from the view&apos;s drawable textures</div><div class="line">MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;</div><div class="line"></div><div class="line">if(renderPassDescriptor != nil)</div><div class="line">&#123;</div><div class="line">    // Create a render command encoder so we can render into something</div><div class="line">    id&lt;MTLRenderCommandEncoder&gt; renderEncoder =</div><div class="line">    [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];</div><div class="line">    renderEncoder.label = @&quot;MyRenderEncoder&quot;;</div><div class="line"></div><div class="line">    // 设置显示区域</div><div class="line">    [renderEncoder setViewport:(MTLViewport)&#123;0.0, 0.0, _viewportSize.x, _viewportSize.y, -1.0, 1.0 &#125;];</div><div class="line"></div><div class="line">    // 设置渲染管道，以保证顶点和片元两个shader会被调用</div><div class="line">    [renderEncoder setRenderPipelineState:_pipelineState];</div><div class="line"></div><div class="line">    // 设置顶点缓存</div><div class="line">    [renderEncoder setVertexBuffer:_vertices</div><div class="line">                            offset:0</div><div class="line">                          atIndex:AAPLVertexInputIndexVertices];</div><div class="line">    </div><div class="line">    [renderEncoder setVertexBytes:&amp;_viewportSize</div><div class="line">                           length:sizeof(_viewportSize)</div><div class="line">                          atIndex:AAPLVertexInputIndexViewportSize];</div><div class="line">    // 设置纹理</div><div class="line">    [renderEncoder setFragmentTexture:_texture</div><div class="line">                              atIndex:AAPLTextureIndexBaseColor];</div><div class="line">    // // 绘制</div><div class="line">    [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle</div><div class="line">                      vertexStart:0</div><div class="line">                      vertexCount:_numVertices];</div><div class="line">     // 结束</div><div class="line">    [renderEncoder endEncoding];</div><div class="line">    // 显示</div><div class="line">    [commandBuffer presentDrawable:view.currentDrawable];</div><div class="line">&#125;</div><div class="line">// Finalize rendering here &amp; push the command buffer to the GPU</div><div class="line">[commandBuffer commit];</div></pre></td></tr></table></figure>
<h3 id="MTLCommandEncoder"><a href="#MTLCommandEncoder" class="headerlink" title="MTLCommandEncoder"></a>MTLCommandEncoder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">An encoder that writes GPU commands into a command buffer</div></pre></td></tr></table></figure>
<p>编码器(Command Encoder)，将我们描述的高级指令，编码转换成GPU可以理解的低级指令(GPU commands)，写入command buffer中。</p>
<pre><code>Protocol | Description |  
------ | -------- | 
MTLRenderCommandEncoder | 用于图形渲染任务的编码器 |  
MTLComputeCommandEncoder | 用于计算任务的编码器 | 
MTLBlitCommandEncoder | 用于内存管理任务的编码器 |  
MTLParallelRenderCommandEncoder | 用于并行编码的多个图形渲染任务的编码器 | 
</code></pre><p>关于buffer，texture，Command Encoder,Command Queue之间的关系，借用官方的一张图，理得很清楚</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Cmd-Model-1_2x.png" alt="blockchain"></p>
<h3 id="Metal-Shader-Language"><a href="#Metal-Shader-Language" class="headerlink" title="Metal Shader Language"></a>Metal Shader Language</h3><p><a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf" target="_blank" rel="external">Metal Shader Language</a>我觉得是学Metal遇到的最大阻力了，并且只能看官方文档来学习，网上讲解的资料也很少，我也只是了解了个大概。</p>
<p>shader有三个基本函数：</p>
<p>顶点函数（vertex），对每个顶点进行处理，生成数据并输出到绘制管线，作为片元函数的输入；</p>
<p>片元函数（fragment），对光栅化后的每个像素点进行处理，生成数据并输出到绘制管线；</p>
<p>通用计算函数（kernel），是并行计算的函数，其返回值类型必须为void；</p>
<p>比如一个顶点函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    float4 clipSpacePosition [[position]]; // position的修饰符表示这个是顶点</div><div class="line">    </div><div class="line">    float2 textureCoordinate; // 纹理坐标，会做插值处理</div><div class="line">    </div><div class="line">&#125; RasterizerData;</div><div class="line"></div><div class="line">vertex RasterizerData // 返回给片元着色器的结构体</div><div class="line">vertexShader(uint vertexID [[ vertex_id ]], // vertex_id是顶点shader每次处理的index，用于定位当前的顶点</div><div class="line">             constant  ZJVertex*vertexArray [[ buffer(0) ]]) &#123; // buffer表明是缓存数据，0是索引</div><div class="line">    RasterizerData out;</div><div class="line">    out.clipSpacePosition = vertexArray[vertexID].position;</div><div class="line">    out.textureCoordinate = vertexArray[vertexID].textureCoordinate;</div><div class="line">    return out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的功能是把从 Metal API 绑定的数据从ZJVertex结构体封装成RasterizerData结构体并交给片元着色器。</p>
<p>比如一个片元函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fragment float4</div><div class="line">samplingShader(RasterizerData input [[stage_in]], // stage_in表示这个数据来自光栅化。（光栅化是顶点处理之后的步骤，业务层无法修改）</div><div class="line">               texture2d&lt;half&gt; colorTexture [[ texture(0) ]]) // texture表明是纹理数据，0是索引</div><div class="line">&#123;</div><div class="line">    constexpr sampler textureSampler (mag_filter::linear,</div><div class="line">                                      min_filter::linear); // sampler是采样器 决定如何对一个纹理进行采样操作。寻址模式，过滤模式，归一化坐标，比较函数</div><div class="line">    </div><div class="line">    half4 colorSample = colorTexture.sample(textureSampler, input.textureCoordinate); // 得到纹理对应位置的颜色</div><div class="line">    </div><div class="line">    float4 color = float4(colorSample);</div><div class="line">    return color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>片元着色器用于处理片元，它的返回值是这个片元的颜色，是一个四维向量。从输入的结构体中取出纹理坐标，利用采样器对纹理采样，拿到对应坐标的颜色值的RGB值，最后返回这个片元的颜色值。</p>
<p>对于没接触过图形学人来说，这些名词比较陌生，可能一时难于理解，主要是多看多练，写多了就理解它们的意义了。</p>
<p>接下会写一下Metal的渲染过程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/02/Metal学习(二)：渲染过程/" itemprop="url">
                  Metal学习(二)：渲染过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-02T16:54:54+08:00" content="2019-02-02">
              2019-02-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/02/Metal学习(二)：渲染过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/02/Metal学习(二)：渲染过程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/02/02/Metal学习(二)：渲染过程/" class="leancloud_visitors" data-flag-title="Metal学习(二)：渲染过程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="渲染管线Pipeline"><a href="#渲染管线Pipeline" class="headerlink" title="渲染管线Pipeline"></a>渲染管线Pipeline</h3><p>在图形处理中中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，所以我们大部分工作都是把3D坐标转变为适应屏幕的2D像素。3D坐标转为2D坐标的处理过程是由的图形渲染管线（Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p>
<p>图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>
<h3 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h3><p>以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。</p>
<a href="!--![Pipeline](https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/PipelineState_2x.png)--">!--![Pipeline](https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/PipelineState_2x.png)--</a>
<h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p>为了让系统知道我们的坐标和颜色值构成的到底是什么，需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一个点？一个三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元。</p>
<p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状。</p>
<h3 id="Vertex-function："><a href="#Vertex-function：" class="headerlink" title="Vertex function："></a>Vertex function：</h3><p>接收一组顶点数据数组，每个顶点执行一次运算，计算该顶点的坐标，颜色，光照，纹理坐标等，在渲染管线中每个顶点都是独立地被执行。每个图元由一个或者多个顶点组成，每个顶点定义一个点，一条边的一端或者三角形的一个角。每个顶点关联一些数据，这些数据包括顶点坐标，颜色，法向量以及纹理坐标等。所有这些顶点相关的信息就构成顶点数据。<br>Vertex function的返回值会被作为片元着色器函数的输入。</p>
<h3 id="Rasterization："><a href="#Rasterization：" class="headerlink" title="Rasterization："></a>Rasterization：</h3><p>在光栅化阶段，基本图元被转换为供片段着色器使用的片段。简单来说，就是将数据转化成可见像素的过程。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。在Metal中，这一步是用户控制不了的，由系统自动处理</p>
<h3 id="Fragment-function"><a href="#Fragment-function" class="headerlink" title="Fragment function"></a>Fragment function</h3><p>片段着色器的主要作用是计算一个像素的最终颜色<br>在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样(从纹理坐标获取纹理颜色叫做采样(Sampling))，以计算该片段的颜色值。从而调整成各种各样不同的效果图，这也是所有OpenGL或Metal高级效果产生的地方<br>片段着色器的返回值是一个四维向量，即是这个片元的颜色 RGBA 值</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/gfx-pipeline_2x.png" alt="Pipeline"></p>
<p>渲染过程：<br>读取顶点数据——执行顶点着色器——组装图元——光栅化图元——执行片元着色器——写入帧缓冲区——显示到屏幕上。</p>
<p>下面就以实际代码来看一下,以<a href="https://developer.apple.com/documentation/metal/basic_texturing?language=objc" target="_blank" rel="external">官方Demo</a>为例：</p>
<p>初始化顶点数据，然后根据顶点数据来计算顶点数量及MTLBuffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Set up a simple MTLBuffer with our vertices which include texture coordinates</div><div class="line">static const AAPLVertex quadVertices[] =</div><div class="line">&#123;</div><div class="line">    // Pixel positions, Texture coordinates</div><div class="line">    &#123; &#123;  250,  -250 &#125;,  &#123; 1.f, 0.f &#125; &#125;,</div><div class="line">    &#123; &#123; -250,  -250 &#125;,  &#123; 0.f, 0.f &#125; &#125;,</div><div class="line">    &#123; &#123; -250,   250 &#125;,  &#123; 0.f, 1.f &#125; &#125;,</div><div class="line"></div><div class="line">    &#123; &#123;  250,  -250 &#125;,  &#123; 1.f, 0.f &#125; &#125;,</div><div class="line">    &#123; &#123; -250,   250 &#125;,  &#123; 0.f, 1.f &#125; &#125;,</div><div class="line">    &#123; &#123;  250,   250 &#125;,  &#123; 1.f, 1.f &#125; &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// Create our vertex buffer, and initialize it with our quadVertices array</div><div class="line">_vertices = [_device newBufferWithBytes:quadVertices</div><div class="line">                                 length:sizeof(quadVertices)</div><div class="line">                                options:MTLResourceStorageModeShared];</div><div class="line"></div><div class="line"> // 通过将字节长度除以每个顶点的大小来计算顶点的数量</div><div class="line">_numVertices = sizeof(quadVertices) / sizeof(AAPLVertex);</div></pre></td></tr></table></figure>
<p>然后获得图片数据，根据图片数据来设置MTLTexture</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">NSURL *imageFileLocation = [[NSBundle mainBundle] URLForResource:@&quot;Image&quot;</div><div class="line">                                                   withExtension:@&quot;tga&quot;];</div><div class="line">AAPLImage * image = [[AAPLImage alloc] initWithTGAFileAtLocation:imageFileLocation];</div><div class="line">if(!image)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;Failed to create the image from %@&quot;, imageFileLocation.absoluteString);</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line">MTLTextureDescriptor *textureDescriptor = [[MTLTextureDescriptor alloc] init];</div><div class="line"></div><div class="line">//  表明每个像素都有一个蓝色，绿色，红色和alpha通道，每个通道都是一个8位无符号标准化值</div><div class="line">textureDescriptor.pixelFormat = MTLPixelFormatBGRA8Unorm;</div><div class="line"> //设置纹理的像素尺寸</div><div class="line">textureDescriptor.width = image.width;</div><div class="line">textureDescriptor.height = image.height;</div><div class="line">// 通过 descriptor 创建纹理对象</div><div class="line">_texture = [_device newTextureWithDescriptor:textureDescriptor];</div><div class="line">// Calculate the number of bytes per row of our image.</div><div class="line">NSUInteger bytesPerRow = 4 * image.width;</div><div class="line"></div><div class="line">//MTLRegion结构用于识别纹理的特定区域。 此示例使用图像数据填充整个纹理; 因此，覆盖整个纹理的像素区域等于纹理的尺寸</div><div class="line">MTLRegion region = &#123;</div><div class="line">    &#123; 0, 0, 0 &#125;,                   // MTLOrigin</div><div class="line">    &#123;image.width, image.height, 1&#125; // MTLSize</div><div class="line">&#125;;</div><div class="line">// 与存储多种自定义数据的MTLBuffer对象不同，MTLTexture对象专门用于存储格式化的图像数据。 尽管MTLTextureDescriptor对象指定足够的信息来分配纹理内存，但需要额外的信息来填充空纹理容器。 MTLTexture对象由replaceRegion：mipmapLevel：withBytes：bytesPerRow：方法填充图像数据。</div><div class="line">[_texture replaceRegion:region</div><div class="line">            mipmapLevel:0</div><div class="line">              withBytes:image.data.bytes</div><div class="line">            bytesPerRow:bytesPerRow];</div></pre></td></tr></table></figure>
<p>因为demo中给的是tga文件格式的图片，所以专门封装了一个类<code>AAPLImage</code>来处理图片。当然，我们也可以使用一下代码来获得texture</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">CGImageRef spriteImage = image.CGImage;</div><div class="line">// 1 读取图片的大小</div><div class="line">size_t width = CGImageGetWidth(spriteImage);</div><div class="line">size_t height = CGImageGetHeight(spriteImage);</div><div class="line">Byte * spriteData = (Byte *) calloc(width * height * 4, sizeof(Byte)); //rgba共4个byte</div><div class="line">CGContextRef spriteContext = CGBitmapContextCreate(spriteData, width, height, 8, width*4,</div><div class="line">                                                   CGImageGetColorSpace(spriteImage), kCGImageAlphaPremultipliedLast);</div><div class="line">    </div><div class="line">// 2 在CGContextRef上绘图</div><div class="line">CGContextDrawImage(spriteContext, CGRectMake(0, 0, width, height), spriteImage);</div><div class="line">CGContextRelease(spriteContext);</div><div class="line">    </div><div class="line">MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</div><div class="line">                                                                                             width:width</div><div class="line">                                                                                            height:height</div><div class="line">                                                                                         mipmapped:NO];</div><div class="line">textureDescriptor.usage = MTLTextureUsageShaderRead;</div><div class="line">id&lt;MTLTexture&gt; texture = [context.device newTextureWithDescriptor:textureDescriptor];</div><div class="line">    </div><div class="line">    </div><div class="line">MTLRegion region = &#123;&#123; 0, 0, 0 &#125;, &#123;image.size.width, image.size.height, 1&#125;&#125;; // 纹理上传的范围</div><div class="line">[texture replaceRegion:region mipmapLevel:0 withBytes:spriteData bytesPerRow:4 * image.size.width];</div><div class="line">free(spriteData);</div></pre></td></tr></table></figure>
<p>接下来就是初始化MTLRenderPipelineState及MTLCommandQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// Load all the shader files with a metal file extension in the project</div><div class="line">id&lt;MTLLibrary&gt; defaultLibrary = [_device newDefaultLibrary];</div><div class="line"></div><div class="line">// Load the vertex function from the library</div><div class="line">id&lt;MTLFunction&gt; vertexFunction = [defaultLibrary newFunctionWithName:@&quot;vertexShader&quot;];</div><div class="line"></div><div class="line">// Load the fragment function from the library</div><div class="line">id&lt;MTLFunction&gt; fragmentFunction = [defaultLibrary newFunctionWithName:@&quot;samplingShader&quot;];</div><div class="line"></div><div class="line">// Set up a descriptor for creating a pipeline state object</div><div class="line">MTLRenderPipelineDescriptor *pipelineStateDescriptor = [[MTLRenderPipelineDescriptor alloc] init];</div><div class="line">pipelineStateDescriptor.label = @&quot;Texturing Pipeline&quot;;</div><div class="line">pipelineStateDescriptor.vertexFunction = vertexFunction;</div><div class="line">pipelineStateDescriptor.fragmentFunction = fragmentFunction;</div><div class="line">pipelineStateDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat;</div><div class="line"></div><div class="line">NSError *error = NULL;</div><div class="line">_pipelineState = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor</div><div class="line">                                                         error:&amp;error];</div><div class="line"></div><div class="line">// Create the command queue</div><div class="line">_commandQueue = [_device newCommandQueue];</div></pre></td></tr></table></figure>
<p>最后就是绘制视图调用的<code>- (void)drawInMTKView:(nonnull MTKView *)view</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)drawInMTKView:(nonnull MTKView *)view</div><div class="line">&#123;</div><div class="line">    id&lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer];</div><div class="line">    commandBuffer.label = @&quot;MyCommand&quot;;</div><div class="line">    MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;</div><div class="line"></div><div class="line">    if(renderPassDescriptor != nil)</div><div class="line">    &#123;</div><div class="line">        // Create a render command encoder so we can render into something</div><div class="line">        id&lt;MTLRenderCommandEncoder&gt; renderEncoder =</div><div class="line">        [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];</div><div class="line">        renderEncoder.label = @&quot;MyRenderEncoder&quot;;</div><div class="line">        // 设置显示区域</div><div class="line">        [renderEncoder setViewport:(MTLViewport)&#123;0.0, 0.0, _viewportSize.x, _viewportSize.y, -1.0, 1.0 &#125;];</div><div class="line">        // 设置渲染管道，以保证顶点和片元两个shader会被调用</div><div class="line">        [renderEncoder setRenderPipelineState:_pipelineState];</div><div class="line">        // 设置顶点缓存</div><div class="line">        [renderEncoder setVertexBuffer:_vertices</div><div class="line">                                offset:0</div><div class="line">                              atIndex:AAPLVertexInputIndexVertices];</div><div class="line">        [renderEncoder setVertexBytes:&amp;_viewportSize</div><div class="line">                               length:sizeof(_viewportSize)</div><div class="line">                              atIndex:AAPLVertexInputIndexViewportSize];</div><div class="line">        // 设置纹理</div><div class="line">        [renderEncoder setFragmentTexture:_texture</div><div class="line">                                  atIndex:AAPLTextureIndexBaseColor];</div><div class="line">        // // 绘制</div><div class="line">        [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle</div><div class="line">                          vertexStart:0</div><div class="line">                          vertexCount:_numVertices];</div><div class="line">         // 结束</div><div class="line">        [renderEncoder endEncoding];</div><div class="line">        // 显示</div><div class="line">        [commandBuffer presentDrawable:view.currentDrawable];</div><div class="line">    &#125;   </div><div class="line">    // Finalize rendering here &amp; push the command buffer to the GPU</div><div class="line">    [commandBuffer commit];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个环节中:</p>
<ul>
<li>第一步是获取command buffer(命令缓冲区)。 所有进入GPU的工作将被排入此缓冲区。 我们需要前一阶段的command queue来创建一个command buffer(命令缓冲区)。</li>
<li>第二步是设置render pass(渲染通道)。 渲染通道描述符告诉Metal渲染图像时要执行的操作。 配置它需要我们指定我们渲染的颜色纹理。</li>
<li>第三步是实际drawing(绘制)。 我们指定存储顶点的缓冲区，然后指定我们需要绘制的基元。 第四步也是最后一步是commit the command buffer(提交命令缓冲区)给GPU。 调用commit时，command buffer会被编码，发送到命令队列的末尾，并在GPU运行时执行。</li>
</ul>
<p>最后附一张非常详细的流程图：</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_xuanranguocheng.jpg" alt="xuanran"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/" itemprop="url">
                  MLeaksFinder与FBRetainCycleDetector小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-12-15T19:54:38+08:00" content="2018-12-15">
              2018-12-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/" class="leancloud_visitors" data-flag-title="MLeaksFinder与FBRetainCycleDetector小结">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MLeaksFinder"><a href="#MLeaksFinder" class="headerlink" title="MLeaksFinder"></a>MLeaksFinder</h3><p>建议先仔细阅读<a href="http://wereadteam.github.io/2016/07/20/MLeaksFinder2/" target="_blank" rel="external">官方介绍</a>，很多原理性的东西原文档讲的很清楚，这里主要以几个问题来分析一下实现过程。<br>假如给你一个原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 </div><div class="line">UIViewController，它的 view，view 的 subviews 等等是否还存在</div></pre></td></tr></table></figure>
<p>你能想到怎么用代码实现这个功能呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (BOOL)willDealloc &#123;</div><div class="line">    __weak id weakSelf = self;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        [weakSelf assertNotDealloc];</div><div class="line">    &#125;);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line">- (void)assertNotDealloc &#123;</div><div class="line">     NSAssert(NO, @“”);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如何判断一个ViewController被pop或dismiss"><a href="#如何判断一个ViewController被pop或dismiss" class="headerlink" title="如何判断一个ViewController被pop或dismiss"></a>如何判断一个ViewController被pop或dismiss</h4><p>MLeaksFinder通过Runtime hook了<code>viewDidDisappear</code> 和 <code>viewWillAppear</code>方法，但是一个界面消失时，可能是被pop或dismiss了，也有可能是push了一个新的界面，push时当前页面也会调用<code>viewDidDisappear</code>方法。我们要做的是只有被pop或dismiss时，才去监测是否内存泄漏了。MLeaksFinder做法是这样的：</p>
<p>当<code>viewWillAppear</code>被调用时，通过<code>objc_setAssociatedObject</code>方法对ViewController添加一个标记属性值，当ViewController被pop时，获得这个ViewController并改变这个属性值。然后在<code>viewDidDisappear</code>判断一下这个属性值是否被改变了，假如改变了，则是被pop或dismiss了。见代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)swizzled_viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    [self swizzled_viewDidDisappear:animated];</div><div class="line">    </div><div class="line">    BOOL value = [objc_getAssociatedObject(self, kHasBeenPoppedKey) boolValue] ;</div><div class="line">    if (value) &#123;</div><div class="line">        [self willDealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)swizzled_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self swizzled_viewWillAppear:animated];</div><div class="line">    objc_setAssociatedObject(self, kHasBeenPoppedKey, @(NO), OBJC_ASSOCIATION_RETAIN);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">UIViewController *poppedViewController = [self swizzled_popViewControllerAnimated:animated];</div><div class="line"></div><div class="line">extern const void *const kHasBeenPoppedKey;</div><div class="line">    objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(YES), OBJC_ASSOCIATION_RETAIN);</div><div class="line">    </div><div class="line">    return poppedViewController;</div></pre></td></tr></table></figure>
<h4 id="如何构建视图层级信息"><a href="#如何构建视图层级信息" class="headerlink" title="如何构建视图层级信息"></a>如何构建视图层级信息</h4><p>假如一个ViewController的一个view没有释放，找出来这个view所属的层级。</p>
<p>首先先检测ViewController，然后将ViewController的className记录下来，然后遍历ViewController.view的时候，将ViewController的className的赋值给view，以及对ViewController.view.subviews循环遍历,添加弱引用指针前时，都通过赋值传递的方法，先将视图信息记录下来，赋值给这个对象。<code>objc_setAssociatedObject</code>方法将当前遍历的类名string添加到Array里面。假如发生了内存泄漏，通过<code>objc_getAssociatedObject</code>方法获得Array，即记录的视图层级信息.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)willReleaseChildren:(NSArray *)children &#123;</div><div class="line">    </div><div class="line">    NSArray *viewStack = [self viewStack];</div><div class="line">    NSSet *parentPtrs = [self parentPtrs];</div><div class="line">    // 遍历时，添加弱引用指针前，现将之前的视图信息赋值给将要检测的对象</div><div class="line">    for (id child in children) &#123;</div><div class="line">        NSString *className = NSStringFromClass([child class]);</div><div class="line">        [child setViewStack:[viewStack arrayByAddingObject:className]];</div><div class="line">        [child setParentPtrs:[parentPtrs setByAddingObject:@((uintptr_t)child)]];</div><div class="line">        [child willDealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 赋值视图层级信息</div><div class="line">- (NSArray *)viewStack &#123;</div><div class="line">    NSArray *viewStack = objc_getAssociatedObject(self, kViewStackKey);</div><div class="line">    if (viewStack) &#123;</div><div class="line">        return viewStack;</div><div class="line">    &#125;</div><div class="line">    NSString *className = NSStringFromClass([self class]);</div><div class="line">    return @[ className ];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获得视图层级信息</div><div class="line">- (void)setViewStack:(NSArray *)viewStack &#123;</div><div class="line">    NSLog(@&quot;setViewStack -- %@&quot;,NSStringFromClass([self class]));</div><div class="line">    objc_setAssociatedObject(self, kViewStackKey, viewStack, OBJC_ASSOCIATION_RETAIN);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如何判断属于释放不及时的情况"><a href="#如何判断属于释放不及时的情况" class="headerlink" title="如何判断属于释放不及时的情况"></a>如何判断属于释放不及时的情况</h4><p>原文中是这么描述的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，</div><div class="line">对于同一个类不断地报 Object Deallocated 和 Memory Leak。这种情况属于释放不及时的情况。</div></pre></td></tr></table></figure>
<p>意思就是该释放的时候没释放，但是过了一段时间，或触发了某个场景又释放了，这不算严格上的内存泄漏，属于释放不及时的情况，比如这种场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)push &#123;</div><div class="line">    SecViewController *controller = [[SecViewController alloc] init];</div><div class="line">    self.secController = controller;</div><div class="line">    [self.navigationController pushViewController: controller animated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从当前界面push到SecViewController界面，但是当前界面持有SecViewController对象的强引用，所以SecViewController pop时，SecViewController对象时不会释放的，只有当前界面释放了，SecViewController对象才释放。</p>
<p>检测这种情况的方法，也是使用了<code>objc_setAssociatedObject</code>方法。当一个对象发生内存泄漏时，使用<code>objc_setAssociatedObject</code>为该对象添加一个标记对象MLeakedObjectProxy，MLeakedObjectProxy持有这个泄漏对象的弱引用，这样当泄漏的对象释放时，会清除自身关联的AssociatedObject，关联对象MLeakedObjectProxy此时释放，所以关联对象释放的时机即是内存泄漏对象delloc的时机，这个时候会弹一个Object Deallocated的alertView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+ (void)addLeakedObject:(id)object &#123;</div><div class="line">    NSAssert([NSThread isMainThread], @&quot;Must be in main thread.&quot;);</div><div class="line">    </div><div class="line">    MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] init];</div><div class="line">    proxy.object = object;</div><div class="line">    proxy.objectPtr = @((uintptr_t)object);</div><div class="line">    proxy.viewStack = [object viewStack];</div><div class="line">    static const void *const kLeakedObjectProxyKey = &amp;kLeakedObjectProxyKey;</div><div class="line">    objc_setAssociatedObject(object, kLeakedObjectProxyKey, proxy, OBJC_ASSOCIATION_RETAIN);</div><div class="line">    </div><div class="line">    [leakedObjectPtrs addObject:proxy.objectPtr];</div><div class="line">    </div><div class="line">    [MLeaksMessenger alertWithTitle:@&quot;Memory Leak&quot;</div><div class="line">                            message:[NSString stringWithFormat:@&quot;%@&quot;, proxy.viewStack]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSNumber *objectPtr = _objectPtr;</div><div class="line">    NSArray *viewStack = _viewStack;</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [leakedObjectPtrs removeObject:objectPtr];</div><div class="line">        [MLeaksMessenger alertWithTitle:@&quot;Object Deallocated&quot;</div><div class="line">                                message:[NSString stringWithFormat:@&quot;%@&quot;, viewStack]];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="FBRetainCycleDetector"><a href="#FBRetainCycleDetector" class="headerlink" title="FBRetainCycleDetector"></a>FBRetainCycleDetector</h3><p>MLeaksFinder的作用是找出来没有释放的对象，但是要找出哪个对象强引用着这个未释放的对象、哪几个对象造成了循环引用，还要靠<a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="external">FBRetainCycleDetector</a>。它的原理是获得要检查对象的所有强引用对象，按照深入优先搜索的方法遍历所有强引用对象，假如在遍历的过程中又遍历到了自己，表明发生了循环引用，然后输出日志。</p>
<p><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/MLeaksFinder_Cycle.jpg" alt="循环引用"></p>
<p>如上图，搜索过程中 object1 -&gt; object4 -&gt; object6 -&gt; object1 ，造成了循环引用，控制台会输出这些信息。</p>
<p>FB中关于寻找一个对象的所有强引用属性，比如上图中的object1,找出它的所有strong类型的属性：object2,object3,object4以及关联对象，这个过程值得我们去深究，复习下Runtime及Block底层知识。</p>
<p>FBRetainCycleDetector中将需要检查的类型分成了三类，分别是NSObject类型，NSTimer类型，Block类型，对每种类型分别包装成了FBObjectiveCObject，FBObjectiveCNSCFTimer，FBObjectiveCBlock。<br>判断一个对象是否是NSTimer类型非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object_getClass(object) isSubclassOfClass:[NSTimer class]]</div></pre></td></tr></table></figure>
<p>判断一个对象是否是Block的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static Class _BlockClass() &#123;</div><div class="line">  static dispatch_once_t onceToken;</div><div class="line">  static Class blockClass;</div><div class="line">  dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">      void (^testBlock)(void) = [^&#123;&#125; copy];</div><div class="line">    blockClass = [testBlock class];</div><div class="line">    while(class_getSuperclass(blockClass) &amp;&amp; class_getSuperclass(blockClass) != [NSObject class]) &#123;</div><div class="line">      blockClass = class_getSuperclass(blockClass);</div><div class="line">    &#125;</div><div class="line">    [testBlock release];</div><div class="line">  &#125;);</div><div class="line">  return blockClass;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL FBObjectIsBlock(void *object) &#123;</div><div class="line">  Class blockClass = _BlockClass();</div><div class="line">  Class candidate = object_getClass((__bridge id)object);</div><div class="line">  return [candidate isSubclassOfClass:blockClass];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取通过关联对象方式添加的属性"><a href="#获取通过关联对象方式添加的属性" class="headerlink" title="获取通过关联对象方式添加的属性"></a>获取通过关联对象方式添加的属性</h4><p>FBObjectiveCObject，FBObjectiveCNSCFTimer，FBObjectiveCBlock这三个类有一个共同父类FBObjectiveCGraphElement，共用父类的方法<code>- (NSSet *)allRetainedObjects</code>，这个方法用来获得通过<code>objc_setAssociatedObject</code>方法添加的属性。</p>
<p>FBRetainCycleDetector 使用了 <a href="https://github.com/facebook/fishhook" target="_blank" rel="external">fishhook</a> hook了 <code>objc_setAssociatedObject</code> 和 <code>objc_removeAssociatedObjects</code> 方法，在FBAssociationManager类里维护了一个存储关联对象信息的Map, 这样的话通过关联对象的方式添加属性，就能被捕捉到，然后操作维护的Map。这样就能获得一个对象，通过关联对象方式添加强引用属性的所有信息了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface FBAssociationManager : NSObject</div><div class="line"></div><div class="line">+ (void)hook;</div><div class="line"></div><div class="line">+ (void)unhook;</div><div class="line"></div><div class="line">+ (nullable NSArray *)associationsForObject:(nullable id)object;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="对于NSObject类型"><a href="#对于NSObject类型" class="headerlink" title="对于NSObject类型"></a>对于NSObject类型</h4><p>对于通过@property方式添加的属性，在Runtime层面来说，内部都会有一个IvarList存放着实例变量列表。有的人可能会想，不是有api：<code>class_getIvarLayout</code>、<code>class_getWeakIvarLayout</code>可以直接获得strong类型的实例变量和weak类型的实例变量吗？其实不然，ivarLayout和weakIvarLayout存放的只是强ivar和弱ivar的存储规则，并不是真正的实例变量，具体可以看<a href="https://www.jianshu.com/p/6b218d12caae" target="_blank" rel="external">这篇文章</a>。</p>
<p>但是我们可以根据ivarLayout这个存储规则找出强ivar的所在的index,再通过<code>class_copyIvarList</code>获取所有的ivar, 这样就找出了这个对象的强ivar。有了这个强ivar后再通过<code>object_getIvar</code>获得ivar对应的值，从而达成了目的。核心代码主要在FBClassStrongLayout类里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">static NSArray&lt;id&lt;FBObjectReference&gt;&gt; *FBGetStrongReferencesForClass(Class aCls) &#123;</div><div class="line">//    class的引用所有的引用(iVarList)，包括强引用和弱引用</div><div class="line">  NSArray&lt;id&lt;FBObjectReference&gt;&gt; *ivars = [FBGetClassReferences(aCls) filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) &#123;</div><div class="line">    if ([evaluatedObject isKindOfClass:[FBIvarReference class]]) &#123;</div><div class="line">      FBIvarReference *wrapper = evaluatedObject;</div><div class="line">      return wrapper.type != FBUnknownType;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">  &#125;]];</div><div class="line"></div><div class="line">    // 获取属性为strong或copy在内存中的存储规则，结果可能为nil</div><div class="line">  const uint8_t *fullLayout = class_getIvarLayout(aCls);</div><div class="line">  if (!fullLayout) &#123;</div><div class="line">    return nil;</div><div class="line">  &#125;</div><div class="line">    NSLog(@&quot;%@ fullLayout:\n%s&quot;,NSStringFromClass(aCls),fullLayout);</div><div class="line">//获取ivar的最小index</div><div class="line">  NSUInteger minimumIndex = FBGetMinimumIvarIndex(aCls);</div><div class="line">//获取强引用的index区间。 https://www.jianshu.com/p/89ac27684693</div><div class="line">  NSIndexSet *parsedLayout = FBGetLayoutAsIndexesForDescription(minimumIndex, fullLayout);</div><div class="line"></div><div class="line">  NSArray&lt;id&lt;FBObjectReference&gt;&gt; *filteredIvars =</div><div class="line">  [ivars filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id&lt;FBObjectReference&gt; evaluatedObject,</div><div class="line">                                                                           NSDictionary *bindings) &#123;</div><div class="line">    return [parsedLayout containsIndex:[evaluatedObject indexInIvarLayout]];</div><div class="line">  &#125;]];</div><div class="line"></div><div class="line">  return filteredIvars;</div><div class="line">&#125;</div><div class="line">NSArray&lt;id&lt;FBObjectReference&gt;&gt; *FBGetObjectStrongReferences(id obj,</div><div class="line">                                                            NSMutableDictionary&lt;Class, NSArray&lt;id&lt;FBObjectReference&gt;&gt; *&gt; *layoutCache) &#123;</div><div class="line">  NSMutableArray&lt;id&lt;FBObjectReference&gt;&gt; *array = [NSMutableArray new];</div><div class="line"></div><div class="line">  __unsafe_unretained Class previousClass = nil;</div><div class="line">  __unsafe_unretained Class currentClass = object_getClass(obj);</div><div class="line"></div><div class="line">  while (previousClass != currentClass) &#123;</div><div class="line">    NSArray&lt;id&lt;FBObjectReference&gt;&gt; *ivars;</div><div class="line">    </div><div class="line">    if (layoutCache &amp;&amp; currentClass) &#123;</div><div class="line">      ivars = layoutCache[currentClass];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!ivars) &#123;</div><div class="line">      ivars = FBGetStrongReferencesForClass(currentClass);</div><div class="line">      if (layoutCache &amp;&amp; currentClass) &#123;</div><div class="line">        layoutCache[currentClass] = ivars;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    [array addObjectsFromArray:ivars];</div><div class="line"></div><div class="line">    previousClass = currentClass;</div><div class="line">    currentClass = class_getSuperclass(currentClass);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return [array copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 简略流程图为：</p>
<p><img src="http://ww1.sinaimg.cn/mw690/006OKvcNly1fy5f0i5pfzj30q80j0dgu.jpg" alt="循环引用"></p>
<h4 id="对于Block类型"><a href="#对于Block类型" class="headerlink" title="对于Block类型"></a>对于Block类型</h4><p>首先要了解Block的结构是什么，假如引用了对象，这部分的对象存在哪里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct BlockDescriptor &#123;</div><div class="line">  unsigned long int reserved;                // NULL</div><div class="line">  unsigned long int size;</div><div class="line">  // optional helper functions</div><div class="line">  void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25)</div><div class="line">  void (*dispose_helper)(void *src);         // IFF (1&lt;&lt;25)</div><div class="line">  const char *signature;                     // IFF (1&lt;&lt;30)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct BlockLiteral &#123;</div><div class="line">  void *isa;  // initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</div><div class="line">  int flags;</div><div class="line">  int reserved;</div><div class="line">  void (*invoke)(void *, ...);</div><div class="line">  struct BlockDescriptor *descriptor;</div><div class="line">  // imported variables</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>FB中将传入的Blok强转成了BlockLiteral类型的结构体，对于BlockLiteral这个结构体进行操作。</p>
<p>其实最重要的理解dispose_helper这个函数的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispose_helper 向所有捕获的变量发送release消息，对弱引用不会做任何的处理</div></pre></td></tr></table></figure>
<p>我们可以先存一份<code>dispose_helper</code>调用之前的数据，然后调用<code>dispose_helper</code>函数，对比调用后的数据，就能得出所强引用的函数。<br>FBBlockStrongRelationDetector 为<code>dispose_helper</code>的消息接收类，复写了release函数。它的实例在接受release消息时，并不会真正的释放，只会将标记_strong 为YES，<br>只有真正执行<code>trueRelease</code> 的时候才会向对象发送 release 消息。更多详细的信息见<a href="https://github.com/draveness/analyze/blob/master/contents/FBRetainCycleDetector/iOS%20中的%20block%20是如何持有对象的.md" target="_blank" rel="external">这篇文章</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (oneway void)release</div><div class="line">&#123;</div><div class="line">  _strong = YES;</div><div class="line">&#125;</div><div class="line">- (oneway void)trueRelease</div><div class="line">&#123;</div><div class="line">  [super release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_GetBlockStrongLayout</code>核心代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//    获得dispose_helper函数</div><div class="line">  void (*dispose_helper)(void *src) = blockLiteral-&gt;descriptor-&gt;dispose_helper;</div><div class="line">  const size_t ptrSize = sizeof(void *);</div><div class="line"></div><div class="line">  // Figure out the number of pointers it takes to fill out the object, rounding up.</div><div class="line">//    获取 block 持有的指针的数量</div><div class="line">  const size_t elements = (blockLiteral-&gt;descriptor-&gt;size + ptrSize - 1) / ptrSize;</div><div class="line"></div><div class="line">  // Create a fake object of the appropriate length.</div><div class="line">  void *obj[elements];</div><div class="line">  void *detectors[elements];</div><div class="line"></div><div class="line">  for (size_t i = 0; i &lt; elements; ++i) &#123;</div><div class="line">    FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector new];</div><div class="line">    obj[i] = detectors[i] = detector;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @autoreleasepool &#123;</div><div class="line">    dispose_helper(obj);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Run through the release detectors and add each one that got released to the object&apos;s</div><div class="line">  // strong ivar layout.</div><div class="line">  NSMutableIndexSet *layout = [NSMutableIndexSet indexSet];</div><div class="line"></div><div class="line">  for (size_t i = 0; i &lt; elements; ++i) &#123;</div><div class="line">    FBBlockStrongRelationDetector *detector = (FBBlockStrongRelationDetector *)(detectors[i]);</div><div class="line">    if (detector.isStrong) &#123;</div><div class="line">      [layout addIndex:i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Destroy detectors</div><div class="line">    [detector trueRelease];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return layout;</div></pre></td></tr></table></figure>
<h4 id="对于NSTimer类型"><a href="#对于NSTimer类型" class="headerlink" title="对于NSTimer类型"></a>对于NSTimer类型</h4><p>通过<code>CFRunLoopTimerGetContext</code>获得timer的详细信息，包括target</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_FBNSCFTimerInfoStruct infoStruct = *(_FBNSCFTimerInfoStruct *)(context.info);</div><div class="line"></div><div class="line">typedef struct &#123;</div><div class="line">  long _unknown; // This is always 1</div><div class="line">  id target;</div><div class="line">  SEL selector;</div><div class="line">  NSDictionary *userInfo;</div><div class="line">&#125; _FBNSCFTimerInfoStruct;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>阅读优秀的开源框架能够学习很深层次的知识点，以及如何正确使用这些知识。比如MLeaksFinder中大量使用了<code>objc_setAssociatedObject</code>来实现想要的功能。再比如即使我们知道了Block的数据结构，那么能用这些知识来实现什么功能呢，FBRetainCycleDetector中使用了Block中的<code>dispose_helper</code>函数来筛选引用到的对象，使用了fishhook来hook Runtime层面的api。你知道了消息转发的过程和原理，假如你去阅读<a href="https://github.com/steipete/Aspects" target="_blank" rel="external">Aspects</a>源码的话，就会更加了解如何去用正确使用消息转发，并且惊叹消息转发用处原来这么强大。优秀的人无处不在，所以不仅仅是自己研究，也要多汲取别人的思路想法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/02/平凡的世界/" itemprop="url">
                  《平凡的世界》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-10-02T09:54:10+08:00" content="2018-10-02">
              2018-10-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/读书与感悟/" itemprop="url" rel="index">
                    <span itemprop="name">读书与感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/02/平凡的世界/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/02/平凡的世界/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/10/02/平凡的世界/" class="leancloud_visitors" data-flag-title="《平凡的世界》">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>《平凡的世界》记录的是一九七四年至一九八四年，十年间以乡下的一个小村庄双水村的变化，反映了中国快速发展的面貌。我大部分都是在晚上读这本小说，花了三个多月的时间读完了这本书，共三部。书中一些情节，人物的刻画，故事的发展，以及作者对人生的思考，都给了我很大的帮助，以至于现在有一种想读第二遍的冲动。所以，我觉得我有必要写一些东西记录下我读后的感悟。</p>
<h3 id="关于爱情与婚姻"><a href="#关于爱情与婚姻" class="headerlink" title="关于爱情与婚姻"></a>关于爱情与婚姻</h3><p>书中关于爱情的情节，有两条线，一条是孙少安与田润叶，一条是孙少平与田晓霞。他们双方都深爱着对方，但最后都没能走到一起。前者是因为孙少安是社会最底层的农民，觉得自己配不上干部家庭及文化高的田润叶，后者是因为田晓霞因为在洪水中救人而牺牲了。哎，很可惜，特别是孙少平与田晓霞，它们俩一开始就互相帮助对方，本以为它们会走到最后，没想到…</p>
<p>《阿甘正传》里有一句台词：人生就像一盒巧克力，你永远无法知道下一颗是什么滋味。在青涩的年纪，就像爱情一样，你也无法知道最后陪伴你一生的那个人是谁，人生总是充满了插曲。两个人在一起爱情和婚姻是不同的，爱情的可以轰轰烈烈，但婚姻平平淡淡最好。每个人都会有青涩的初恋，刻骨的爱情，但爱情的尽头呢？会是婚姻吗？在过程中会有各种阻隔让你们分开，你们或许让对方尝到了爱情的滋味，但未必给的了婚姻的幸福，一生的呵护。</p>
<h3 id="对于苦难"><a href="#对于苦难" class="headerlink" title="对于苦难"></a>对于苦难</h3><p>记忆最深刻的就是孙少平不想永远呆在小山村，想出去闯荡，于是一个人去煤矿打工，受了很多苦。书中是这样描述这一经历的，原文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">有文化，但是没有幸运的进入大学或参加工作，因此似乎没有充分的条件直接参与到目前社会发展的主潮之</div><div class="line">中，而另一方面，他们往往又不甘心，把自己局限在狭小生活的天地里。因此，他们带着一种悲壮的激情，在</div><div class="line">一条最为艰难的道路上进行人生的搏斗。他们顾不得高谈论阔，或愤世嫉俗的忧患人类的命运。他们首先得改</div><div class="line">变自己的生存条件，同时也不放弃最主要的精神追求。他们既不鄙视普通人的世俗生活，但又竭力使自己对生</div><div class="line">活的认识达到更深的层次。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">是的，他是在社会最底层挣扎，为了几个钱而受尽折磨，但他已不仅仅将此看做是谋生活命——职业的高低贵</div><div class="line">贱，不能说明一个人的价值。恰恰相反，他现在倒很“热爱”自己的苦难。通过这一段血火般的洗礼，他相信，</div><div class="line">自己历经千辛万苦而酿造出的生活之蜜，肯定比轻而易举拿来的更有滋味。</div></pre></td></tr></table></figure>
<p>苦难是对自己的磨难，在磨难中，在压力中你才能更加快速的成长。苦难过后，你再看看自己曾经走过的路，你会感谢他们，正是因为他们，你才有了许多人生的感悟，人生的道理，而这些是别人不能给你的，只能自己去经历，自己去体会。</p>
<p>很遗憾，直到书的结尾，孙少平还在经历苦难的磨炼。但我相信，他会创出自己的天地，走向更广阔的天空。</p>
<h3 id="要有一颗不屈于现状的心"><a href="#要有一颗不屈于现状的心" class="headerlink" title="要有一颗不屈于现状的心"></a>要有一颗不屈于现状的心</h3><p>孙少安虽然在农村老家勤恳务农，但他却觉得一直这样的话，无疑是在走父辈的老路。所以就有了开砖厂的想法，第一次由于经营不善，用人不善倒闭了。过了一年，重整旗鼓，吸取教训，最后终于办的有模有样，成了家乡的富翁。</p>
<p>孙少平从上高中开始就有读书的习惯，通过阅报一直在关注世界各地的发展形势，所以就有了一个不安分的心，想要到外面闯荡。所以后来独自一人去了煤矿，得到了一份令人羡慕不已的工作。</p>
<p>书中也反映了现实中的道理，有一句话，“比你优秀的人比你更努力”，假如觉得现在的生活可以了，不想再奋斗了，但是别人都在朝着自己的目标努力，若干时间后，你还会这样想吗？</p>
<h3 id="风雨过后就是彩虹"><a href="#风雨过后就是彩虹" class="headerlink" title="风雨过后就是彩虹"></a>风雨过后就是彩虹</h3><p>社会总是在不断发展的，美好的事物总会来临，就像中国这几十年来的发展一样，一天比一天好。不管怎样，属于你的终究是属于你的。不要抱有太多的悲观情绪，可以对比下自己，把现在的自己和一年前的自己，五年前的自己比比，是不是成长了许多。所以，奋斗吧骚年，风雨过后就是彩虹！！！</p>
<p>(软文一篇 😝)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/30/NSNotificationCenter防Crash守护/" itemprop="url">
                  NSNotificationCenter防Crash守护
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-30T15:08:47+08:00" content="2018-08-30">
              2018-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/30/NSNotificationCenter防Crash守护/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/30/NSNotificationCenter防Crash守护/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/08/30/NSNotificationCenter防Crash守护/" class="leancloud_visitors" data-flag-title="NSNotificationCenter防Crash守护">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于NSNotificationCenter，使用不当会造成Crash错误，比如没有在dealloc中removeObserver，或者在分线程中进行接收、发送通知等等。</p>
<ul>
<li>注：在iOS 9.0 或 macOS 10.11 以后，不需要在dealloc中调用removeObserver方法了,见<a href="https://developer.apple.com/documentation/foundation/nsnotificationcenter/1413994-removeobserver?language=objc" target="_blank" rel="external">官方文档</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">If your app targets iOS 9.0 and later or macOS 10.11 and later, you don&apos;t need to unregister an observer</div><div class="line"> in its dealloc method. Otherwise, you should call this method or removeObserver:name:object: before </div><div class="line"> observer or any object specified in addObserverForName:object:queue:usingBlock: or </div><div class="line"> addObserver:selector:name:object: is deallocated.</div></pre></td></tr></table></figure>
<p>当向通知中心注册的时候，NSNotificationCenter不会对observer强引用，在iOS 9.0以前，会持有一个<code>__unsafe_unretained</code>的指针，假如observer释放了，指针不会置为nil，变成不安全的指针。而在iOS 9.0及以后，使用<code>weak</code>修饰指针，解决了这个问题。详细见<a href="https://developer.apple.com/library/archive/releasenotes/Foundation/RN-FoundationOlderNotes/index.html#X10_11Notes" target="_blank" rel="external">官方更新说明</a>中关于NSNotificationCenter部分。</p>
<p>虽然不用移除了。但是探讨如何在dealloc方法中实现自动removeObserver还是有好处的。</p>
<h3 id="Swillze-dealloc-方法"><a href="#Swillze-dealloc-方法" class="headerlink" title="Swillze dealloc 方法"></a>Swillze dealloc 方法</h3><p>既然需要在dealloc方法中调用removeObserver方法，那么我们Swillze dealloc不就好了吗，在交换的dealloc方法里调用removeObserver。那么又有了一个问题，我们hook的dealloc方法是所有对象的dealloc，即所有对象的dealloc方法都会走我们自己的交换方法，怎么判定这个对象被注册到通知中心了呢？</p>
<p>所以，也需要hook <code>- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject</code> 这个方法，在hook方法里使用Rumtime AssociatedObject为observer添加一个标记。然后在自己的dealloc方法里通过判断是否有标记，来移除observer。</p>
<p>分析：<br>dealloc方法算是在整个项目里调用最频繁的方法之一了，hook dealloc方法感觉有点得不偿失，对性能有点影响。所以，我对这个 Swillze dealloc方法没有具体写代码去实现。</p>
<h3 id="AssociatedObject-Weak"><a href="#AssociatedObject-Weak" class="headerlink" title="AssociatedObject + Weak"></a>AssociatedObject + Weak</h3><p>我们先来看看dealloc底层都实现了什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void *objc_destructInstance(id obj) </div><div class="line">&#123;</div><div class="line">    if (obj) &#123;</div><div class="line">        // Read all of the flags at once for performance.</div><div class="line">        bool cxx = obj-&gt;hasCxxDtor();</div><div class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</div><div class="line"></div><div class="line">        // This order is important.</div><div class="line">        if (cxx) object_cxxDestruct(obj);</div><div class="line">        if (assoc) _object_remove_assocations(obj);</div><div class="line">        obj-&gt;clearDeallocating();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中有重要的两步，就是释放关联对象及弱引用，这个自动removeObserver就是用这两个知识点实现的。</p>
<p>当向通知中心注册的时候，用AssociatedObject为observer添加一个属性标记，这里使用的是分类的方式添加的，对NSObject添加一个分类，在分类里添加一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface NSObject (Tag)</div><div class="line">@property (nonatomic, strong) ZJNotificationTag *tag;</div><div class="line">@end</div><div class="line"></div><div class="line">static void *NSObject_ZJTag_Key = &amp;NSObject_ZJTag_Key;</div><div class="line"></div><div class="line">@implementation NSObject (ZJTag)</div><div class="line"></div><div class="line">- (void)setTag:(ZJNotificationTag *)tag &#123;</div><div class="line">    objc_setAssociatedObject(self, NSObject_ZJTag_Key, tag, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(ZJNotificationTag *)tag &#123;</div><div class="line">    return (ZJNotificationTag *)objc_getAssociatedObject(self, NSObject_ZJTag_Key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>ZJNotificationTag是自定义的，继承自NSObject的子类，持有observer的弱引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@interface ZJNotificationTag: NSObject</div><div class="line">@property (nonatomic, weak) id observer;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZJNotificationTag</div><div class="line"></div><div class="line">- (void)setObserver:(id)observer &#123;</div><div class="line">    _observer = observer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self.observer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>思路就是当observer释放，即dealloc的时候，dealloc内部会清除与之相关联的对象，即上述代码中的<code>tag</code>对象，而tag对象弱引用observer，所以不会产生循环引用，所以在tag对象的dealloc方法里，通过<code>tag.observer</code>得到了observer对象，从而将observer对象从通知中心移除。</p>
<p>下面简述一下实现过程中遇到的问题：</p>
<h4 id="保证observer对象只调用一次remove方法"><a href="#保证observer对象只调用一次remove方法" class="headerlink" title="保证observer对象只调用一次remove方法"></a>保证observer对象只调用一次remove方法</h4><p>假如在ViewController里同时注册多个不同通知，那么在dealloc里也只需移除一次。所以在添加标记时，先判断一下是否已经添加了标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSObject *_observer = (NSObject *)observer;</div><div class="line">if(!_observer.tag)&#123;</div><div class="line">    ZJNotificationTag *tag = [[ZJNotificationTag alloc] init];</div><div class="line">    _observer.tag = tag;</div><div class="line">    tag.observer = _observer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="保证不会重复注册observer"><a href="#保证不会重复注册observer" class="headerlink" title="保证不会重复注册observer"></a>保证不会重复注册observer</h4><p>对于同一个通知，即<code>NSNotificationName</code>相同的通知，如果重复注册，就会重复收到回调方法，在这里我维护了一个NSMutableDictionary，来处理这种由于不小心可能造成的bug：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary &lt;NSString*, NSHashTable*&gt;*_dic;</div></pre></td></tr></table></figure>
<p>key为<code>NSNotificationName</code>，value为<code>NSHashTable</code>，即能实现对内部对象弱引用的Set，当addObserver时先判断是否已经存在了，如果存在，即证明已经注册过了，直接返回，不再调用addObserver方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSHashTable *hashTable = [_dic objectForKey:name];</div><div class="line">if(!hashTable) &#123;</div><div class="line">    hashTable = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];</div><div class="line">    [self _addObserver:observer selector:selector name:name object:object hashTable:hashTable];</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">    if(![hashTable containsObject:observer]) &#123;</div><div class="line">        [self _addObserver:observer selector:selector name:name object:object hashTable:hashTable];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">[_dic setObject:hashTable forKey:name];</div></pre></td></tr></table></figure>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>注册observer、添加标记、添加对象到hashTable等操作方法都加了锁，保证线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_init(&amp;_lock, NULL);</div><div class="line"></div><div class="line">pthread_mutex_lock(&amp;_lock);</div><div class="line"></div><div class="line">pthread_mutex_unlock(&amp;_lock);</div></pre></td></tr></table></figure>
<p>在发送通知时，为了防止多线程可能引起的问题，在这里统一在主线程发出通知，这样的话，就保证了接收通知时一定在主线程，见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/NotificationCenters.html#//apple_ref/doc/uid/20000216-111349" target="_blank" rel="external">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In a multithreaded application, notifications are always delivered in the thread in which the </div><div class="line">notification was posted, which may not be the same thread in which an observer registered itself.</div></pre></td></tr></table></figure>
<p>借鉴了SDWebImage的做法(站在巨人的肩膀上😝)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)postNotificationName:(NSString *)name object:(id)object &#123;</div><div class="line">    </div><div class="line">    dispatch_main_async_safe(^&#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:name object:object];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在ViewController中添加监听的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[ZJNotificationCenter defaultCenter] addObserver:self selector:@selector(didReceiveNotification) name:@&quot;TestNotificationName&quot; object:nil];</div></pre></td></tr></table></figure>
<p>发送通知的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[ZJNotificationCenter defaultCenter] postNotificationName:@&quot;TestNotificationName&quot; object:nil];</div></pre></td></tr></table></figure>
<p>本文研究如何实现自动removeObserver，只是想到了这一个思路，文中的代码并未在正式环境中使用，如果错误，请指正。</p>
<p>代码已传至<a href="https://github.com/coderZhou10496/NotificationDemo" target="_blank" rel="external">Github</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/zhoujian_headerImage.jpeg"
               alt="Zhou Jian" />
          <p class="site-author-name" itemprop="name">Zhou Jian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coderZhou10496" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"coderzhou"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Bw40KBIPanRkt0iqTr7NLT6I-gzGzoHsz", "MQjFPSYkEazqnUv2rS7TOsui");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
