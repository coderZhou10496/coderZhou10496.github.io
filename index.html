<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Sky的博客">
<meta property="og:url" content="http://coderzhou.com/index.html">
<meta property="og:site_name" content="Sky的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sky的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coderzhou.com/"/>

  <title> Sky的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sky的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一枚小小的程序猿，专注于iOS开发</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/29/自定义转场动画/" itemprop="url">
                  自定义转场动画
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-29T21:02:39+08:00" content="2017-04-29">
              2017-04-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/29/自定义转场动画/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/29/自定义转场动画/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/04/29/自定义转场动画/" class="leancloud_visitors" data-flag-title="自定义转场动画">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近详细学习了关于转场动画的知识，通过一些API可以帮助我们实现炫酷的转场动画，先直接上Demo:<a href="https://github.com/coderZhou10496/TransitionDemo" target="_blank" rel="external">Github地址</a>，下面的转场动画都是自定义的动画</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB.gif" alt="image"></p>
<p>先来了解一下转场动画所需要的几个protocol</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/TransitionPic.png" alt="image"></p>
<p>我们一一简单了解下这些类是干嘛用的：</p>
<blockquote>
<p><code>UINavigationControllerDelegate</code></p>
</blockquote>
<p>这个delegate主要有一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                   animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                                fromViewController:(UIViewController *)fromVC</div><div class="line">                                                  toViewController:(UIViewController *)toVC</div></pre></td></tr></table></figure></p>
<p>自定义 push pop 动画时要实现这个方法，这个方法需要我们提供一个实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象。</p>
<blockquote>
<p><code>UIViewControllerTransitioningDelegate</code></p>
</blockquote>
<p>这个delegate 用于实现自定义的 present diss 动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:</div><div class="line">(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</div></pre></td></tr></table></figure>
<p>这个方法也需要我们提供一个实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象。</p>
<blockquote>
<p><code>UIViewControllerInteractiveTransitioning</code></p>
</blockquote>
<p>这个protocol是跟手势交互相关的。比如需要通过手势来返回到上一界面，就要返回实现了这个protocol的对象</p>
<blockquote>
<p><code>UIViewControllerAnimatedTransitioning</code> </p>
</blockquote>
<p> 这个protocol就是用于实现动画效果的protocol了，其中有两个必须实现的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</div><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</div></pre></td></tr></table></figure>
<p>第一个方法返回动画所需要的时间，第二个方法就是动画的具体实现</p>
<blockquote>
<p><code>UIViewControllerContextTransitioning</code></p>
</blockquote>
<p>这个protocol提供我们动画的具体实现所需要的元素，比如这些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)viewControllerForKey:(UITransitionContextViewControllerKey)</div><div class="line">- ( UIView *)viewForKey:(UITransitionContextViewKey)</div><div class="line">- (UIView *)containerView</div></pre></td></tr></table></figure>
<p>通过 UITransitionContextViewControllerKey 获得 动画所需要的 fromVc toVc，通过UITransitionContextViewKey 获得 动画所需要的 fromView toView 等等。</p>
<p>接下来就是实战了，主要是对一系列过程的封装。我采用了类别的方式，对 UINavigationController 增加了一个属性，即 push 的动画方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger,ZJNavigationTransitioningStyle)&#123;</div><div class="line">    ZJNavigationTransitioningStyleSystem,</div><div class="line">    ZJNavigationTransitioningStyleRound,</div><div class="line">    ZJNavigationTransitioningStyleScale,</div><div class="line">    ZJNavigationTransitioningStyleLeftSunken,</div><div class="line">    ZJNavigationTransitioningStyleRotate</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface UINavigationController (ZJTransitioning)</div><div class="line">@property (nonatomic,assign) ZJNavigationTransitioningStyle transitioningStyle;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当我们 push 的时候 ，只需为这个属性赋值就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ResultViewController *controller = [[ResultViewController alloc] init];</div><div class="line">self.navigationController.transitioningStyle = ZJNavigationTransitioningStyleSystem;</div><div class="line">[self.navigationController pushViewController:controller animated:YES];</div></pre></td></tr></table></figure>
<p>下面我们对其中一种动画方式 ZJNavigationTransitioningStyleScale ，详细描述实现过程 </p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/scale.gif" alt="image"></p>
<p>在 UINavigationController (ZJTransitioning) 这个类别的 .m 实现文件中，我们将 UINavigationController 的 delegate 方法用 ZJNavigationDelegateMediator 这个类来接收，意思就是 <code>@protocol UINavigationControllerDelegate &lt;NSObject&gt;</code>里的方法，在 ZJNavigationDelegateMediator 类里面来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">-(void)viewDidLoad</div><div class="line">&#123;</div><div class="line">//    将delegate 设置为 ZJNavigationDelegateMediator 对象，在 ZJNavigationDelegateMediator 类里实现</div><div class="line">//    UINavigationControllerDelegate的方法</div><div class="line">    self.delegate = self.mediator;</div><div class="line">&#125;</div><div class="line">-(ZJNavigationTransitioningStyle)transitioningStyle</div><div class="line">&#123;</div><div class="line">    return self.mediator.transitioningStyle;</div><div class="line">&#125;</div><div class="line">-(void)setTransitioningStyle:(ZJNavigationTransitioningStyle)transitioningStyle</div><div class="line">&#123;</div><div class="line">    self.mediator.transitioningStyle = transitioningStyle;</div><div class="line">&#125;</div><div class="line">-(ZJNavigationDelegateMediator *)mediator</div><div class="line">&#123;</div><div class="line">    ZJNavigationDelegateMediator *mediator = objc_getAssociatedObject(self, &amp;ZJTransitioningMediator_key);</div><div class="line">    if(mediator == nil)</div><div class="line">    &#123;</div><div class="line">        mediator = [[ZJNavigationDelegateMediator alloc] init];</div><div class="line">        self.mediator = mediator;</div><div class="line">    &#125;</div><div class="line">    return mediator;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)setMediator:(ZJNavigationDelegateMediator *)mediator</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(self, &amp;ZJTransitioningMediator_key, mediator, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ZJNavigationDelegateMediator 类里也定义了一个 ZJNavigationTransitioningStyle 的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface ZJNavigationDelegateMediator : NSObject&lt;UINavigationControllerDelegate&gt;</div><div class="line">@property (nonatomic,assign) ZJNavigationTransitioningStyle transitioningStyle;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>设置完<code>self.navigationController.transitioningStyle</code>后，所有的操作都转交给 ZJNavigationDelegateMediator，返回的动画方式的对象，以及动画对象的管理，也是在这个类里实现。</p>
<p>下面是实现 UINavigationControllerDelegate 的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                  animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                               fromViewController:(UIViewController *)fromVC</div><div class="line">                                                 toViewController:(UIViewController *)toVC</div><div class="line">&#123;</div><div class="line">    self.operation = operation;</div><div class="line">    if(self.transitioningStyle == ZJNavigationTransitioningStyleRound)</div><div class="line">    &#123;</div><div class="line">        return self.roundTransitioning;</div><div class="line">    &#125;</div><div class="line">    else if (self.transitioningStyle == ZJNavigationTransitioningStyleScale)</div><div class="line">    &#123;</div><div class="line">        return self.scaleTransitioning;</div><div class="line">    &#125;</div><div class="line">    else if (self.transitioningStyle == ZJNavigationTransitioningStyleLeftSunken)</div><div class="line">    &#123;</div><div class="line">        return self.leftSunkenTransitioning;</div><div class="line">    &#125;</div><div class="line">    else if (self.transitioningStyle == ZJNavigationTransitioningStyleRotate)</div><div class="line">    &#123;</div><div class="line">        return self.rotateTransitioning;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>选择了哪种动画方式，就返回相应的 AnimatedTransitioning 对象，并将以何种方式进行页面切换 即是 push 还是 pop 也传到 AnimatedTransitioning 对象里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(ZJScaleAnimatedTransitioning *)scaleTransitioning</div><div class="line">&#123;</div><div class="line">    if(_scaleTransitioning == nil)</div><div class="line">    &#123;</div><div class="line">        _scaleTransitioning = [[ZJScaleAnimatedTransitioning alloc] init];</div><div class="line">    &#125;</div><div class="line">    _scaleTransitioning.operation = self.operation;</div><div class="line">    return _scaleTransitioning;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的动画对象，都继承自 ZJBaseAnimatedTransitioning，这个类 实现 <code>@protocol UIViewControllerAnimatedTransitioning &lt;NSObject&gt;</code>这个动画 protocol。</p>
<p>由于 动画方式 为 ZJNavigationTransitioningStyleScale 的时候，需要得到 push 前图片的位置信息，以及 push 后图片的位置信息 ，所以我声明了protocol，用来得到这些信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 此协议是为了得到push方式为 ZJNavigationTransitioningStyleRound 和 ZJNavigationTransitioningStyleScale 的图片的相关信息</div><div class="line"> */</div><div class="line">@protocol ZJTransitioningProtocol &lt;NSObject&gt;</div><div class="line">-(NSDictionary *)getTransitioningInfoWithTransitioning:(id &lt;UIViewControllerAnimatedTransitioning&gt;)transitioning;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在 <code>@protocol UIViewControllerAnimatedTransitioning &lt;NSObject&gt;</code> 实现方法里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</div></pre></td></tr></table></figure>
<p>我们去写实际动画相关的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</div><div class="line">UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</div><div class="line">UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey];</div><div class="line">UIView *containerView = [transitionContext containerView];</div></pre></td></tr></table></figure>
<p>在本例中，当为 push 操作时，fromVC 为 TableViewController，toVC 为 ImageViewController。而当为 pop 操作时，fromVC 为 ImageViewController，toVC 为 TableViewController，这一点千万要注意，是相反的。</p>
<p>先通过自己定义的 ZJTransitioningProtocol 得到图片的位置信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">UIImageView *fromImageView = nil;</div><div class="line">UIImageView *toImageView = nil;</div><div class="line">CGRect fromRect = CGRectZero ;</div><div class="line">CGRect ToRect = CGRectZero;</div><div class="line">if([fromVC respondsToSelector:@selector(getTransitioningInfoWithTransitioning:)])</div><div class="line">&#123;</div><div class="line">    NSDictionary *dic = [(id &lt;ZJTransitioningProtocol&gt;)fromVC getTransitioningInfoWithTransitioning:self];</div><div class="line">    fromImageView = dic[@&quot;imageView&quot;];</div><div class="line">    fromRect = CGRectFromString(dic[@&quot;frame&quot;]);</div><div class="line"> &#125;</div><div class="line">  if([toVC respondsToSelector:@selector(getTransitioningInfoWithTransitioning:)])</div><div class="line"> &#123;</div><div class="line">     NSDictionary *dic = [(id &lt;ZJTransitioningProtocol&gt;)toVC getTransitioningInfoWithTransitioning:self];</div><div class="line">     toImageView = dic[@&quot;imageView&quot;];</div><div class="line">     oRect = CGRectFromString(dic[@&quot;frame&quot;]);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 将 toView 加入到 containerView 的时候，当为 pop 操作时，注意为</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[containerView insertSubview:toView belowSubview:fromView];</div></pre></td></tr></table></figure>
<p> 上面都是准备操作，下面到了实际的动画操作</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIImageView *imageView = [self copyOfImageView:toImageView];</div><div class="line">imageView.frame = fromRect;</div><div class="line">[[UIApplication sharedApplication].keyWindow addSubview:imageView];</div><div class="line">fromImageView.hidden = YES;</div><div class="line">toImageView.hidden = YES;</div></pre></td></tr></table></figure>
<p>加一个过渡的imageView 加在 window 上 ，用imageView的坐标的变化实现动画效果，动画结束后移除此过渡imageView，并将先将原来的fromImageView toImageView隐藏.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0.0 options:UIViewAnimationOptionCurveEaseOut animations: ^&#123;</div><div class="line">   // 动画阴影效果</div><div class="line">    maskViewForFromView.alpha = maskViewAlpha;</div><div class="line">    maskViewForToView.alpha = 0.0;</div><div class="line">    </div><div class="line">    toView.frame = finalFrameForToVC;</div><div class="line">    if (self.operation == UINavigationControllerOperationPush)</div><div class="line">    &#123;</div><div class="line">        CGRect frame = fromView.frame;</div><div class="line">        frame.origin.x = frame.origin.x - frame.size.width / 3.0;</div><div class="line">        fromView.frame = frame;</div><div class="line">    &#125;</div><div class="line">    else if (self.operation == UINavigationControllerOperationPop)</div><div class="line">    &#123;</div><div class="line">        CGRect frame = fromView.frame;</div><div class="line">        frame.origin.x = frame.origin.x + frame.size.width;</div><div class="line">        fromView.frame = frame;</div><div class="line">    &#125;</div><div class="line">    imageView.frame = ToRect;</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">    [maskViewForFromView removeFromSuperview];</div><div class="line">    [maskViewForToView removeFromSuperview];</div><div class="line"></div><div class="line">    fromImageView.hidden = NO;</div><div class="line">    toImageView.hidden = NO;</div><div class="line">    [imageView removeFromSuperview];</div><div class="line">    [transitionContext completeTransition:!transitionContext.transitionWasCancelled];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>代码很好理解，在 fromView toView 上都加了过渡的阴影view，动画的过程中将 maskViewForFromView 的 alpha 增加，将 maskViewForToView 的 alpha 减小至0，动画结束后移除此阴影view。切换方式为 push pop时，分别设置 fromView.frame ，完成动画效果。最后，一定不要忘了设置这句代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[transitionContext completeTransition:!transitionContext.transitionWasCancelled];</div></pre></td></tr></table></figure>
<p>这是为了告诉系统，动画已经完成，这是系统为自动帮我们移除 fromView.</p>
<p>关于其他动画方式的具体实现，有兴趣的可以到Github上下载，都有注释，很好理解</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/04/关于__block的实现原理/" itemprop="url">
                  __block实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-04T19:04:46+08:00" content="2017-04-04">
              2017-04-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/04/关于__block的实现原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/04/关于__block的实现原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/04/04/关于__block的实现原理/" class="leancloud_visitors" data-flag-title="__block实现原理">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前面试的时候，面试官问到过这个问题, <code>__block</code>修饰的对象在 ARC 下和非ARC下有何不同？为什么在 ARC 环境下，<code>__block</code> 修饰对象解决不了循环引用，只能用 __weak? 之前了解的不够全面，今天来深入探讨下。</p>
<h3 id="block修饰基本常量"><a href="#block修饰基本常量" class="headerlink" title="__block修饰基本常量"></a>__block修饰基本常量</h3><p>首先，对于基本常量，我们来写下测试代码，声明一个两个 int 类型常量，一个加 __block 修饰符，一个不加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int value = 1;</div><div class="line">        __block int block_value = 1;</div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            NSLog(@&quot;value:%d block_value:%d&quot;,value,block_value);</div><div class="line">        &#125;;</div><div class="line">        value++;</div><div class="line">        block_value++;</div><div class="line">        myBlock();</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>clang 后源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_block_value_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_block_value_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int block_value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int value;</div><div class="line">  __Block_byref_block_value_0 *block_value; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _value, __Block_byref_block_value_0 *_block_value, int flags=0) : value(_value), block_value(_block_value-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_block_value_0 *block_value = __cself-&gt;block_value; // bound by ref</div><div class="line">  int value = __cself-&gt;value; // bound by copy</div><div class="line"></div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_f4_lvvgftyd48vbb5hbcyk0y1900000gn_T_main_13a5e9_mi_0,value,(block_value-&gt;__forwarding-&gt;block_value));</div><div class="line">        &#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;block_value, (void*)src-&gt;block_value, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;block_value, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line">        int value = 1;</div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_block_value_0 block_value = &#123;(void*)0,(__Block_byref_block_value_0 *)&amp;block_value, 0, sizeof(__Block_byref_block_value_0), 1&#125;;</div><div class="line">        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, value, (__Block_byref_block_value_0 *)&amp;block_value, 570425344));</div><div class="line">        value++;</div><div class="line">        (block_value.__forwarding-&gt;block_value)++;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咋一看，这么多代码，有点头疼，没事我们慢慢分析，首先看这一段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line">        int value = 1;</div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_block_value_0 block_value = &#123;(void*)0,(__Block_byref_block_value_0 *)&amp;block_value, 0, sizeof(__Block_byref_block_value_0), 1&#125;;</div><div class="line">        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, value, (__Block_byref_block_value_0 *)&amp;block_value, 570425344));</div><div class="line">        value++;</div><div class="line">        (block_value.__forwarding-&gt;block_value)++;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>int value = 1，这行代码没变，clang 后还是这行。倒是 <code>__block int block_value</code> = 1;这句代码，被转化成了 <code>__Block_byref_block_value_0</code> 类型的结构体。结构体里有5个成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_block_value_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_block_value_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int block_value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意，这个结构体包含了该实例本身的引用__forwarding，再看下面这行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, value, (__Block_byref_block_value_0 *)&amp;block_value, 570425344))</div></pre></td></tr></table></figure>
<p><code>__main_block_impl_0</code> 为 myBlock 的构造体函数，其中传入的参数具体为：</p>
<p><code>__main_block_func_0</code> ：包含了block内部的代码，在我们的例子中，就是 NSLog(@”value:%d block_value:%d”,value,block_value)；</p>
<p><code>__main_block_desc_0_DATA</code>：block的内存管理相关信息；</p>
<p><code>value</code>：即，传入的 value；</p>
<p><code>block_value</code>：被转化后的 __Block_byref_block_value_0类型的block_value。</p>
<p>当我们在 block 内部用到外部变量值的时候，在本例中就是 NSLog的时候，对于没有 __block修饰的 value 常量，直接通过自身，访问 value的值，得到最原始的值，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int value = __cself-&gt;value;</div></pre></td></tr></table></figure>
<p>关于为什么不能再 block 内部改变外部常量的值，是因为，int value变量定义在栈上，在block调用时已经被销毁，但是我们还能在block内部访问这个值，显然是被 copy 进了block内部。就算我可以在block内部重新设置 value的值，但是当我在 block内 NSlog(@”%d”,value)得到value值得时候，是通过 <code>__cself-&gt;value</code> 得到的，还是当初 copy进来的那个值。所以说，在block 内部重新改变外部 value值是做不到的，既然做不到，那干脆编译器不让我们这么写。所以说，在 block 内部设置外部变量的值得时候，编译器会给错误提示。<br>对于__block修饰的常量，是通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__Block_byref_block_value_0 *block_value = __cself-&gt;block_value; // bound by ref;</div><div class="line">block_value-&gt;__forwarding-&gt;block_value</div></pre></td></tr></table></figure>
<p>这样得到的。那么问题来了<code>__Block_byref_block_value_0</code> 结构体内部不是有一个成员变量 block_value 吗，直接访问不就好了，为什么还要通过自身引用 <code>__forwarding-&gt;block_value</code>这样得到呢？</p>
<p>先来了解一下关于 block 的类型：block一共有3种类型的block</p>
<p>_NSGlobalBlock 全局静态</p>
<p>_NSStackBlock 保存在栈中，出函数作用域就销毁</p>
<p>_NSMallocBlock 保存在堆中，retainCount == 0销毁</p>
<p>ARC环境下，一旦Block赋值就会触发copy，<code>__block</code>修饰的对象就会copy到堆上，Block也是<strong>NSMallocBlock。<br>MRC环境下，只有copy，`</strong>block<code>才会被复制到堆上，否则，</code><strong>block`一直都在栈上，block也只是</strong>NSStackBlock。</p>
<p>回到刚才的 <code>__forwarding-&gt;block_value</code>问题上，在上面的示例代码中，由于在 ARC 下进行，所以，block为 <code>__NSMallocBlock</code>，<code>__forwarding</code>指向自己。但是在 MRC 下，这样的代码示例，这个block 是 <code>_NSStackBlock</code>，只有被 copy 后才是 <code>__NSMallocBlock</code>。</p>
<p>通过<code>__forwarding-&gt;block_value</code>这样访问，正是考虑到了ARC 与 MRC的情况，当一个Block被复制到堆上时，与之相关的<code>__block</code>变量也会被复制到堆上，此时堆上的Block持有相应堆上的<code>__block</code>变量，而在栈上的<code>__block</code>变量被复制到堆上之后，会将成员变量<code>__forwarding</code>的值替换为堆上的<code>__block</code>变量的地址。这个时候我们可以通过代码访问：<code>__forwarding-&gt;block_value</code>。这里的两张图非常经典：</p>
<p>_NSMallocBlock:</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/blockTest_Stack.jpg" alt="image"></p>
<p>_NSStackBlock -&gt; _NSMallocBlock:</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/blockTest_Malloc.jpg" alt="image"></p>
<h3 id="block修饰对象"><a href="#block修饰对象" class="headerlink" title="__block修饰对象"></a>__block修饰对象</h3><p>直接上代码，MRC 下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        // MRC下</div><div class="line">        NSObject *obj =[[NSObject alloc] init];</div><div class="line">        __block NSObject *blockObj =[[NSObject alloc] init];</div><div class="line">        </div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            NSLog(@&quot;%d %d&quot;,(int)obj.retainCount,(int)blockObj.retainCount);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，block内部 obj,和<code>__block</code>修饰下的 blockObj 的 retainCount 为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-04-05 15:50:22.732 BlockTest[4240:1342091] 1 1</div></pre></td></tr></table></figure>
<p>可以看出来，此时 block 为栈block, obj 和 blockObj 的引用计数都没有增加。但是当我将这个block copy之后，见代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSObject *obj =[[NSObject alloc] init];</div><div class="line"> __block NSObject *blockObj =[[NSObject alloc] init];</div><div class="line">      </div><div class="line">      void(^myBlock)(void) = ^&#123;</div><div class="line">          NSLog(@&quot;%d %d&quot;,(int)obj.retainCount,(int)blockObj.retainCount);</div><div class="line">      &#125;;</div><div class="line">      [myBlock copy];</div><div class="line">      myBlock();</div></pre></td></tr></table></figure>
<p>此时，此时 block 为堆block， retainCount 为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-04-05 15:55:22.732 BlockTest[4240:1342091] 2 1</div></pre></td></tr></table></figure>
<p>即 myBlock 强引用了 obj。这也印证了 ARC 下，block 会强引用内部使用的对象，因为在ARC环境下，我们对 block 进行赋值时，block 会自动copy，转为 <code>_NSMallocBlock</code>，所以会强引用内部对象。</p>
<p>在 ARC 下，clang 源码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_blockObj_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_blockObj_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</div><div class="line"> void (*__Block_byref_id_object_dispose)(void*);</div><div class="line"> NSObject *blockObj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  NSObject *obj;</div><div class="line">  __Block_byref_blockObj_0 *blockObj; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSObject *_obj, __Block_byref_blockObj_0 *_blockObj, int flags=0) : obj(_obj), blockObj(_blockObj-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_blockObj_0 *blockObj = __cself-&gt;blockObj; // bound by ref</div><div class="line">  NSObject *obj = __cself-&gt;obj; // bound by copy</div><div class="line"></div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_f4_lvvgftyd48vbb5hbcyk0y1900000gn_T_main_0bbf21_mi_0,obj ,(blockObj-&gt;__forwarding-&gt;blockObj));</div><div class="line">        &#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;obj, (void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;blockObj, (void*)src-&gt;blockObj, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;blockObj, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line"></div><div class="line">        NSObject *obj =((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_blockObj_0 blockObj = &#123;(void*)0,(__Block_byref_blockObj_0 *)&amp;blockObj, 33554432, sizeof(__Block_byref_blockObj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;))&#125;;</div><div class="line"></div><div class="line">        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, obj, (__Block_byref_blockObj_0 *)&amp;blockObj, 570425344));</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 obj 和 blockObj 的处理方法与处理常量大径相同，被 <code>__block</code>修饰的对象会被转为 <code>__Block_byref_blockObj_0</code> 结构体类型的对象，这个对象一样强引用着blockObj。就是说，block 会 一直持有被<code>__block</code>修饰的对象，直到 block 对象从堆上销毁。 所以，在ARC 下，<code>__block</code>修饰的对象，不会解决循环引用问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/27/Runtime学习之二：消息的传递与转发/" itemprop="url">
                  Runtime学习之二：消息的传递与转发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-27T22:22:26+08:00" content="2017-03-27">
              2017-03-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/27/Runtime学习之二：消息的传递与转发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/27/Runtime学习之二：消息的传递与转发/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/03/27/Runtime学习之二：消息的传递与转发/" class="leancloud_visitors" data-flag-title="Runtime学习之二：消息的传递与转发">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>消息机制是 Runtime 中最吸引人的地方，为什么说 OC 是一门动态语言，就是因为 OC 上所有的方法调用都是在运行时进行。就是说，向对象发送方法，就会使用动态绑定机制来决定需要调用的方法，这与 C 语言中调用方式完全不同，C 语言使用的是静态绑定，即在编译期就决定了运行时所调用的函数。今天我们就详细来看下 Runtime 的消息机制。</p>
<h3 id="一-、消息的传递"><a href="#一-、消息的传递" class="headerlink" title="一 、消息的传递"></a>一 、消息的传递</h3><p> 消息的传递，简单来说，就是 Runtime 通过 selector 查找 IMP 的过程，有了 IMP 这个函数指针之后就可以执行对应的函数实现</p>
<h4 id="1-1-objc-msgSend"><a href="#1-1-objc-msgSend" class="headerlink" title="1.1 objc_msgSend"></a>1.1 objc_msgSend</h4><p>当你随便写下一段函数调用的代码后，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[receiver message];</div></pre></td></tr></table></figure>
<p> 都会被编译器转化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSend(id self, SEL op, ...);</div></pre></td></tr></table></figure>
<p>Objective-C 中关于 objc_msgSend 的实现并没有开源，我们只能看到关于它的相关注释，在 message.h 文件里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> * @note When it encounters a method call, the compiler generates a call to one of the</div><div class="line"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.</div><div class="line"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper; </div><div class="line"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values</div><div class="line"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.</div><div class="line"> */</div><div class="line">OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)</div></pre></td></tr></table></figure>
<p> 简单翻译一下就是说，当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 objc_msgSend、objc_msgSend_stret、objc_msgSendSuper 和 objc_msgSendSuper_stret。 发送给对象的父类的消息会使用 objc_msgSendSuper 有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret 其它的消息都是使用 objc_msgSend 发送的。</p>
<p>objc_msgSend内部是用汇编写的，至于为什么用汇编写，速度快是一方面，<a href="http://arigrant.com/blog/2014/2/12/why-objcmsgsend-must-be-written-in-assembly" target="_blank" rel="external">这篇文章</a>也说了其他的原因。它针对不同架构有不同的实现，但它内部到底是怎么实现的呢？在 <a href="https://github.com/opensource-apple/objc4/blob/master/runtime/Messengers.subproj/objc-msg-x86_64.s" target="_blank" rel="external">objc-msg-x86_64.s </a>中，我们可以发现在 x86_64 架构下的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"> *</div><div class="line"> * id objc_msgSend(id self, SEL	_cmd,...);</div><div class="line"> *</div><div class="line"> ********************************************************************/</div><div class="line">	</div><div class="line">	.data</div><div class="line">	.align 3</div><div class="line">	.globl _objc_debug_taggedpointer_classes</div><div class="line">_objc_debug_taggedpointer_classes:</div><div class="line">	.fill 16, 8, 0</div><div class="line"></div><div class="line">	ENTRY	_objc_msgSend</div><div class="line">	MESSENGER_START</div><div class="line"></div><div class="line">	NilTest	NORMAL</div><div class="line"></div><div class="line">	GetIsaFast NORMAL		// r11 = self-&gt;isa</div><div class="line">	CacheLookup NORMAL		// calls IMP on success</div><div class="line"></div><div class="line">	NilTestSupport	NORMAL</div><div class="line"></div><div class="line">	GetIsaSupport	NORMAL</div><div class="line"></div><div class="line">// cache miss: go search the method lists</div><div class="line">LCacheMiss:</div><div class="line">	// isa still in r11</div><div class="line">	MethodTableLookup %a1, %a2	// r11 = IMP</div><div class="line">	cmp	%r11, %r11		// set eq (nonstret) for forwarding</div><div class="line">	jmp	*%r11			// goto *imp</div><div class="line"></div><div class="line">	END_ENTRY	_objc_msgSend</div><div class="line"></div><div class="line">	</div><div class="line">	ENTRY _objc_msgSend_fixup</div><div class="line">	int3</div><div class="line">	END_ENTRY _objc_msgSend_fixup</div><div class="line"></div><div class="line">	</div><div class="line">	STATIC_ENTRY _objc_msgSend_fixedup</div><div class="line">	// Load _cmd from the message_ref</div><div class="line">	movq	8(%a2), %a2</div><div class="line">	jmp	_objc_msgSend</div><div class="line">	END_ENTRY _objc_msgSend_fixedup</div><div class="line"></div><div class="line">	</div><div class="line">/********************************************************************</div></pre></td></tr></table></figure>
<p> 一看到汇编，好晕，不过还要硬着头皮来看下这段代码</p>
<p> <code>NilTest</code>  宏，判断被发送消息的对象是否为 nil 的。如果为 nil，那就直接返回 nil。这就是为啥也可以对 nil 发消息。</p>
<p> <code>GetIsaFast</code> 通过它的名字，我们也可以理解：快速地获取到对象的 isa 指针地址</p>
<p> <code>CacheLookup</code> 这是一个方法，它干了什么，我们可以通过它的注释来看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Locate the implementation for a class in a selector&apos;s method cache.</div></pre></td></tr></table></figure>
<p> 就是，在类的缓存中查找 selector 对应的 IMP，但是如果没有找到呢？我们继续看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// cache miss: go search the method lists</div><div class="line">LCacheMiss</div></pre></td></tr></table></figure>
<p> 就只能到 method lists 方法列表里找了</p>
<p> <code>MethodTableLookup</code> 负责在缓存没命中时在方法表中负责查找 IMP。<br> 接下来，我们具体看下 MethodTableLookup 内部是怎么实现的</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.macro MethodTableLookup</div><div class="line"></div><div class="line"> MESSENGER_END_SLOW</div><div class="line"></div><div class="line"> SaveRegisters</div><div class="line"></div><div class="line"> // _class_lookupMethodAndLoadCache3(receiver, selector, class)</div><div class="line"></div><div class="line"> movq $0, %a1</div><div class="line"> movq $1, %a2</div><div class="line"> movq %r11, %a3</div><div class="line"> call __class_lookupMethodAndLoadCache3</div><div class="line"></div><div class="line"> // IMP is now in %rax</div><div class="line"> movq %rax, %r11</div><div class="line"></div><div class="line"> RestoreRegisters</div><div class="line"></div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>这个方法里面最重要的就是调用 __class_lookupMethodAndLoadCache3 这个函数了，我们可以在 objc-runtime-new.mm 中看到它的具体实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* _class_lookupMethodAndLoadCache.</div><div class="line">* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().</div><div class="line">* This lookup avoids optimistic cache scan because the dispatcher </div><div class="line">* already tried that.</div><div class="line">**********************************************************************/</div><div class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</div><div class="line">&#123;</div><div class="line">    return lookUpImpOrForward(cls, sel, obj, </div><div class="line">                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果这个方法中又调用了 lookUpImpOrForward 这个方法，可以看到缓存参数传入为 NO ，因为之前已经查找过缓存了，没有在缓存中找到 IMP。我们再继续往下看。</p>
<p>lookUpImpOrForward 源码的具体实现太长了，所以不贴全部代码了，有感兴趣的可以自己下载看看源码。这里分模块说下，首先进行初始化，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class curClass;</div><div class="line">IMP imp = nil;</div><div class="line">Method meth;</div><div class="line">bool triedResolver = NO;</div></pre></td></tr></table></figure>
<p>curClass 用来存放正在查找的类，imp 用来存放找到的 IMP，meth 用来存放找到的 Method，triedResolver 用来表示是否进行过动态方法解析。接下来，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runtimeLock.assertUnlocked();</div></pre></td></tr></table></figure>
<p>runtimeLock 本质上是对提供的线程读写锁 pthread_rwlock_t 的一层封装，所以这里就是加一个读写锁，保证线程安全。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> if (cache) &#123;</div><div class="line">     imp = cache_getImp(cls, sel);</div><div class="line">     if (imp) return imp;</div><div class="line"> &#125;</div><div class="line"> if (!cls-&gt;isRealized()) &#123;  </div><div class="line"> rwlock_writer_t lock(runtimeLock);</div><div class="line"> realizeClass(cls);</div><div class="line">&#125;</div><div class="line"> if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;  </div><div class="line"> _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。下面的两个判断是判断类是否载入了运行时以及是否进行了初始化，如果没有的话，会进行载入运行时操作和初始化操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runtimeLock.read();</div></pre></td></tr></table></figure>
<p>这里加了一个读锁。因为在运行时中会动态的添加方法（有 category 加入），为了保证线程安全，所以要加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Try this class&apos;s cache.</div><div class="line">imp = cache_getImp(cls, sel);</div><div class="line">if (imp) goto done;</div></pre></td></tr></table></figure>
<p>再次尝试从缓存中查找，因为加锁前可能已经有别的地方将方法的缓存加入了，如果缓存中还是没有的话，继续下面的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Try this class&apos;s method lists.</div><div class="line">meth = getMethodNoSuper_nolock(cls, sel);</div><div class="line">if (meth) &#123;</div><div class="line">    log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class="line">    imp = meth-&gt;imp;</div><div class="line">    goto done;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先使用 getMethodNoSuper_nolock(cls, sel) 在类里查找方法，如果找到了，调用 log_and_fill_cache 函数填充缓存并结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// Try superclass caches and method lists.</div><div class="line">curClass = cls;</div><div class="line">while ((curClass = curClass-&gt;superclass)) &#123;</div><div class="line">    // Superclass cache.</div><div class="line">    imp = cache_getImp(curClass, sel);</div><div class="line">    if (imp) &#123;</div><div class="line">        if (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class="line">            // Found the method in a superclass. Cache it in this class.</div><div class="line">            log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // Found a forward:: entry in a superclass.</div><div class="line">            // Stop searching, but don&apos;t cache yet; call method </div><div class="line">            // resolver for this class first.</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Superclass method list.</div><div class="line">    meth = getMethodNoSuper_nolock(curClass, sel);</div><div class="line">    if (meth) &#123;</div><div class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class="line">        imp = meth-&gt;imp;</div><div class="line">        goto done;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>往父类查找，首先现在父类的缓存中查找，找到后需要检查是否是 _objc_msgForward_impcache，这是运行时中消息转发的实现，需要先无视父类中消息转发的缓存，因为子类里可能实现了动态方法解析。找到了就把这个方法cache回自己的缓存中，然后结束。如果父类的缓存中没有，就调用 getMethodNoSuper_nolock 在父类中查找方法，找到了照样把这个方法cache回自己的缓存中，然后结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// No implementation found. Try method resolver once.</div><div class="line">if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class="line">    runtimeLock.unlockRead();</div><div class="line">    _class_resolveMethod(cls, sel, inst);</div><div class="line">    // Don&apos;t cache the result; we don&apos;t hold the lock so it may have </div><div class="line">    // changed already. Re-do the search from scratch instead.</div><div class="line">    triedResolver = YES;</div><div class="line">    goto retry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果最后都没有找到实现，那就进入动态方法解析过程。首先先判断是否开启了动态方法解析并且还没有尝试过，之后将锁打开，为什么将锁打开，是因为开发者可能会在这里动态增加方法实现，所以不需要缓存结果。调用 _class_resolveMethod，这个函数会根据 cls 是否是元类来调用我们熟知的 +resolveInstanceMethod: 或者 +resolveClassMethod。之后便重新走一遍消息发送过程（goto retry）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// No implementation found, and method resolver didn&apos;t help. </div><div class="line">// Use forwarding.</div><div class="line">imp = (IMP)_objc_msgForward_impcache;</div><div class="line">cache_fill(cls, sel, imp, inst);</div></pre></td></tr></table></figure>
<p>在缓存、当前类、父类以及 resolveInstanceMethod: 都没有解决实现查找的问题时，Objective-C 还为我们提供了最后一次翻身的机会，进行方法转发。</p>
<h3 id="二-、消息的转发"><a href="#二-、消息的转发" class="headerlink" title="二 、消息的转发"></a>二 、消息的转发</h3><p>消息的转发，就是在查找 IMP 失败后执行一系列转发流程的过程，如果不作转发处理，则会打日志和抛出异常。</p>
<p>_objc_msgForward_impcache 方法也是用汇编实现的，我们可以在<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/Messengers.subproj/objc-msg-x86_64.s" target="_blank" rel="external">objc-msg-x86_64.s </a>看下它的内部实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// _objc_msgForward_impcache is the function pointer actually stored in</div><div class="line">//   method caches.</div><div class="line">	STATIC_ENTRY	__objc_msgForward_impcache</div><div class="line">	// Method cache version</div><div class="line">	// THIS IS NOT A CALLABLE C FUNCTION</div><div class="line">	// Out-of-band condition register is NE for stret, EQ otherwise.</div><div class="line">	MESSENGER_START</div><div class="line">	nop</div><div class="line">	MESSENGER_END_SLOW</div><div class="line">	jne	__objc_msgForward_stret</div><div class="line">	jmp	__objc_msgForward</div><div class="line">	END_ENTRY	__objc_msgForward_impcache</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_objc_msgForward and _objc_msgForward_stret are the externally-callable</div><div class="line"> functions returned by things like method_getImplementation().</div></pre></td></tr></table></figure>
<p>我们通过注释也可以看到 _objc_msgForward_impcache 只是个内部的函数指针，只存储于上面提到的类的方法缓存中，需要被转化为 _objc_msgForward 和 _objc_msgForward_stret 才能被外部调用。_objc_msgForward_impcache 会根据返回值类型转化为 _objc_msgForward 或__objc_msgForward_stret。带 stret 后缀的函数依旧是返回值为结构体的版本。</p>
<p>_objc_msgForward 和 _objc_msgForward_stret 会分别调用 _objc_forward_handler 和 _objc_forward_handler_stret，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ENTRY	__objc_msgForward</div><div class="line">// Non-stret version</div><div class="line">movq	__objc_forward_handler(%rip), %r11</div><div class="line">jmp	*%r11</div><div class="line">END_ENTRY	__objc_msgForward</div><div class="line">ENTRY	__objc_msgForward_stret</div><div class="line">// Struct-return version</div><div class="line">movq	__objc_forward_stret_handler(%rip), %r11</div><div class="line">jmp	*%r11</div><div class="line">END_ENTRY	__objc_msgForward_stret</div></pre></td></tr></table></figure>
<p>接下来我们分析一下 _objc_forward_handler，继续看源码，在 objc-runtime.mm 文件中我们看到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</div><div class="line"></div><div class="line">__attribute__((noreturn)) void </div><div class="line">objc_defaultForwardHandler(id self, SEL sel)</div><div class="line">&#123;</div><div class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</div><div class="line">                &quot;(no message forward handler is installed)&quot;, </div><div class="line">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                object_getClassName(self), sel_getName(sel), self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时，我们看到了比较熟悉的语句 <code>unrecognized selector sent to instance</code> ，_objc_fatal 作用就是输出日志并触发崩溃，此时崩溃就产生了。由此我们可以理解，objc_defaultForwardHandler 这个方法就是让崩溃产生的方法，我们不要让系统调用这个方法就行了，也就是消息转发。正好系统提供了方法，来设置 forward_handler 而替换到默认的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void objc_setForwardHandler(void *fwd, void *fwd_stret)</div><div class="line">&#123;</div><div class="line">    _objc_forward_handler = fwd;</div><div class="line">#if SUPPORT_STRET</div><div class="line">    _objc_forward_stret_handler = fwd_stret;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是我们设置了 ForwardHandler 之后又该干什么呢，objc_setForwardHandler 这个方法的调用栈是什么呢，这里必须要用到关于逆向的知识。大家可以看下<a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="external">这篇文章</a>，很详细。概括的说，就是：<br><code>__CF_forwarding_prep_0</code> 和 <code>__forwarding_prep_1</code> 作为参数调用 objc_setForwardHandler 方法, <code>__CF_forwarding_prep_0</code> 和 <code>__forwarding_prep_1</code> 函数都调用了 <code>__forwarding__</code>方法，<code>__forwarding__</code> 有两个参数，第一个参数为将要被转发消息的栈指针（可以简单理解成 IMP），第二个参数标记是否返回结构体。消息转发的逻辑几乎都写在 <code>__forwarding__</code>函数中了，这个函数的伪代码实现，大家可以<br><a href="http://arigrant.com/blog/2013/12/13/a-selector-left-unhandled" target="_blank" rel="external">看这里</a>。</p>
<p>1.先调用 forwardingTargetForSelector 方法获取新的 target 作为 receiver 重新执行 selector，如果返回的内容不合法（为 nil 或者跟旧 receiver 一样），那就进入第二步。</p>
<p>2.调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入第三步</p>
<p>3.调用 doesNotRecognizeSelector 方法，产生崩溃</p>
<p>至此，整个消息传递与转发流程结束。</p>
<h3 id="三-、消息转发实战练习"><a href="#三-、消息转发实战练习" class="headerlink" title="三 、消息转发实战练习"></a>三 、消息转发实战练习</h3><p>通过以上描述，我们知道了消息转发机制基本分为三个步骤：</p>
<p>1.动态方法解析</p>
<p>2.备用接受者</p>
<p>3.完整的消息转发</p>
<h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><p>对象在接收到未知的消息时，首先会调用所属类的类方法 +resolveInstanceMethod:(实例方法)或 者 +resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经 实现了该”处理方法”，只需要在运行时通过class_addMethod 函数动态添加到类里面就可以了。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface People : NSObject</div><div class="line">-(void)test;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我在People类里，.h文件声明了<code>test</code>方法，但在 .m 文件里没有实现，如果 People的实例对象调用这个方法，会发生崩溃，我们可以 + (BOOL)resolveInstanceMethod:(SEL)sel 这个方法避免, .m 文件为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#import &quot;People.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation People</div><div class="line"> //  先返回值  @: 传入的参数</div><div class="line">// v@:@    void self sel NSString  book.name = @&quot;c++ primer&quot;</div><div class="line"></div><div class="line">//@@: book.name</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    if(sel==@selector(test))</div><div class="line">    &#123;</div><div class="line">        class_addMethod(self, sel, (IMP)dynamicMethodIMP, &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line">void dynamicMethodIMP(id self, SEL _cmd)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;运行时加入的方法:%@&quot;,NSStringFromSelector(_cmd));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>外部 People 的实例对象调用 test 方法，不会产生崩溃，控制台啊输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RuntimeDemo[3672:97440] 运行时加入的方法:test</div></pre></td></tr></table></figure>
<p>不过这种方案，更多用于实现@dynamic属性。即运行时动态增加getter，setter方法。</p>
<p><code>延伸：关于&quot;v@:&quot;</code>：</p>
<p>Objective-C中的方法默认被隐藏了两个参数：self 和_cmd 。self 指向对象本身，_cmd 指向方法本身。举两个例子来说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSString *)name</div></pre></td></tr></table></figure>
<p>这个方法实际上有两个参数：self和_cmd。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)setValue:(int)val</div></pre></td></tr></table></figure>
<p>这个方法实际上有三个参数：self, _cmd和val。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)test</div></pre></td></tr></table></figure>
<p>这个方法无返回值，所以为 <code>v@:</code> ，这里的第一个字符v代表函数的返回类型是 void，后面两个个分别是self, _cmd。</p>
<h5 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h5><p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。代码如下：</p>
<p>还是一样，在People类里，.h文件声明了<code>test</code>方法，但在 .m 文件里没有实现，如果 People的实例对象调用这个方法，会发生崩溃。我 在People 类里面实现了 - (id)forwardingTargetForSelector:(SEL)aSelector 方法，另外再新建一个类 Dog，也继承自 NSObject。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;forwardingTargetForSelector&quot;);</div><div class="line">    </div><div class="line">    NSString *selectorString = NSStringFromSelector(aSelector);</div><div class="line">    </div><div class="line">    // 将消息转发给Dog类来处理</div><div class="line">    if ([selectorString isEqualToString:@&quot;test&quot;]) &#123;</div><div class="line">        return [[Dog alloc] init];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>意思就是，让 Dog类来处理这个方法，如果 Dog 类来处理这个消息，如果 Dog 也没有实现这个方法，一样会发生崩溃，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[Dog test]: unrecognized selector sent to instance 0x60800000d5f0</div></pre></td></tr></table></figure>
<p>如果实现了，就不会发生崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &quot;Dog.h&quot;</div><div class="line">@implementation Dog</div><div class="line">-(void)test</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;dog test&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RuntimeDemo[4158:111341] dog test</div></pre></td></tr></table></figure>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h5 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h5><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div></pre></td></tr></table></figure>
<p> 运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的 NSInvocation 对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标 (target) 和参数。我们可以在 forwardInvocation 方法中选择将消息转发给其它对象。 forwardInvocation:方法的实现有两个任务：</p>
<p>1.定位可以响应封装在anInvocation中的消息的对象，这个对象不需要能处理所有未知消息。</p>
<p>2.使用anInvocation作为参数，将消息发送到选中的对象</p>
<p>在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息 .</p>
<p>我们必须重写以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p> 消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象,为给定的selector提供一个合适的方法签名。具体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">-(NSString *)readWithBookName:(NSString *)nameString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p> Person类中声明了一个方法 <code>-(NSString *)readWithBookName:(NSString *)nameString;</code>，这个方法带参数，带返回值。</p>
<p> 我们在 .m 文件中实现完整消息转发的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &quot;Car.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation Person</div><div class="line"></div><div class="line"></div><div class="line">-(NSMethodSignature*)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSString *sel = NSStringFromSelector(aSelector);</div><div class="line">    if([sel isEqualToString:@&quot;readWithBookName:&quot;])</div><div class="line">    &#123;</div><div class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;];</div><div class="line">    &#125;</div><div class="line">    return [super methodSignatureForSelector:aSelector];</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    SEL selector = [anInvocation selector];</div><div class="line">    Car *c = [[Car alloc] init];</div><div class="line">    if([c respondsToSelector:selector])</div><div class="line">    &#123;</div><div class="line">        [anInvocation invokeWithTarget:c];</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p> 意思就是将这个方法转发到 Car 类中的 <code>-(NSString *)readWithBookName:(NSString *)nameString;</code> 这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface Car : NSObject</div><div class="line">-(NSString *)readWithBookName:(NSString *)nameString;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Car</div><div class="line">-(NSString *)readWithBookName:(NSString *)nameString;</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;car类中得到的nameString:%@&quot;,nameString);</div><div class="line">    return @&quot;西游记&quot;;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p> 接下来，我们在别处，别的类里面用 Person 类的实例调用这个方法，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Person *p = [[Person alloc] init];</div><div class="line">NSString *resultString = [p readWithBookName:@&quot;红楼梦&quot;];</div><div class="line">NSLog(@&quot;返回的结果为:%@&quot;,resultString);</div></pre></td></tr></table></figure>
<p>你可以发现，控制台输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2017-03-30 22:10:53.187 MyRuntimeDemo[9313:261584] car类中得到的nameString:红楼梦</div><div class="line">2017-03-30 22:10:53.187 MyRuntimeDemo[9313:261584] 返回的结果为:西游记</div></pre></td></tr></table></figure>
<p>即完成了消息的转发过程。</p>
<p>在这里介绍一下一个类 <code>NSProxy</code>,这是除了 NSObject 之外的另一个基类,这个类的官方文档为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSProxy is an abstract superclass defining an API for objects that act as stand-ins for other objects or for objects that don’t exist yet. Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create.</div></pre></td></tr></table></figure>
<p>意思就是， NSProxy是一个虚类，你可以通过继承它，并重写这两个方法以实现消息转发到另一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel;</div></pre></td></tr></table></figure>
<p>这个类除了重载消息转发机制外没有别的用法，这也是它被设计的初衷，自己什么都不干，转给代理对象就好,就是一种代理模式。NSProxy 实现了包括 NSObject 协议在内基类所需的基础方法，但是作为一个虚拟的基类并没有提供初始化的方法。它接收到任何自己没有定义的方法他都会产生一个异常，所以一个实际的子类必须提供一个初始化方法或者创建方法通过这个类可以调用其他类的方法。我们可以通过 NSProxy 实现类似于“多继承”的功能。这里我们就拿<a href="https://developer.apple.com/library/content/samplecode/ForwardInvocation/Listings/main_m.html#//apple_ref/doc/uid/DTS40008833-main_m-DontLinkElementID_4" target="_blank" rel="external">官方</a>的例子来说下：</p>
<p>新建一个类，继承自 NSProxy，并提供初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface MyProxy : NSProxy</div><div class="line">-(id)initWithTarget1:(id)target1 target2:(id)target2;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>其中target1，target2 为真正要实现方法的对象，在 .m 文件中重写必须实现的两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#import &quot;MyProxy.h&quot;</div><div class="line"></div><div class="line">@interface MyProxy()</div><div class="line"></div><div class="line">&#123;</div><div class="line">    id _target1;</div><div class="line">    id _target2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyProxy</div><div class="line">-(id)initWithTarget1:(id)target1 target2:(id)target2</div><div class="line">&#123;</div><div class="line">    _target1 = target1;</div><div class="line">    _target2 = target2;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *sig;</div><div class="line">    sig = [_target1 methodSignatureForSelector:aSelector];</div><div class="line">    if (sig) return sig;</div><div class="line">    sig = [_target2 methodSignatureForSelector:aSelector];</div><div class="line">    return sig;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</div><div class="line">    id target = [_target1 methodSignatureForSelector:[invocation selector]] ? _target1 : _target2;</div><div class="line">    [invocation invokeWithTarget:target];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector &#123;</div><div class="line">    if ([_target1 respondsToSelector:aSelector]) return YES;</div><div class="line">    if ([_target2 respondsToSelector:aSelector]) return YES;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>接下来，我们在外部使用这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;AppDelegate.h&quot;</div><div class="line">#import &quot;MyProxy.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        NSMutableString *string = [NSMutableString string];</div><div class="line">        NSMutableArray *array = @[].mutableCopy;</div><div class="line">        </div><div class="line">        id proxy = [[MyProxy alloc] initWithTarget1:string target2:array];</div><div class="line">        </div><div class="line">        [proxy appendString:@&quot;iOS&quot;];</div><div class="line">        </div><div class="line">        [proxy addObject:@1];</div><div class="line">        </div><div class="line">        NSLog(@&quot;string:%@\narray:%@&quot;,string,array);</div><div class="line">        </div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为 MyProxy 传入两个为 NSMutableString 与 NSMutableArray的实例对象。proxy 本身并没有<code>appendString：</code> 和 <code>addObject：</code>方法 ，但运行不会产生崩溃，因为proxy 调用的任何方法都会被转发，被 string 与 array 调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2017-04-02 10:37:34.651 MyProxyDemo[1752:40883] string:iOS</div><div class="line">array:(</div><div class="line">    1</div><div class="line">)</div></pre></td></tr></table></figure>
<p>但是假如，我们用 proxy 调用这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[proxy setObject:@&quot;Jane&quot; forKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>就是产生崩溃，因为这个方法要转发给的对象 string ，array 都不能响应这个方法。</p>
<p>关于 NSProxy 的使用，<a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m" target="_blank" rel="external">YYWeakProxy</a>也用这个类实现了弱引用，有兴趣的话可以看下。</p>
<p>关于 Runtime 的消息转发就写到这里，确实，Runtime的确强大，我们可以用它做很多事情。虽然学的过程是痛苦的，也许为了弄清某一个非常小的知识点，需要花费很多时间，查阅很多资料，但最后学到的都是自己的，都是值得的。不进步，就相当于退步。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/Runtime学习之一：类与对象/" itemprop="url">
                  Runtime学习之一：类与对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-08T13:49:52+08:00" content="2017-03-08">
              2017-03-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/08/Runtime学习之一：类与对象/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/08/Runtime学习之一：类与对象/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/03/08/Runtime学习之一：类与对象/" class="leancloud_visitors" data-flag-title="Runtime学习之一：类与对象">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着 iOS开发的深入，必须要了解一些底层的东西才能算上高级iOS开发工程师，比如 Runtime，Roonloop之类的。以前都是零碎的看过网上的文章，接下来就系统整理一下，也算是对记忆的加深。</p>
<p>###简介<br>Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。</p>
<p>Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。</p>
<p>开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。</p>
<p>我们可以通过<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">这里</a>来下载Runtime源码</p>
<p>通过源码我们可以看到，NSObject定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSObject &lt;NSObject&gt; &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这个<code>Class</code>又是什么呢？我们点进去可以看一下，是一个objc_class类型的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div><div class="line">typedef struct objc_object *id;</div></pre></td></tr></table></figure>
<p>到这里我们来看一下，Runtime里面Class和Object基础数据结构，objc/runtime.h中objc_class结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">Class super_class OBJC2_UNAVAILABLE; // 父类</div><div class="line">const char *name OBJC2_UNAVAILABLE; // 类名</div><div class="line">long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0</div><div class="line">long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识</div><div class="line">long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小</div><div class="line">struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表</div><div class="line">struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表</div><div class="line">struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在methodLists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</div><div class="line">struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>此时注意，带有<code>OBJC2_UNAVAILABLE</code>标记的表示已经废弃，其实早在 2006 年，苹果在 WWDC 大会上就发布了 Objective-C 2.0，其中的改动包括 Max OS X 平台上的垃圾回收机制(现已废弃)，runtime 性能优化等。所以说，以上只是老版的objc_class结构体定义，现在我们看下新的结构体信息是怎么样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    // Class ISA;</div><div class="line">    Class superclass; //父类的指针</div><div class="line">    cache_t cache;   // 方法缓存          // formerly cache pointer and vtable</div><div class="line">    class_data_bits_t bits;  //实例方法列表  // class_rw_t * plus custom rr/alloc flags</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出objc_class是继承自objc_object的，本质上,类是一个对象,这也就是我们通常会说的’类对象’的缘由.<br>其中objc_object有一个唯一的私有变量 - isa_t类型的isa指针，所以objc_class也有这个指针。</p>
<p>当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_data_bits_t中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。</p>
<p>但是在我们调用类方法的时候，类对象的isa里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念，即：</p>
<p>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。<br>类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/ObjectAndClass.png" alt="image"></p>
<p>上图实线是super_class指针，虚线是isa指针，我们可以看出</p>
<ol>
<li>Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil</li>
<li>每个Class都有一个isa指针指向唯一的Meta class</li>
<li>Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路</li>
<li>每个Meta class的isa指针都指向Root class (meta)</li>
</ol>
<h4 id="1-isa-t-isa"><a href="#1-isa-t-isa" class="headerlink" title="1.isa_t isa"></a>1.isa_t isa</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">union isa_t </div><div class="line">&#123;</div><div class="line">    isa_t() &#123; &#125;</div><div class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class="line"></div><div class="line">    Class cls;</div><div class="line">    uintptr_t bits;</div><div class="line"></div><div class="line"># if __arm64__</div><div class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</div><div class="line">    struct &#123;</div><div class="line">        uintptr_t nonpointer        : 1;</div><div class="line">        uintptr_t has_assoc         : 1;//对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</div><div class="line">        uintptr_t has_cxx_dtor      : 1;//析构器方法,如果没有析构器就会快速释放内存</div><div class="line">        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000</div><div class="line">        uintptr_t magic             : 6;//用于调试器判断当前对象是真的对象还是没有初始化的空间</div><div class="line">        uintptr_t weakly_referenced : 1;//对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</div><div class="line">        uintptr_t deallocating      : 1;//对象正在释放内存</div><div class="line">        uintptr_t has_sidetable_rc  : 1;//对象的引用计数太大了，存不下</div><div class="line">        uintptr_t extra_rc          : 19;//对象的引用计数超过 1，会存在这个这个里面</div><div class="line">#       define RC_ONE   (1ULL&lt;&lt;45)</div><div class="line">#       define RC_HALF  (1ULL&lt;&lt;18)</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"># elif __x86_64__</div><div class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</div><div class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</div><div class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</div><div class="line">    struct &#123;</div><div class="line">        uintptr_t nonpointer        : 1;</div><div class="line">        uintptr_t has_assoc         : 1;</div><div class="line">        uintptr_t has_cxx_dtor      : 1;</div><div class="line">        uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000</div><div class="line">        uintptr_t magic             : 6;</div><div class="line">        uintptr_t weakly_referenced : 1;</div><div class="line">        uintptr_t deallocating      : 1;</div><div class="line">        uintptr_t has_sidetable_rc  : 1;</div><div class="line">        uintptr_t extra_rc          : 8;</div><div class="line">#       define RC_ONE   (1ULL&lt;&lt;56)</div><div class="line">#       define RC_HALF  (1ULL&lt;&lt;7)</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"># else</div><div class="line">#   error unknown architecture for packed isa</div><div class="line"># endif</div><div class="line"></div><div class="line">// SUPPORT_PACKED_ISA</div><div class="line">#endif</div><div class="line"></div><div class="line"></div><div class="line">#if SUPPORT_INDEXED_ISA</div><div class="line"></div><div class="line"># if  __ARM_ARCH_7K__ &gt;= 2</div><div class="line"></div><div class="line">#   define ISA_INDEX_IS_NPI      1</div><div class="line">#   define ISA_INDEX_MASK        0x0001FFFC</div><div class="line">#   define ISA_INDEX_SHIFT       2</div><div class="line">#   define ISA_INDEX_BITS        15</div><div class="line">#   define ISA_INDEX_COUNT       (1 &lt;&lt; ISA_INDEX_BITS)</div><div class="line">#   define ISA_INDEX_MAGIC_MASK  0x001E0001</div><div class="line">#   define ISA_INDEX_MAGIC_VALUE 0x001C0001</div><div class="line">    struct &#123;</div><div class="line">        uintptr_t nonpointer        : 1;</div><div class="line">        uintptr_t has_assoc         : 1;</div><div class="line">        uintptr_t indexcls          : 15;</div><div class="line">        uintptr_t magic             : 4;</div><div class="line">        uintptr_t has_cxx_dtor      : 1;</div><div class="line">        uintptr_t weakly_referenced : 1;</div><div class="line">        uintptr_t deallocating      : 1;</div><div class="line">        uintptr_t has_sidetable_rc  : 1;</div><div class="line">        uintptr_t extra_rc          : 7;</div><div class="line">#       define RC_ONE   (1ULL&lt;&lt;25)</div><div class="line">#       define RC_HALF  (1ULL&lt;&lt;6)</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"># else</div><div class="line">#   error unknown architecture for indexed isa</div><div class="line"># endif</div><div class="line"></div><div class="line">// SUPPORT_INDEXED_ISA</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>看到isa指针是一个联合体，它在在 <strong>x86_64</strong> 上的实现 和 在<strong>arm64</strong> 的设备可能有些差别，不过这些字段都是存在的</p>
<p>其中</p>
<p>SUPPORT_INDEXED_ISA,文档注释Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa  field as an index into a class table.,也就是当该属性为真,则把该类存储在isa中,作为全局class表的索引();</p>
<p>nonpointer为1,表示使用优化的isa指针,包含了引用计数,析构状态等.</p>
<p>has_assoc,是否包含关联对象,如果没有,会更快的释放内存;</p>
<p>has_cxx_dtor,是否包含析构函数,如果没有,会更快的释放内存;</p>
<p>shiftcls,类的指针;</p>
<p>magic,固定值,用于判断是否完成初始化;</p>
<p>weakly_referenced,对象是否指向一个弱引用对象,没有弱引用对象可以更快的被释放;</p>
<p>deallocating,对象是否正在销毁;</p>
<p>has_sidetable_rc,是否有sidetable(散列表),如果为真,则引用计数存储在该散列表中;</p>
<p>extra_rc,存储引用计数,比真实的引用计数少1.</p>
<h4 id="2-cache-t的具体实现"><a href="#2-cache-t的具体实现" class="headerlink" title="2.cache_t的具体实现"></a>2.cache_t的具体实现</h4><p>Cache的作用主要是为了优化方法调用的性能。如果每发送一个消息都需要去方法表中去查找，当方法很多的时候，查找是很耗力的，并且当 存在继承关系的时候，一个方法的查找链可能会很长。那么对使用过的方法进行缓存，便于第二次查找。我们看下源码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct cache_t &#123;</div><div class="line">    struct bucket_t *_buckets;</div><div class="line">    mask_t _mask;</div><div class="line">    mask_t _occupied;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而bucket_t 结构体，mask_t分别是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct bucket_t &#123;</div><div class="line">private:</div><div class="line">    cache_key_t _key;</div><div class="line">    IMP _imp;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> typedef uint32_t mask_t</div><div class="line"> typedef uintptr_t cache_key_t</div></pre></td></tr></table></figure>
<p>_buckets是一个散列表，用来方法缓存，bucket_t的结构体中存储了一个IMP，MP是一个函数指针，指向了一个方法的具体实现。</p>
<p>mask表示缓存bucket的总数。</p>
<p>occupied表明目前实际占用的缓存bucket的个数。</p>
<h4 id="3-class-data-bits-t-bits"><a href="#3-class-data-bits-t-bits" class="headerlink" title="3.class_data_bits_t bits"></a>3.class_data_bits_t bits</h4><p>bits 就是存储类的方法、属性、遵循的协议等信息的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct class_data_bits_t &#123;</div><div class="line">    // Values are the FAST_ flags above.</div><div class="line">    uintptr_t bits;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>由此可以看出ObjC 中 class_data_bits_t 的结构体，其中只含有一个 64 位的 bits 用于存储与类有关的信息，而在在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>那么这个class_rw_t又是什么呢？源码里面也为我们提供了方法返回该类型的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class_rw_t* data() &#123;</div><div class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>ObjC 类中的属性、方法还有遵循的协议等信息都保存在 class_rw_t 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct class_rw_t &#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t version;</div><div class="line"></div><div class="line">    const class_ro_t *ro;</div><div class="line"></div><div class="line">    method_array_t methods;</div><div class="line">    property_array_t properties;</div><div class="line">    protocol_array_t protocols;</div><div class="line"></div><div class="line">    Class firstSubclass;</div><div class="line">    Class nextSiblingClass;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中还有一个指向常量的指针 ro，其中存储了当前类在编译期就已经确定的属性、方法以及遵循的协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct class_ro_t &#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t instanceStart;</div><div class="line">    uint32_t instanceSize;</div><div class="line">    uint32_t reserved;</div><div class="line"></div><div class="line">    const uint8_t * ivarLayout;</div><div class="line"></div><div class="line">    const char * name;</div><div class="line">    method_list_t * baseMethodList;</div><div class="line">    protocol_list_t * baseProtocols;</div><div class="line">    const ivar_list_t * ivars;</div><div class="line"></div><div class="line">    const uint8_t * weakIvarLayout;</div><div class="line">    property_list_t *baseProperties;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在编译期间类的结构中的 class_data_bits_t <em>data 指向的是一个 class_ro_t </em> 指针。</p>
<p>总之就是，class_rw_t<em> data,存储该类方法属性协议等相关内容的指针,该结构体包含一个const class_ro_t </em>ro只读属性ro,ro中存储类在编译阶段就存在的方法属性协议等,因此当在运行时向类添加方法,那么改变的是class_rw_t类型的rw中的方法列表,而不是class_ro_t类型的ro的列表(rw即读写,ro即只读).<br>关于更详细的ObjC 中方法的结构，大家可以看<a href="http://www.jianshu.com/p/d7a60fc7b0a1" target="_blank" rel="external">这篇文章</a></p>
<p>这篇文章只是介绍了Runtime中的类与对象，接下来还会介绍Runtime对于消息是怎么处理的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/22/iOS事件的传递与响应/" itemprop="url">
                  iOS事件的传递与响应
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-22T15:19:03+08:00" content="2016-08-22">
              2016-08-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/22/iOS事件的传递与响应/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/22/iOS事件的传递与响应/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/22/iOS事件的传递与响应/" class="leancloud_visitors" data-flag-title="iOS事件的传递与响应">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在iOS中，能够响应事件的对象都是UIResponder的子类对象。UIResponder提供了四个用户点击的回调方法，分别对应用户点击开始、移动、点击结束以及取消点击。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesCancelled:(nullable NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div></pre></td></tr></table></figure>
<p>点击一个 UIView 或产生一个触摸事件，首先接收事件的是 UIApplication，UIApplication 把这个事件添加到管理的事件队列中，那么这个事件是怎么找到合适的 view 去处理事件呢？</p>
<h3 id="一、事件的传递"><a href="#一、事件的传递" class="headerlink" title="一、事件的传递"></a>一、事件的传递</h3><p>UIView 是如何判定这个事件是否是自己应该处理的呢？iOS 系统检测到一个触摸操作时会打包一个UIEvent 对象，并放入 Application 的队列，Application 从队列中取出事件后交给 UIWindow 来处理，UIWindow 会使用 hitTest:withEvent: 方法来递归的寻找操作初始点所在的 view，这个过程成为 hit-test view。</p>
<ol>
<li><p>调用当前 view 的 pointInside:withEvent: 方法来判定触摸点是否在当前view内部</p>
</li>
<li><p>如果返回 NO,则 hitTest:withEvent: 返回 nil，如果返回 YES,向当前 view 内的subViews 发送 hitTest:withEvent: 消息</p>
</li>
<li><p>如此循环遍历子控件，直到找到最合适的 view，如果没有更合适的子控件，那么自己就成为最合适的 view。</p>
</li>
</ol>
<p>注意，当 view 的 userInteractionEnabled = NO 或 view.hidden = YES 或 view 为透明，是不能接收触摸事件的，如果父控件不能接收触摸事件，那么子控件也不能收到触摸事件。<br>遍历子控件的顺序，是从最层级从高到低的顺序，即最顶层的 SubView 开始遍历，一旦有视图可以接收此次事件，就不会再往下遍历。下面通过代码来验证一下：</p>
<p>新建一个类，MyView，继承自 UIView,定义一个属性 name;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface MyView : UIView</div><div class="line">@property (nonatomic,copy)NSString *name;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#import &quot;MyView.h&quot;</div><div class="line"></div><div class="line">@implementation MyView</div><div class="line"></div><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;hitTest %@ 进入 event=%p&quot;, self.name, event);</div><div class="line">    UIView *view =  [super hitTest:point withEvent:event];</div><div class="line">    NSLog(@&quot;hitTest %@ 退出 event=%p&quot;, self.name, event);</div><div class="line">    return view;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    BOOL ret = [super pointInside:point withEvent:event];</div><div class="line">    if (ret) &#123;</div><div class="line">        NSLog(@&quot;pointInside %@ = YES&quot;, self.name);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;pointInside %@ = NO&quot;, self.name);</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;处理事件的view为:%@&quot;,self.name);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在 ViewController 中分别实例化 MyView 的对象,superView，viewA,viewB,viewC,viewD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">MyView *superView = [[MyView alloc] initWithFrame:CGRectMake(50, 100, 250, 450)];</div><div class="line">superView.name = @&quot;superView&quot;;</div><div class="line">superView.backgroundColor = [UIColor grayColor];</div><div class="line">[self.view addSubview:superView];</div><div class="line"></div><div class="line">MyView *viewA =[[MyView alloc] initWithFrame:CGRectMake(25, 80, 200, 100)];</div><div class="line">viewA.name = @&quot;viewA&quot;;</div><div class="line">viewA.backgroundColor = [UIColor cyanColor];</div><div class="line">[superView addSubview:viewA];</div><div class="line"></div><div class="line">MyView *viewB =[[MyView alloc] initWithFrame:CGRectMake(25, 200, 200, 220)];</div><div class="line">viewB.name = @&quot;viewB&quot;;</div><div class="line">viewB.backgroundColor = [UIColor orangeColor];</div><div class="line">[superView addSubview:viewB];</div><div class="line"></div><div class="line">MyView *viewC =[[MyView alloc] initWithFrame:CGRectMake(25, 40, 150, 80)];</div><div class="line">viewC.name = @&quot;viewC&quot;;</div><div class="line">viewC.backgroundColor = [UIColor blueColor];</div><div class="line">[viewB addSubview:viewC];</div><div class="line"></div><div class="line">MyView *viewD =[[MyView alloc] initWithFrame:CGRectMake(25, 130, 150, 80)];</div><div class="line">viewD.name = @&quot;viewD&quot;;</div><div class="line">viewD.backgroundColor = [UIColor greenColor];</div><div class="line">[viewB addSubview:viewD];</div></pre></td></tr></table></figure>
<p>viewA 和 viewB 为 superView 的子视图，viewC 和 viewD 为 viewB 的子视图,运行后，视图为：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/hitTest.png" alt="image"></p>
<p>当我点击 viewC 时，控制台输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">2016-08-22 17:46:15.273 EventDemo[3268:357205] hitTest superView 进入 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.274 EventDemo[3268:357205] pointInside superView = YES</div><div class="line">2016-08-22 17:46:15.274 EventDemo[3268:357205] hitTest viewB 进入 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.274 EventDemo[3268:357205] pointInside viewB = YES</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] hitTest viewD 进入 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] pointInside viewD = NO</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] hitTest viewD 退出 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] hitTest viewC 进入 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] pointInside viewC = YES</div><div class="line">2016-08-22 17:46:15.275 EventDemo[3268:357205] hitTest viewC 退出 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.276 EventDemo[3268:357205] hitTest viewB 退出 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.276 EventDemo[3268:357205] hitTest superView 退出 event=0x7ffe8ad08dc0</div><div class="line">2016-08-22 17:46:15.279 EventDemo[3268:357205] 处理事件的view为:viewC</div></pre></td></tr></table></figure>
<p>由控制台输出可以看出，的确是一层一层遍历子视图，最后找到处理视图 viewC。这里为什么没有遍历 viewA 呢，正如上面所说的，遍历顺序是从 superView 的最上层子视图，即 viewB 开始的。viewC 和 viewD 作为 viewB 的子视图，viewD 后添加到 viewB 上，先遍历 viewD 。</p>
<h3 id="二、时间的响应"><a href="#二、时间的响应" class="headerlink" title="二、时间的响应"></a>二、时间的响应</h3><p>先看下官方给的图：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/hitappleaggin.png" alt="image"></p>
<ol>
<li><p>事件顺着responder chain传递，如果一环不处理，则传递到下一环</p>
</li>
<li><p>view 的下一级是包含它的 viewController，如果没有 viewController 则是它的 superView</p>
</li>
<li><p>viewController 的下一级是它的 view 的 superView</p>
</li>
<li><p>view 之后是 window，最后传给 application，如果都没有处理，最后回到UIApplication，再不处理就会抛弃</p>
</li>
</ol>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>1、当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。</p>
<p>2、事件的响应，首先看initial view能否处理这个事件，如果不能则会将事件传递给其上级视图；如果上级视图仍然无法处理则会继续传递；一直到 window，如果window还是不能处理此事件则继续交给application处理，如果最后application还是不能处理此事件则将其丢弃</p>
<p>3、在事件的响应中，如果某个控件实现了touches…方法，则这个事件将由该控件来接受，如果调用了[supertouches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的touches….方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/18/Objective-C Category/" itemprop="url">
                  Objective-C Category
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-18T16:13:04+08:00" content="2016-08-18">
              2016-08-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/18/Objective-C Category/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/18/Objective-C Category/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/18/Objective-C Category/" class="leancloud_visitors" data-flag-title="Objective-C Category">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Category简介"><a href="#Category简介" class="headerlink" title="Category简介"></a>Category简介</h3><p>最近更加深入了学习category，查阅了好多大牛博客，系统的整理一下学习过程。</p>
<p>关于Category的简单介绍，首先摘自官方文档的一句话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">You use categories to define additional methods of an existing class—even one whose source code is unavailable to you—without subclassing. You typically use a category to add methods to an existing class, such as one defined in the Cocoa frameworks. The added methods are inherited by subclasses and are indistinguishable at runtime from the original methods of the class</div><div class="line"></div><div class="line">* Distribute the implementation of your own classes into separate source </div><div class="line">* files—for example, you could group the methods of a large class into several categories and put each category in a different file.</div><div class="line">Declare private methods.</div></pre></td></tr></table></figure>
<p>说的很清楚，当原有的方法不能满足你需要的时候，你可以用category来定义一个自己的方法。使用场景有：</p>
<p>1.给现有的类添加方法</p>
<p>2.将类的实现分开在不同的文件里</p>
<p>3.声明私有方法</p>
<p>接下来将结合 runtime，了解 category 的内部实现原理。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>所有的OC类和对象，在 runtime 层都是用 struct 表示的，category 也不例外，在 runtime层，category 用结构体 category_t 表示，在 objc-runtime-new.h 文件中，我们可以看到关于 category_t 的定义：（ 没有的同学可以在这里下载： <a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">Runtime源码下载</a> ）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">struct category_t &#123;</div><div class="line">    const char *name; //类的名字</div><div class="line">    classref_t cls; //要扩展的类对象</div><div class="line">    struct method_list_t *instanceMethods; //category中所有给类添加的实例方法的列表</div><div class="line">    struct method_list_t *classMethods; //category中所有添加的类方法的列表</div><div class="line">    struct protocol_list_t *protocols; //category实现的所有协议的列表</div><div class="line">    struct property_list_t *instanceProperties; //category中添加的所有属性</div><div class="line"></div><div class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</div><div class="line">        if (isMeta) return classMethods;</div><div class="line">        else return instanceMethods;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    property_list_t *propertiesForMeta(bool isMeta) &#123;</div><div class="line">        if (isMeta) return nil; // classProperties;</div><div class="line">        else return instanceProperties;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们代码中写入 category，它是如何加载的呢，我们继续阅读 runtime源码,对月OC运行时，runtime的加载入口是下面的一个方法，我们 可以在objc-os.mm 文件中看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void _objc_init(void)</div><div class="line">&#123;</div><div class="line">    static bool initialized = false;</div><div class="line">    if (initialized) return;</div><div class="line">    initialized = true;</div><div class="line">    </div><div class="line">    // fixme defer initialization until an objc-using image is found?</div><div class="line">    environ_init();</div><div class="line">    tls_init();</div><div class="line">    static_init();</div><div class="line">    lock_init();</div><div class="line">    exception_init();</div><div class="line">        </div><div class="line">    // Register for unmap first, in case some +load unmaps something</div><div class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</div><div class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,</div><div class="line">                                             1/*batch*/, &amp;map_2_images);</div><div class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>category被附加到类上面是在 map_2_images 的时候发生的,_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，最终 category 的加载方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">void _read_images(header_info **hList, uint32_t hCount)</div><div class="line">&#123;</div><div class="line">  // 其它的加载，在这里省略</div><div class="line">  // Discover categories. </div><div class="line">    for (EACH_HEADER) &#123;</div><div class="line">        category_t **catlist = </div><div class="line">            _getObjc2CategoryList(hi, &amp;count);</div><div class="line">        for (i = 0; i &lt; count; i++) &#123;</div><div class="line">            category_t *cat = catlist[i];</div><div class="line">            Class cls = remapClass(cat-&gt;cls);</div><div class="line"></div><div class="line">            if (!cls) &#123;</div><div class="line">                // Category&apos;s target class is missing (probably weak-linked).</div><div class="line">                // Disavow any knowledge of this category.</div><div class="line">                catlist[i] = nil;</div><div class="line">                if (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</div><div class="line">                                 &quot;missing weak-linked target class&quot;, </div><div class="line">                                 cat-&gt;name, cat);</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Process this category. </div><div class="line">            // First, register the category with its target class. </div><div class="line">            // Then, rebuild the class&apos;s method lists (etc) if </div><div class="line">            // the class is realized. </div><div class="line">            bool classExists = NO;</div><div class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </div><div class="line">                ||  cat-&gt;instanceProperties) </div><div class="line">            &#123;</div><div class="line">                addUnattachedCategoryForClass(cat, cls, hi);</div><div class="line">                if (cls-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls);</div><div class="line">                    classExists = YES;</div><div class="line">                &#125;</div><div class="line">                if (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, </div><div class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </div><div class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </div><div class="line">                /* ||  cat-&gt;classProperties */) </div><div class="line">            &#123;</div><div class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</div><div class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls-&gt;ISA());</div><div class="line">                &#125;</div><div class="line">                if (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, </div><div class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这一大堆代码，我们可以看到：</p>
<ol>
<li>遍历 catlist 数组（装有categoty_t的数组），把 category 的实例方法，协议及属性添加到主类上</li>
<li>把 category 的类方法和协议添加到 metaclass 上。</li>
</ol>
<p>我们再来分析一下上面的代码的关键方法： remethodizeClass</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void remethodizeClass(Class cls)</div><div class="line">&#123;</div><div class="line">    category_list *cats;</div><div class="line">    bool isMeta;</div><div class="line"></div><div class="line">    runtimeLock.assertWriting();</div><div class="line"></div><div class="line">    isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    // Re-methodizing: check for more categories</div><div class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</div><div class="line">        if (PrintConnecting) &#123;</div><div class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;, </div><div class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        attachCategories(cls, cats, true /*flush caches*/);        </div><div class="line">        free(cats);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法又调用了 attachCategories：（一层套一层，汗！）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">// Attach method lists and properties and protocols from categories to a class.</div><div class="line">// Assumes the categories in cats are all loaded and sorted by load order, </div><div class="line">// oldest categories first.</div><div class="line">static void </div><div class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</div><div class="line">&#123;</div><div class="line">    if (!cats) return;</div><div class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line"></div><div class="line">    bool isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    // fixme rearrange to remove these intermediate allocations</div><div class="line">    method_list_t **mlists = (method_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*mlists));</div><div class="line">    property_list_t **proplists = (property_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*proplists));</div><div class="line">    protocol_list_t **protolists = (protocol_list_t **)</div><div class="line">        malloc(cats-&gt;count * sizeof(*protolists));</div><div class="line"></div><div class="line">    // Count backwards through cats to get newest categories first</div><div class="line">    int mcount = 0;</div><div class="line">    int propcount = 0;</div><div class="line">    int protocount = 0;</div><div class="line">    int i = cats-&gt;count;</div><div class="line">    bool fromBundle = NO;</div><div class="line">    while (i--) &#123;</div><div class="line">        auto&amp; entry = cats-&gt;list[i];</div><div class="line"></div><div class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">        if (mlist) &#123;</div><div class="line">            mlists[mcount++] = mlist;</div><div class="line">            fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta);</div><div class="line">        if (proplist) &#123;</div><div class="line">            proplists[propcount++] = proplist;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class="line">        if (protolist) &#123;</div><div class="line">            protolists[protocount++] = protolist;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    auto rw = cls-&gt;data();</div><div class="line"></div><div class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">    free(mlists);</div><div class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class="line"></div><div class="line">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">    free(proplists);</div><div class="line"></div><div class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">    free(protolists);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码才是关键，注意看苹果给的这个方法的注释：Attach method lists and properties and protocols from categories to a class,把 category 中的方法，属性，协议从 category 中加到类上面，<br>通过 while 循环，遍历所有的 category,得到它的方法列表并存入 mlist 中，最后通过 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rw-&gt;methods.attachLists(mlists, mcount);</div></pre></td></tr></table></figure>
<p>将 category 中的方法，与原方法 合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;  </div><div class="line">    if (addedCount == 0) return;</div><div class="line">    uint32_t oldCount = array()-&gt;count;</div><div class="line">    uint32_t newCount = oldCount + addedCount;</div><div class="line">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class="line">    array()-&gt;count = newCount;</div><div class="line">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0]));</div><div class="line">    memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 attachLists 方法就是合并的方法，将新的方法列表数组，即 category 中的方法 添加到了原方法列表中的前面，所以说：<br>category 中的方法并没有替换掉原来类已经有的方法，只不过新添加的方法在原来类方法的前面，运行时在查找方法时，是按着方法列表的顺序查找的，只要一找到，就会停止查找，所以说会调用 category 中的方法</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.sunnyxx.com/2014/03/05/objc_category_secret/" target="_blank" rel="external">objc category的秘密</a></p>
<p><a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a></p>
<p><a href="http://www.jianshu.com/p/d66d65314add" target="_blank" rel="external">结合 category 工作原理分析 OC2.0 中的 runtime</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/16/KVO原理/" itemprop="url">
                  KVO原理实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-16T16:57:11+08:00" content="2016-08-16">
              2016-08-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/16/KVO原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/16/KVO原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/16/KVO原理/" class="leancloud_visitors" data-flag-title="KVO原理实现">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、KVO简介"><a href="#一、KVO简介" class="headerlink" title="一、KVO简介"></a>一、KVO简介</h3><p>KVO是 Objective-C 对观察者设计模式的一种实现，它提供一种机制，指定一个被观察对象，当这个对象指定的属性发生改变时，对象会获得通知，并作出相应处理。比如在下拉刷新控件中，观察scrollView的contentOffset属性，当contentOffset发生改变时，让刷新控件显示不同的状态。</p>
<h3 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h3><p>KVO的实现依赖于 Objective-C 强大的 Runtime，下面我们来探索一下：<br>新建一个Person类，监听它的name属性，并在监听前与监听后分别输出相关信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.per = [[Person alloc] init];</div><div class="line">NSLogDescription(self.per);</div><div class="line">[self.per addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];</div><div class="line">NSLogDescription(self.per);</div></pre></td></tr></table></figure>
<p>NSLogDescription方法为工具方法，输出类的名字，isa，实现的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static void NSLogDescription(id obj)</div><div class="line">&#123;</div><div class="line">    NSString *str = [NSString stringWithFormat:</div><div class="line">                     @&quot;%@\n\tclassName: %s\n\tclsss isa: %s\n\timplements methods &lt;%@&gt;&quot;,</div><div class="line">                     obj,</div><div class="line">                     class_getName([obj class]),</div><div class="line">                     class_getName(object_getClass(obj)),</div><div class="line">                     [ClassMethodNames(object_getClass(obj)) componentsJoinedByString:@&quot;, &quot;]];</div><div class="line">    printf(&quot;%s\n&quot;, [str UTF8String]);</div><div class="line">&#125;</div><div class="line">static NSArray *ClassMethodNames(Class c)</div><div class="line">&#123;</div><div class="line">    NSMutableArray *array = [NSMutableArray array];</div><div class="line">    </div><div class="line">    unsigned int methodCount = 0;</div><div class="line">    Method *methodList = class_copyMethodList(c, &amp;methodCount);</div><div class="line">    unsigned int i;</div><div class="line">    for(i = 0; i &lt; methodCount; i++)</div><div class="line">        [array addObject: NSStringFromSelector(method_getName(methodList[i]))];</div><div class="line">    free(methodList);</div><div class="line">    return array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在控制台可以看见监听前和监听后的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Person: 0x7fcc4b61a240&gt;</div><div class="line">	className: Person</div><div class="line">	clsss isa: Person</div><div class="line">	implements methods &lt;.cxx_destruct, name, setName:&gt;</div><div class="line">&lt;Person: 0x7fcc4b61a240&gt;</div><div class="line">	className: Person</div><div class="line">	clsss isa: NSKVONotifying_Person</div><div class="line">	implements methods &lt;setName:, class, dealloc, _isKVOA&gt;</div></pre></td></tr></table></figure>
<p>我们看到，类的名字还是 Person，但是 isa 指针却是 NSKVONotifying<em>Person，并且实现的方法也变了<br>其实这是 Runtime 搞的鬼，当某个类的对象第一次被观察时，系统就会在运行期动态的创建该类的子类，修改这个类的 isa 指向这个新的子类，类名字就是这种 NSKVONotifying</em>(类名)。由于在 iOS 中函数调用都转化为 isa 查表形式，所以这次查的是新的子类的表，也就是说对类的函数调用被子类给拦截了。这种修改类的 isa 技术被称为 isa-swizzling 技术。由此可见，新的 NSKVONotifying_Person 类都做了一下事情：</p>
<p> 2.1、重写 class 方法</p>
<p>当你打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.per class];</div></pre></td></tr></table></figure>
<p>不管在监听前，还是监听后，都返回 Person,这应该是苹果故意而为之，他们不希望这个机制暴露在外面，故重写了 class 方法</p>
<p> 2.2、重写 set 方法</p>
<p>新类会重写监听属性的 set 方法，如果该类还有其他属性，但是没有监听，不会重写其他属性的 set 方法，并且在重写的 set 方法内增加了另外两个方法的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(void)willChangeValueForKey:(NSString *)key</div><div class="line">-(void)didChangeValueForKey:(NSString *)key</div></pre></td></tr></table></figure>
<p>其中，didChangeValueForKey:方法负责调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(NSDictionary *)change</div><div class="line">                       context:(void *)context</div></pre></td></tr></table></figure>
<p>这就是 KVO 实现的原理了。</p>
<p>2.3、增加了 _isKVOA  dealloc 方法</p>
<p>_isKVOA 用来标示该类是一个 KVO 机制声称的类。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>KVO 是 Cocoa 提供的一个很强大的特性，但同时它也有很多坑需要我我们注意，比如比如添加完监听后，要在不需要的时候删除掉监听，否则就会造成意外崩溃。还有相对于 delegate , notification,KVO 要创建子类及重写方法，相对的占用更多的内存。对一个复杂和相关性很多的class，用 delegate 或 notification 的方式比较简洁</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/15/老生常谈NSString与NSMutableString/" itemprop="url">
                  老生常谈NSString与NSMutableString
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-15T11:38:34+08:00" content="2016-08-15">
              2016-08-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/15/老生常谈NSString与NSMutableString/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/15/老生常谈NSString与NSMutableString/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/15/老生常谈NSString与NSMutableString/" class="leancloud_visitors" data-flag-title="老生常谈NSString与NSMutableString">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSString与NSMutableString是我们在写代码中最熟悉不过的了，今天我们就来完全彻底的认识一下他们。</p>
<h3 id="一-、NSConstantString"><a href="#一-、NSConstantString" class="headerlink" title="一 、NSConstantString"></a>一 、NSConstantString</h3><p>我们一般通过下面这种方法来创建一个字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *string1 = @&quot;Hello World!&quot;;</div><div class="line">NSString *string2 = @&quot;Hello World!&quot;;</div></pre></td></tr></table></figure>
<p>此时我们打印一下string1与string2的内存地址发现他们是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-08-15 11:14:22.661 StringTest[1028:98759] string1: 0x102c31050</div><div class="line">2016-08-15 11:14:22.661 StringTest[1028:98759] string1: 0x102c31050</div></pre></td></tr></table></figure>
<p>其实字string1与string2并不是真正包含一个字符串对象，而是指向内存中字符串对象的指针，字面量@”Hello World!”存储在文字常量区，指针string1与string2都指向它，他们在编译时真实类型是NSConstantString</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;string1:%@&quot;,[string1 class]);</div><div class="line">NSLog(@&quot;string2:%@&quot;,[string2 class]);</div><div class="line"></div><div class="line">输出为：</div><div class="line">string1:__NSCFConstantString</div><div class="line">string2:__NSCFConstantString</div></pre></td></tr></table></figure>
<p>NSConstantString是NSString的子类，是一个字符串常量，是在编译时创建的，并且是没有retainCount(引用计数的)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSString *string1 = @&quot;Hello World!&quot;;</div><div class="line">NSLog(@&quot;引用计数为：%lu&quot;,string1.retainCount);</div><div class="line">[string1 retainCount];</div><div class="line">NSLog(@&quot;retainCount后引用计数为：%lu&quot;,string1.retainCount);</div><div class="line"></div><div class="line">输出为：</div><div class="line">引用计数为：18446744073709551615</div><div class="line">retainCount后引用计数为：18446744073709551615</div></pre></td></tr></table></figure>
<p>由此可见，打印引用计数，以及retainCount一次后引用计数都为非正常值，所以说是无引用计数的.<br>再比如我在ViewController里定义了两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,strong)NSString *string1;</div><div class="line">@property(nonatomic,weak)NSString *string2;</div></pre></td></tr></table></figure>
<p>然后在实现方法里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.string1 = @&quot;Hello World!&quot;;</div><div class="line">self.string2 = self.string1;</div><div class="line">self.string1 = nil;</div><div class="line">NSLog(@&quot;%@ %@&quot;,self.string1,self.string2);</div></pre></td></tr></table></figure>
<p>由于string2修饰符是weak，当我让self.string1 = nil时，self.string2也应该为nil，但输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-08-15 14:09:47.400 StringTest[1265:166991] (null) Hello World!</div></pre></td></tr></table></figure>
<p>self.string2还有值！<br>原因还是上面所说的，NSConstantString类型的字符串没有引用计数，所以没有强指针指向它，它也不会被销毁。那怎么也让self.string2也为nil呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.string1 = [[NSMutableString alloc] initWithFormat:@&quot;Hello World!&quot;];</div></pre></td></tr></table></figure>
<p>只要这样初始化self.string1就可以啦,此时self.string1类型为__NSCFString，除此之外还有一种类型NSTaggedPointerString，它也是NSString的子类，也是无引用计数的。关于Tagged Pointer，它是苹果为了节省内存和提高执行效率引进的概念，对于64位程序，能大大提高访问速度及减少内存占用，可以看看这篇文章 <a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/" target="_blank" rel="external">深入理解Tagged Pointer</a></p>
<h3 id="二、copy与strong"><a href="#二、copy与strong" class="headerlink" title="二、copy与strong"></a>二、copy与strong</h3><p>我们在一个类里声明两个字符串属性,一个修饰符是strong，一个copy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,strong)NSString *strongStr;</div><div class="line">@property(nonatomic,copy)NSString *copyedStr;</div></pre></td></tr></table></figure>
<p>首先，我们用一个不可变字符串来为他们赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;Hello World!&quot;;</div><div class="line">self.strongStr = string;</div><div class="line">self.copyedStr = string;</div><div class="line">NSLog(@&quot;string:    %@, %p, %p&quot;,string, string,&amp;string);</div><div class="line">NSLog(@&quot;strongStr: %@, %p, %p&quot;,_strongStr,_strongStr,&amp;_strongStr);</div><div class="line">NSLog(@&quot;copyedStr: %@, %p, %p&quot;,_copyedStr,_copyedStr,&amp;_copyedStr);</div></pre></td></tr></table></figure>
<p> 输出分别是值，内存地址，指针地址，输出为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string:    Hello World!, 0x101314078, 0x7fff5e8eba68</div><div class="line">strongStr: Hello World!, 0x101314078, 0x7f8951f48b60</div><div class="line">copyedStr: Hello World!, 0x101314078, 0x7f8951f48b68</div></pre></td></tr></table></figure>
<p> 由此可见，不管是strong还是copy，string指向的地址都是同一个，假设string有引用计数的话,strong操作和copy操作都使string得引用计数加1。</p>
<p>接下来，我们把string变成可变对象，并且在对self.strongStr,self.copyedStr赋值后修改string的值，再看一下输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;Hello World!&quot;];</div><div class="line">self.strongStr = string;</div><div class="line">self.copyedStr = string;</div><div class="line">//在这里修改一下string的值</div><div class="line">[string appendFormat:@&quot;Hi!&quot;];</div><div class="line"></div><div class="line">NSLog(@&quot;string:    %@, %p, %p&quot;,string, string,&amp;string);</div><div class="line">NSLog(@&quot;strongStr: %@, %p, %p&quot;,_strongStr,_strongStr,&amp;_strongStr);</div><div class="line">NSLog(@&quot;copyedStr: %@, %p, %p&quot;,_copyedStr,_copyedStr,&amp;_copyedStr);</div><div class="line">NSLog(@&quot;%lu %lu&quot;,string.retainCount,self.copyedStr.retainCount);</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string:    Hello World!Hi!, 0x7fea9ae0abb0, 0x7fff59876a68</div><div class="line">strongStr: Hello World!Hi!, 0x7fea9ae0abb0, 0x7fea9ad32500</div><div class="line">copyedStr: Hello World!, 0x7fea9ae0d4c0, 0x7fea9ad32508</div><div class="line">2 1</div></pre></td></tr></table></figure>
<p> 可以发现，copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让_copyedStr指向了这个字符串，string的值再发生改变时，_copyedStr的值不会发生变化。此时string的引用计数为2,self.copyedStr引用计数为1.</p>
<p> 由上面的例子可以看出，当源字符串是NSString时，由于字符串是不可变的，所以，不管strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>
<p> 当源字符串是NSMutableString时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。</p>
<p> 所以，在声明NSString时，到底是选择strong还是copy，视情况而定。不过，一般我们将对象声明为NSString时，都不希望它改变，所以，大多情况下，我们建议用copy</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/12/新的博客，新的开始/" itemprop="url">
                  新的博客，新的开始
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-12T13:57:19+08:00" content="2016-08-12">
              2016-08-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/12/新的博客，新的开始/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/12/新的博客，新的开始/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/12/新的博客，新的开始/" class="leancloud_visitors" data-flag-title="新的博客，新的开始">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看到别人都有自己的技术博客，一时心血来潮，自己也建一个，由于对这方面一窍不通，查了好多资料，用了整整一天，才把这个博客建立起来。</p>
<p>作为一个搞IT开发的，拥有属于自己的技术博客是必须的，这个博客算是对自己学习过程的记录吧，公司项目不忙的话，尽量多抽点时间学点技术写博客，写完之后你会对所写的技术理解更加深刻，记忆也就越深，总之，也督促自己一定要不断学习。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ocauxqtbu.bkt.clouddn.com/27563317749u=2381918280,2871499884&fm=21&gp=0.jpg"
               alt="Zhou Jian" />
          <p class="site-author-name" itemprop="name">Zhou Jian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coderZhou10496" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"coderzhou"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Bw40KBIPanRkt0iqTr7NLT6I-gzGzoHsz", "MQjFPSYkEazqnUv2rS7TOsui");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
