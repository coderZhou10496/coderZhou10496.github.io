<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Jianless的博客">
<meta property="og:url" content="http://coderzhou.com/index.html">
<meta property="og:site_name" content="Jianless的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jianless的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coderzhou.com/"/>

  <title> Jianless的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Jianless的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">专注于iOS开发</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/" itemprop="url">
                  Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-21T20:36:51+08:00" content="2019-02-21">
              2019-02-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/" class="leancloud_visitors" data-flag-title="Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>闲暇时间用Metal撸了一个图片处理demo，也查阅参考了很多大佬的文章，demo代码已上传至<a href="https://github.com/coderZhou10496/Filter" target="_blank" rel="external">Github</a></p>
<h3 id="LUT滤镜"><a href="#LUT滤镜" class="headerlink" title="LUT滤镜"></a>LUT滤镜</h3><p>LUT是look up table，查找表的缩写，所有的颜色都可以在一张表(图片)上找到。我们知道R、G、B三种颜色分别有256种取值，所有的颜色组合就有256X256X256种情况，大约占48MB空间，占用很大的内存，但是有了LUT映射表后，我就可以对任意一张图片进行相同的滤镜变换。</p>
<p>我们遍历图片的像素点，对于每一个像素点，获得其 RGB 组合，在 LUT 表格中查找此 RGB 组合及其对应的 RGB 映射值，然后用 RGB 映射值替换原图的像素点，就可以完成滤镜变换了。但是如何在一张图片中存储三种颜色值的组合呢？</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/original.png" width="50%"><br></div>

<p><br></p>
<p>上图就是一张标准的颜色查找表。它在横竖方向上分成了 8X8 一共 64 个小方格，每一个小方格内的 B 分量为一个定值，总共就表示了 B 分量的 64 种可能值。同时对于每一个小方格，横竖方向又各自分为 64 个小格，横向小格的 R 分量依次增加，纵向小格的 G 分量依次增加。即：</p>
<ul>
<li>整体对每个小方块而言，从左上往右下 B 从 0 到 1 ，是 z 字型的顺序</li>
<li>单独对每个小方块而言，从左到右 R 从 0 到 1，代表 x</li>
<li>单独对每个小方块而言，从上到下 G 从 0 到 1，代表 y</li>
</ul>
<p>那么根据颜色查找表得到转换后的颜色步骤为：</p>
<p>1、用蓝色值R计算正方形的位置，假如一个像素点原来rgb是(0.1, 0.2, 0.4)，那么B = 0.4，则(0.4 <em> 63 = 25.6)/8 = 3，（25 - 3 </em> 8）= 1，即第3行第1列的那个大正方形，quad1.y = 3，quad1.x = 1.</p>
<p>2、根据红色值和绿色值计算对应位置在整个纹理的坐标。</p>
<p>texPos1.x = (quad1.x <em> 64 + rgb.r </em> 63 + 0.5)/512.0</p>
<p>texPos1.y = (quad1.y <em> 64 + rgb.g </em> 63 + 0.5)/512.0</p>
<p>这里，quad1.x * 64意思是：quad1.x和quad1.y是大正方形的坐标，每个大正方形是64格，所以乘以64；</p>
<p>rgb.r * 63意思是：每个大正方形是64格，即(0,63)；</p>
<p>加上0.5表示每个最小的小正方形的中心点；最后除以512.0是因为整个lut图片是512 * 512的，被放大了512倍。最后得到的是每个小正方格中心在整个lut大图中的坐标。</p>
<p>3、根据texPos1和texPos2读取映射结果，再用蓝色值的小数部分进行mix操作</p>
<p>shader代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">fragment float4</div><div class="line">lookUpTableShader(RasterizerData input [[stage_in]], // stage_in表示这个数据来自光栅化。（光栅化是顶点处理之后的步骤，业务层无法修改）</div><div class="line">               texture2d&lt;float&gt; normalTexture [[ texture(LYFragmentTextureIndexNormal) ]], // texture表明是纹理数据，LYFragmentTextureIndexNormal是索引</div><div class="line">               texture2d&lt;float&gt; lookupTableTexture [[ texture(LYFragmentTextureIndexLookupTable) ]]) // texture表明</div><div class="line">&#123;</div><div class="line">    constexpr sampler textureSampler (mag_filter::linear,</div><div class="line">                                      min_filter::linear); // sampler是采样器</div><div class="line">    float4 textureColor = normalTexture.sample(textureSampler, input.textureCoordinate); //正常的纹理颜色</div><div class="line">    </div><div class="line">    float blueColor = textureColor.b * 63.0; // 蓝色部分[0, 63] 共64种</div><div class="line">    </div><div class="line">    float2 quad1; // 第一个正方形的位置, 假如blueColor=22.5，则y=22/8=2，x=22-8*2=6，即是第2行，第6个正方形；（因为y是纵坐标）</div><div class="line">    quad1.y = floor(floor(blueColor) * 0.125);</div><div class="line">    quad1.x = floor(blueColor) - (quad1.y * 8.0);</div><div class="line">    </div><div class="line">    float2 quad2; // 第二个正方形的位置，同上。注意x、y坐标的计算，还有这里用int值也可以，但是为了效率使用float</div><div class="line">    quad2.y = floor(ceil(blueColor) * 0.125);</div><div class="line">    quad2.x = ceil(blueColor) - (quad2.y * 8.0);</div><div class="line">    </div><div class="line">    float2 texPos1; // 计算颜色(r,b,g)在第一个正方形中对应位置</div><div class="line">    texPos1.x = ((quad1.x * 64) +  textureColor.r*63 + 0.5)/512.0;</div><div class="line">    texPos1.y = ((quad1.y * 64) +  textureColor.g*63 + 0.5)/512.0;</div><div class="line">    </div><div class="line">    </div><div class="line">    float2 texPos2; // 同上</div><div class="line">    texPos2.x = ((quad2.x * 64) +  textureColor.r*63 + 0.5)/512.0;</div><div class="line">    texPos2.y = ((quad2.y * 64) +  textureColor.g*63 + 0.5)/512.0;</div><div class="line">    </div><div class="line">    float4 newColor1 = lookupTableTexture.sample(textureSampler, texPos1); // 正方形1的颜色值</div><div class="line">    float4 newColor2 = lookupTableTexture.sample(textureSampler, texPos2); // 正方形2的颜色值</div><div class="line">    </div><div class="line">    float4 newColor = mix(newColor1, newColor2, fract(blueColor)); // 根据小数点的部分进行mix</div><div class="line">    return float4(newColor.rgb, textureColor.w); //不修改alpha值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话我们就能从颜色查找表中得到了对应的转换后的颜色。</p>
<p>如果使用lut进行滤镜，那么每一种滤镜效果都对应着一张颜色查找表。上面给出的图片是原色的颜色查找表，所以使用这张查找表对要滤镜的图片进行处理的话，要滤镜的图片不会有任何变化。</p>
<p>而使用有滤镜效果的查找表进行处理，会有滤镜的效果</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_xiaoguo_1.jpg" width="70%" height="50%"><br></div>

<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_xiaoguo_2.jpg" width="70%" height="50%"><br></div>

<p><br></p>
<p>代码里，我封装了一个<code>ZJLookupTableImageFilter</code>工具类来进行lut滤镜，只需要传入一个MTKView和lut图片就可以进行lut滤镜</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface ZJLookupTableImageFilter : ZJBaseImageFilter</div><div class="line"></div><div class="line">+ (void)filterWithImageView:(ZJShaderLookupImageView *)imageView lookupTableImage:(UIImage *)lutImage;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的lookUpTableShader代码里传入了两个参数，一个是正常图片的texture，另一个是lut图片的texture，所以每选中一个lut图片对原图片进行滤镜处理时，需要得到lut图片的texture.这里我通过<code>ZJTextureProvider</code>这个工具类来获得一张图片的texture。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</div><div class="line">                                                                                             width:width</div><div class="line">                                                                                            height:height</div><div class="line">                                                                                         mipmapped:NO];</div><div class="line">textureDescriptor.usage = MTLTextureUsageShaderRead;</div><div class="line">id&lt;MTLTexture&gt; texture = [context.device newTextureWithDescriptor:textureDescriptor];</div><div class="line"></div><div class="line"></div><div class="line">MTLRegion region = &#123;&#123; 0, 0, 0 &#125;, &#123;image.size.width, image.size.height, 1&#125;&#125;; // 纹理上传的范围</div><div class="line">[texture replaceRegion:region mipmapLevel:0 withBytes:spriteData bytesPerRow:4 * image.size.width];</div><div class="line">free(spriteData);</div></pre></td></tr></table></figure>
<p>然后通过这行代码传入shader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[renderEncoder setFragmentTexture:self.lookupTableTexture</div><div class="line">                                  atIndex:1];</div></pre></td></tr></table></figure>
<p>注意这里index要传1，要和shader中的<code>LYFragmentTextureIndexLookupTable</code>对应</p>
<h3 id="颜色饱和度、模糊度"><a href="#颜色饱和度、模糊度" class="headerlink" title="颜色饱和度、模糊度"></a>颜色饱和度、模糊度</h3><p>模糊后的图片，可调节颜色饱和度及模糊度:</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_blur.jpg" width="50%" height="50%"><br></div>

<p><br></p>
<p>（本来是录制了一个视频的，但是有4M多，半天显示不出来，只好放图片了。）</p>
<p>无论是lut滤镜，还是模糊度调节，都是使用<code>MTLComputeCommandEncoder</code>来处理的。通过<code>computeCommandEncoder</code>方法来获得对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id&lt;MTLComputeCommandEncoder&gt; computeEncoder = [commandBuffer computeCommandEncoder]</div></pre></td></tr></table></figure>
<p>其中有一个地方要设置编码的线程组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[computeEncoder dispatchThreadgroups:self.groupCount</div><div class="line">                   threadsPerThreadgroup:self.groupSize];</div></pre></td></tr></table></figure>
<p>代码里使用<code>ZJShaderImageFilter</code>来进行饱和度模糊度调节，传入需要调节的图片及颜色饱和度value(0,1.0)，模糊度value(0,1.0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (void)shaderImageViewWithView:(ZJShaderImageView *)imageView </div><div class="line">   					saturationValue:(float)saturationValue </div><div class="line">   					blurRadiusValue:(float)blurRadiusValue</div></pre></td></tr></table></figure>
<p>两种效果的shader代码分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">kernel void adjust_saturation(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</div><div class="line">                              texture2d&lt;float, access::write&gt; outTexture [[texture(1)]],</div><div class="line">                              constant AdjustSaturationUniforms &amp;uniforms [[buffer(0)]],</div><div class="line">                              uint2 gid [[thread_position_in_grid]])</div><div class="line">&#123;</div><div class="line">    float4 inColor = inTexture.read(gid);</div><div class="line">    float value = dot(inColor.rgb, float3(0.299, 0.587, 0.114));</div><div class="line">    float4 grayColor(value, value, value, 1.0);</div><div class="line">    float4 outColor = mix(grayColor, inColor, uniforms.saturationFactor);</div><div class="line">    outTexture.write(outColor, gid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">kernel void gaussian_blur_2d(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</div><div class="line">                             texture2d&lt;float, access::write&gt; outTexture [[texture(1)]],</div><div class="line">                             texture2d&lt;float, access::read&gt; weights [[texture(2)]],</div><div class="line">                             uint2 gid [[thread_position_in_grid]])</div><div class="line">&#123;</div><div class="line">    int size = weights.get_width();</div><div class="line">    int radius = size / 2;</div><div class="line">    </div><div class="line">    float4 accumColor(0, 0, 0, 0);</div><div class="line">    for (int j = 0; j &lt; size; ++j)</div><div class="line">    &#123;</div><div class="line">        for (int i = 0; i &lt; size; ++i)</div><div class="line">        &#123;</div><div class="line">            uint2 kernelIndex(i, j);</div><div class="line">            uint2 textureIndex(gid.x + (i - radius), gid.y + (j - radius));</div><div class="line">            float4 color = inTexture.read(textureIndex).rgba;</div><div class="line">            float4 weight = weights.read(kernelIndex).rrrr;</div><div class="line">            accumColor += weight * color;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    outTexture.write(float4(accumColor.rgb, 1), gid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只需要处理texture，把最终的处理结果传给片元函数就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[renderEncoder setFragmentTexture:_texture</div><div class="line">                                  atIndex:0];</div></pre></td></tr></table></figure>
<p>即这里的_texture需要由外部控制，由<code>ZJShaderImageFilter</code>分别经过饱和度处理，模糊度处理后将最终需要传给shader的texture传入。</p>
<p>饱和度处理时，需要额外传入buffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct AdjustSaturationUniforms uniforms;</div><div class="line">    uniforms.saturationFactor = self.isDirty ? self.saturValue : 1.0;</div><div class="line">    id&lt;MTLBuffer&gt; buffer = [self.metalContext.device newBufferWithLength:sizeof(uniforms)</div><div class="line">                                                                 options:MTLResourceOptionCPUCacheModeDefault];</div><div class="line">    memcpy([buffer contents], &amp;uniforms, sizeof(uniforms));</div><div class="line">    </div><div class="line">    [computeEncoder setBuffer:buffer offset:0 atIndex:0];</div></pre></td></tr></table></figure>
<p>而对于模糊度处理，需要额外传入texture:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(self.blurTexture == nil) &#123;</div><div class="line">            [self configBlurTexture];</div><div class="line">        &#125;</div><div class="line">        [computeEncoder setTexture:self.blurTexture</div><div class="line">                           atIndex:2];</div></pre></td></tr></table></figure>
<p>当texture经过编码器(Command Encoder)分别经过饱和度处理和模糊处理时<br>我们是先处理饱和度，后处理模糊度，即饱和度的texture输出outputTexture,为模糊度的输入inputTexture,而模糊度的输出为shader的输入。所以一定要保证饱和度经过编码器(Command Encoder)处理后，再去进行模糊操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[commandBuffer waitUntilCompleted]</div></pre></td></tr></table></figure>
<p>最后一张简单的框架处理流程：</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_liucheng.jpg" width="100%"><br></div>

<p><br></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/21/Metal学习(一)：基本概念介绍/" itemprop="url">
                  Metal学习(一)：基本概念介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-21T20:13:10+08:00" content="2019-02-21">
              2019-02-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/21/Metal学习(一)：基本概念介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/21/Metal学习(一)：基本概念介绍/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/02/21/Metal学习(一)：基本概念介绍/" class="leancloud_visitors" data-flag-title="Metal学习(一)：基本概念介绍">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>断断续续的学习了<a href="https://developer.apple.com/documentation/metal?language=objc" target="_blank" rel="external">Metal</a>，整理下。</p>
<p>关于Metal的介绍，先引用官方文档的一句话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The Metal framework supports GPU-accelerated advanced 3D graphics rendering and data-parallel computation workloads. </div><div class="line">Metal provides a modern and streamlined API for fine-grained, low-level control of the organization, processing, </div><div class="line">and submission of graphics and computation commands, as well as the management of the associated data and resources </div><div class="line">for these commands. A primary goal of Metal is to minimize the CPU overhead incurred by executing GPU workloads.</div></pre></td></tr></table></figure>
<p>意思就是Metal框架提供了GPU加速的高级3D图形渲染功能和数据并行计算的功能，能够更有效地集成图形和计算任务，减小CPU消耗。</p>
<p>Metal优点：</p>
<ul>
<li>GPU 支持的 3D 渲染</li>
<li>和 CPU 并行处理数据 （深度学习）</li>
<li>提供低功耗接口</li>
<li>与 CPU 共享资源内存</li>
</ul>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/Metal_kuangjia.jpg" width="50%" height="50%"><br></div>



<p>Core Animation 依赖于 Metal 做 GPU 渲染，Core Graphics 做 CPU 渲染.</p>
<p>并且在iOS12中，苹果已经弃用了<a href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">OpenGL ES</a>对底层的支持，全面由Metal渲染。可见，苹果对于Metal框架越来越重视。研究Metal框架对于我们了解iOS系统是如何运作的，是怎么支持CoreAnimation框架进行渲染的有很大的帮助。并且用Metal能帮助我们实现一些很有意思的功能，比如图像处理，视频滤镜，高并发运算等。</p>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>在Metal架构中，<code>MTLDevice</code>协议定义了代表单个GPU的接口。与Metal交互所需的对象都来自于获取的<code>MTLDevice</code>。我们可以通过<code>MTLCreateSystemDefaultDevice</code>来获取所需要操作的GPU对象</p>
<h3 id="MLBuffer"><a href="#MLBuffer" class="headerlink" title="MLBuffer"></a>MLBuffer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A memory allocation for storing unformatted data that is accessible to the GPU.</div></pre></td></tr></table></figure>
<p>MLBuffer可以理解为一块连续的内存，它里面存储的数据，是没有格式、类型限制的，即可以存储任意类型的数据，是GPU可访问的专用容器，使图形渲染管道能够从中读取顶点数据。在Metal中用于存储顶点数据。</p>
<p>一般使用这个方法来创建MTLBuffer对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;MTLBuffer&gt;)newBufferWithBytes:(const void *)pointer </div><div class="line">									 length:(NSUInteger)length </div><div class="line">									 options:(MTLResourceOptions)options</div></pre></td></tr></table></figure>
<h3 id="MTLTexture"><a href="#MTLTexture" class="headerlink" title="MTLTexture"></a>MTLTexture</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A memory allocation for storing formatted image data that is accessible to the GPU.</div></pre></td></tr></table></figure>
<p>从开发者角度来看，texture 是一个名词，我们通常说的纹理，指的是一张二维的图片，把它像贴纸一样贴在视图上（采样），使得屏幕显示出我们想要的样子。</p>
<p>但在物理上， texture 指的是 GPU 显存中一段连续的空间，用来存放图像数据。</p>
<p>创建一个MTLTexture对象，需要用到MTLTextureDescriptor，即对纹理相关属性的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">MTLTextureDescriptor *textureDescriptor = [[MTLTextureDescriptor alloc] init];</div><div class="line"></div><div class="line">//  表明每个像素都有一个蓝色，绿色，红色和alpha通道，每个通道都是一个8位无符号标准化值</div><div class="line">textureDescriptor.pixelFormat = MTLPixelFormatBGRA8Unorm;</div><div class="line"></div><div class="line"> //设置纹理的像素尺寸</div><div class="line">textureDescriptor.width = image.width;</div><div class="line">textureDescriptor.height = image.height;</div><div class="line"></div><div class="line">// 通过 descriptor 创建纹理对象</div><div class="line">_texture = [_device newTextureWithDescriptor:textureDescriptor];</div><div class="line"></div><div class="line">// Calculate the number of bytes per row of our image.</div><div class="line">NSUInteger bytesPerRow = 4 * image.width;</div><div class="line"></div><div class="line">//MTLRegion结构用于识别纹理的特定区域。 此示例使用图像数据填充整个纹理; 因此，覆盖整个纹理的像素区域等于纹理的尺寸</div><div class="line">MTLRegion region = &#123;</div><div class="line">    &#123; 0, 0, 0 &#125;,                   // MTLOrigin</div><div class="line">    &#123;image.width, image.height, 1&#125; // MTLSize</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* 与存储多种自定义数据的MTLBuffer对象不同，MTLTexture对象专门用于存储格式化的图像数据。 尽管MTLTextureDescriptor对象指定足够的信息来分配纹理内存，但需要额外的信息来填充空纹理容器。 </div><div class="line">MTLTexture对象由replaceRegion：mipmapLevel：withBytes：bytesPerRow：方法填充图像数据。</div><div class="line">*/</div><div class="line">[_texture replaceRegion:region</div><div class="line">            mipmapLevel:0</div><div class="line">              withBytes:image.data.bytes</div><div class="line">            bytesPerRow:bytesPerRow];</div></pre></td></tr></table></figure>
<p>这里MTLRegion指的是texture中对应的图像区域，一般和图片大小保持一致。纹理坐标(0,0)默认在左下角，右上角为(1,1).</p>
<div align="center"><br><br><br><img src="https://docs-assets.developer.apple.com/published/a8fcc3ae6f/bd9ffd7d-01bf-45f2-8678-779fd47a7f9c.png" width="50%" height="50%"><br><br><br></div>


<h3 id="MTLLibrary"><a href="#MTLLibrary" class="headerlink" title="MTLLibrary"></a>MTLLibrary</h3><p>MTLLibrary负责加载定义在<code>.metal</code>文件中的着色器程序。通过MTLLibrary可以获得MTLFunction对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;MTLFunction&gt;) newFunctionWithName:(NSString *)functionName;</div></pre></td></tr></table></figure>
<h3 id="MTLCommandQueue，MTLCommandBuffer"><a href="#MTLCommandQueue，MTLCommandBuffer" class="headerlink" title="MTLCommandQueue，MTLCommandBuffer"></a>MTLCommandQueue，MTLCommandBuffer</h3><p>MTLCommandQueue由device创建，是整个app绘制的队列，而command buffer存放每次渲染的指令,即包含了每次渲染所需要的信息，直到指令被提交到GPU执行。Command queue用于创建和组织MTLCommandBuffer，其内部存在着多个command buffer，并且保证指令（command buffer）有序地发送到GPU。</p>
<p>command buffer是“一次性对象”，不支持重用。一旦command buffer被提交执行，唯一能做的是等待command buffer被调度或完成。</p>
<ul>
<li>Command buffers是从command queue里创建的</li>
<li>Command encoders将渲染指令command填充到command buffers</li>
<li>Command buffers将数据提交到GPU</li>
<li>GPU开始执行，呈现结果</li>
</ul>
<p><img src="https://docs-assets.developer.apple.com/published/6aedb538f8/b5ff0489-1079-441a-8a24-8f8c75dd2b1e.png" alt="MTLCommandBuffer"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">// Create a new command buffer for each render pass to the current drawable</div><div class="line">id&lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer];</div><div class="line">commandBuffer.label = @&quot;MyCommand&quot;;</div><div class="line">// Obtain a renderPassDescriptor generated from the view&apos;s drawable textures</div><div class="line">MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;</div><div class="line"></div><div class="line">if(renderPassDescriptor != nil)</div><div class="line">&#123;</div><div class="line">    // Create a render command encoder so we can render into something</div><div class="line">    id&lt;MTLRenderCommandEncoder&gt; renderEncoder =</div><div class="line">    [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];</div><div class="line">    renderEncoder.label = @&quot;MyRenderEncoder&quot;;</div><div class="line"></div><div class="line">    // 设置显示区域</div><div class="line">    [renderEncoder setViewport:(MTLViewport)&#123;0.0, 0.0, _viewportSize.x, _viewportSize.y, -1.0, 1.0 &#125;];</div><div class="line"></div><div class="line">    // 设置渲染管道，以保证顶点和片元两个shader会被调用</div><div class="line">    [renderEncoder setRenderPipelineState:_pipelineState];</div><div class="line"></div><div class="line">    // 设置顶点缓存</div><div class="line">    [renderEncoder setVertexBuffer:_vertices</div><div class="line">                            offset:0</div><div class="line">                          atIndex:AAPLVertexInputIndexVertices];</div><div class="line">    </div><div class="line">    [renderEncoder setVertexBytes:&amp;_viewportSize</div><div class="line">                           length:sizeof(_viewportSize)</div><div class="line">                          atIndex:AAPLVertexInputIndexViewportSize];</div><div class="line">    // 设置纹理</div><div class="line">    [renderEncoder setFragmentTexture:_texture</div><div class="line">                              atIndex:AAPLTextureIndexBaseColor];</div><div class="line">    // // 绘制</div><div class="line">    [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle</div><div class="line">                      vertexStart:0</div><div class="line">                      vertexCount:_numVertices];</div><div class="line">     // 结束</div><div class="line">    [renderEncoder endEncoding];</div><div class="line">    // 显示</div><div class="line">    [commandBuffer presentDrawable:view.currentDrawable];</div><div class="line">&#125;</div><div class="line">// Finalize rendering here &amp; push the command buffer to the GPU</div><div class="line">[commandBuffer commit];</div></pre></td></tr></table></figure>
<h3 id="MTLCommandEncoder"><a href="#MTLCommandEncoder" class="headerlink" title="MTLCommandEncoder"></a>MTLCommandEncoder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">An encoder that writes GPU commands into a command buffer</div></pre></td></tr></table></figure>
<p>编码器(Command Encoder)，将我们描述的高级指令，编码转换成GPU可以理解的低级指令(GPU commands)，写入command buffer中。</p>
<pre><code>Protocol | Description |  
------ | -------- | 
MTLRenderCommandEncoder | 用于图形渲染任务的编码器 |  
MTLComputeCommandEncoder | 用于计算任务的编码器 | 
MTLBlitCommandEncoder | 用于内存管理任务的编码器 |  
MTLParallelRenderCommandEncoder | 用于并行编码的多个图形渲染任务的编码器 | 
</code></pre><p>关于buffer，texture，Command Encoder,Command Queue之间的关系，借用官方的一张图，理得很清楚</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Cmd-Model-1_2x.png" alt="blockchain"></p>
<h3 id="Metal-Shader-Language"><a href="#Metal-Shader-Language" class="headerlink" title="Metal Shader Language"></a>Metal Shader Language</h3><p><a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf" target="_blank" rel="external">Metal Shader Language</a>我觉得是学Metal遇到的最大阻力了，并且只能看官方文档来学习，网上讲解的资料也很少，我也只是了解了个大概。</p>
<p>shader有三个基本函数：</p>
<p>顶点函数（vertex），对每个顶点进行处理，生成数据并输出到绘制管线，作为片元函数的输入；</p>
<p>片元函数（fragment），对光栅化后的每个像素点进行处理，生成数据并输出到绘制管线；</p>
<p>通用计算函数（kernel），是并行计算的函数，其返回值类型必须为void；</p>
<p>比如一个顶点函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    float4 clipSpacePosition [[position]]; // position的修饰符表示这个是顶点</div><div class="line">    </div><div class="line">    float2 textureCoordinate; // 纹理坐标，会做插值处理</div><div class="line">    </div><div class="line">&#125; RasterizerData;</div><div class="line"></div><div class="line">vertex RasterizerData // 返回给片元着色器的结构体</div><div class="line">vertexShader(uint vertexID [[ vertex_id ]], // vertex_id是顶点shader每次处理的index，用于定位当前的顶点</div><div class="line">             constant  ZJVertex*vertexArray [[ buffer(0) ]]) &#123; // buffer表明是缓存数据，0是索引</div><div class="line">    RasterizerData out;</div><div class="line">    out.clipSpacePosition = vertexArray[vertexID].position;</div><div class="line">    out.textureCoordinate = vertexArray[vertexID].textureCoordinate;</div><div class="line">    return out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的功能是把从 Metal API 绑定的数据从ZJVertex结构体封装成RasterizerData结构体并交给片元着色器。</p>
<p>比如一个片元函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fragment float4</div><div class="line">samplingShader(RasterizerData input [[stage_in]], // stage_in表示这个数据来自光栅化。（光栅化是顶点处理之后的步骤，业务层无法修改）</div><div class="line">               texture2d&lt;half&gt; colorTexture [[ texture(0) ]]) // texture表明是纹理数据，0是索引</div><div class="line">&#123;</div><div class="line">    constexpr sampler textureSampler (mag_filter::linear,</div><div class="line">                                      min_filter::linear); // sampler是采样器 决定如何对一个纹理进行采样操作。寻址模式，过滤模式，归一化坐标，比较函数</div><div class="line">    </div><div class="line">    half4 colorSample = colorTexture.sample(textureSampler, input.textureCoordinate); // 得到纹理对应位置的颜色</div><div class="line">    </div><div class="line">    float4 color = float4(colorSample);</div><div class="line">    return color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>片元着色器用于处理片元，它的返回值是这个片元的颜色，是一个四维向量。从输入的结构体中取出纹理坐标，利用采样器对纹理采样，拿到对应坐标的颜色值的RGB值，最后返回这个片元的颜色值。</p>
<p>对于没接触过图形学人来说，这些名词比较陌生，可能一时难于理解，主要是多看多练，写多了就理解它们的意义了。</p>
<p>接下会写一下Metal的渲染过程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/02/Metal学习(二)：渲染过程/" itemprop="url">
                  Metal学习(二)：渲染过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-02T16:54:54+08:00" content="2019-02-02">
              2019-02-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/02/Metal学习(二)：渲染过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/02/Metal学习(二)：渲染过程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/02/02/Metal学习(二)：渲染过程/" class="leancloud_visitors" data-flag-title="Metal学习(二)：渲染过程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="渲染管线Pipeline"><a href="#渲染管线Pipeline" class="headerlink" title="渲染管线Pipeline"></a>渲染管线Pipeline</h3><p>在图形处理中中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，所以我们大部分工作都是把3D坐标转变为适应屏幕的2D像素。3D坐标转为2D坐标的处理过程是由的图形渲染管线（Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p>
<p>图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>
<h3 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h3><p>以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。</p>
<a href="!--![Pipeline](https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/PipelineState_2x.png)--">!--![Pipeline](https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/PipelineState_2x.png)--</a>
<h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p>为了让系统知道我们的坐标和颜色值构成的到底是什么，需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一个点？一个三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元。</p>
<p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状。</p>
<h3 id="Vertex-function："><a href="#Vertex-function：" class="headerlink" title="Vertex function："></a>Vertex function：</h3><p>接收一组顶点数据数组，每个顶点执行一次运算，计算该顶点的坐标，颜色，光照，纹理坐标等，在渲染管线中每个顶点都是独立地被执行。每个图元由一个或者多个顶点组成，每个顶点定义一个点，一条边的一端或者三角形的一个角。每个顶点关联一些数据，这些数据包括顶点坐标，颜色，法向量以及纹理坐标等。所有这些顶点相关的信息就构成顶点数据。<br>Vertex function的返回值会被作为片元着色器函数的输入。</p>
<h3 id="Rasterization："><a href="#Rasterization：" class="headerlink" title="Rasterization："></a>Rasterization：</h3><p>在光栅化阶段，基本图元被转换为供片段着色器使用的片段。简单来说，就是将数据转化成可见像素的过程。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。在Metal中，这一步是用户控制不了的，由系统自动处理</p>
<h3 id="Fragment-function"><a href="#Fragment-function" class="headerlink" title="Fragment function"></a>Fragment function</h3><p>片段着色器的主要作用是计算一个像素的最终颜色<br>在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样(从纹理坐标获取纹理颜色叫做采样(Sampling))，以计算该片段的颜色值。从而调整成各种各样不同的效果图，这也是所有OpenGL或Metal高级效果产生的地方<br>片段着色器的返回值是一个四维向量，即是这个片元的颜色 RGBA 值</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/gfx-pipeline_2x.png" alt="Pipeline"></p>
<p>渲染过程：<br>读取顶点数据——执行顶点着色器——组装图元——光栅化图元——执行片元着色器——写入帧缓冲区——显示到屏幕上。</p>
<p>下面就以实际代码来看一下,以<a href="https://developer.apple.com/documentation/metal/basic_texturing?language=objc" target="_blank" rel="external">官方Demo</a>为例：</p>
<p>初始化顶点数据，然后根据顶点数据来计算顶点数量及MTLBuffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Set up a simple MTLBuffer with our vertices which include texture coordinates</div><div class="line">static const AAPLVertex quadVertices[] =</div><div class="line">&#123;</div><div class="line">    // Pixel positions, Texture coordinates</div><div class="line">    &#123; &#123;  250,  -250 &#125;,  &#123; 1.f, 0.f &#125; &#125;,</div><div class="line">    &#123; &#123; -250,  -250 &#125;,  &#123; 0.f, 0.f &#125; &#125;,</div><div class="line">    &#123; &#123; -250,   250 &#125;,  &#123; 0.f, 1.f &#125; &#125;,</div><div class="line"></div><div class="line">    &#123; &#123;  250,  -250 &#125;,  &#123; 1.f, 0.f &#125; &#125;,</div><div class="line">    &#123; &#123; -250,   250 &#125;,  &#123; 0.f, 1.f &#125; &#125;,</div><div class="line">    &#123; &#123;  250,   250 &#125;,  &#123; 1.f, 1.f &#125; &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// Create our vertex buffer, and initialize it with our quadVertices array</div><div class="line">_vertices = [_device newBufferWithBytes:quadVertices</div><div class="line">                                 length:sizeof(quadVertices)</div><div class="line">                                options:MTLResourceStorageModeShared];</div><div class="line"></div><div class="line"> // 通过将字节长度除以每个顶点的大小来计算顶点的数量</div><div class="line">_numVertices = sizeof(quadVertices) / sizeof(AAPLVertex);</div></pre></td></tr></table></figure>
<p>然后获得图片数据，根据图片数据来设置MTLTexture</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">NSURL *imageFileLocation = [[NSBundle mainBundle] URLForResource:@&quot;Image&quot;</div><div class="line">                                                   withExtension:@&quot;tga&quot;];</div><div class="line">AAPLImage * image = [[AAPLImage alloc] initWithTGAFileAtLocation:imageFileLocation];</div><div class="line">if(!image)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;Failed to create the image from %@&quot;, imageFileLocation.absoluteString);</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line">MTLTextureDescriptor *textureDescriptor = [[MTLTextureDescriptor alloc] init];</div><div class="line"></div><div class="line">//  表明每个像素都有一个蓝色，绿色，红色和alpha通道，每个通道都是一个8位无符号标准化值</div><div class="line">textureDescriptor.pixelFormat = MTLPixelFormatBGRA8Unorm;</div><div class="line"> //设置纹理的像素尺寸</div><div class="line">textureDescriptor.width = image.width;</div><div class="line">textureDescriptor.height = image.height;</div><div class="line">// 通过 descriptor 创建纹理对象</div><div class="line">_texture = [_device newTextureWithDescriptor:textureDescriptor];</div><div class="line">// Calculate the number of bytes per row of our image.</div><div class="line">NSUInteger bytesPerRow = 4 * image.width;</div><div class="line"></div><div class="line">//MTLRegion结构用于识别纹理的特定区域。 此示例使用图像数据填充整个纹理; 因此，覆盖整个纹理的像素区域等于纹理的尺寸</div><div class="line">MTLRegion region = &#123;</div><div class="line">    &#123; 0, 0, 0 &#125;,                   // MTLOrigin</div><div class="line">    &#123;image.width, image.height, 1&#125; // MTLSize</div><div class="line">&#125;;</div><div class="line">// 与存储多种自定义数据的MTLBuffer对象不同，MTLTexture对象专门用于存储格式化的图像数据。 尽管MTLTextureDescriptor对象指定足够的信息来分配纹理内存，但需要额外的信息来填充空纹理容器。 MTLTexture对象由replaceRegion：mipmapLevel：withBytes：bytesPerRow：方法填充图像数据。</div><div class="line">[_texture replaceRegion:region</div><div class="line">            mipmapLevel:0</div><div class="line">              withBytes:image.data.bytes</div><div class="line">            bytesPerRow:bytesPerRow];</div></pre></td></tr></table></figure>
<p>因为demo中给的是tga文件格式的图片，所以专门封装了一个类<code>AAPLImage</code>来处理图片。当然，我们也可以使用一下代码来获得texture</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">CGImageRef spriteImage = image.CGImage;</div><div class="line">// 1 读取图片的大小</div><div class="line">size_t width = CGImageGetWidth(spriteImage);</div><div class="line">size_t height = CGImageGetHeight(spriteImage);</div><div class="line">Byte * spriteData = (Byte *) calloc(width * height * 4, sizeof(Byte)); //rgba共4个byte</div><div class="line">CGContextRef spriteContext = CGBitmapContextCreate(spriteData, width, height, 8, width*4,</div><div class="line">                                                   CGImageGetColorSpace(spriteImage), kCGImageAlphaPremultipliedLast);</div><div class="line">    </div><div class="line">// 2 在CGContextRef上绘图</div><div class="line">CGContextDrawImage(spriteContext, CGRectMake(0, 0, width, height), spriteImage);</div><div class="line">CGContextRelease(spriteContext);</div><div class="line">    </div><div class="line">MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</div><div class="line">                                                                                             width:width</div><div class="line">                                                                                            height:height</div><div class="line">                                                                                         mipmapped:NO];</div><div class="line">textureDescriptor.usage = MTLTextureUsageShaderRead;</div><div class="line">id&lt;MTLTexture&gt; texture = [context.device newTextureWithDescriptor:textureDescriptor];</div><div class="line">    </div><div class="line">    </div><div class="line">MTLRegion region = &#123;&#123; 0, 0, 0 &#125;, &#123;image.size.width, image.size.height, 1&#125;&#125;; // 纹理上传的范围</div><div class="line">[texture replaceRegion:region mipmapLevel:0 withBytes:spriteData bytesPerRow:4 * image.size.width];</div><div class="line">free(spriteData);</div></pre></td></tr></table></figure>
<p>接下来就是初始化MTLRenderPipelineState及MTLCommandQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// Load all the shader files with a metal file extension in the project</div><div class="line">id&lt;MTLLibrary&gt; defaultLibrary = [_device newDefaultLibrary];</div><div class="line"></div><div class="line">// Load the vertex function from the library</div><div class="line">id&lt;MTLFunction&gt; vertexFunction = [defaultLibrary newFunctionWithName:@&quot;vertexShader&quot;];</div><div class="line"></div><div class="line">// Load the fragment function from the library</div><div class="line">id&lt;MTLFunction&gt; fragmentFunction = [defaultLibrary newFunctionWithName:@&quot;samplingShader&quot;];</div><div class="line"></div><div class="line">// Set up a descriptor for creating a pipeline state object</div><div class="line">MTLRenderPipelineDescriptor *pipelineStateDescriptor = [[MTLRenderPipelineDescriptor alloc] init];</div><div class="line">pipelineStateDescriptor.label = @&quot;Texturing Pipeline&quot;;</div><div class="line">pipelineStateDescriptor.vertexFunction = vertexFunction;</div><div class="line">pipelineStateDescriptor.fragmentFunction = fragmentFunction;</div><div class="line">pipelineStateDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat;</div><div class="line"></div><div class="line">NSError *error = NULL;</div><div class="line">_pipelineState = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor</div><div class="line">                                                         error:&amp;error];</div><div class="line"></div><div class="line">// Create the command queue</div><div class="line">_commandQueue = [_device newCommandQueue];</div></pre></td></tr></table></figure>
<p>最后就是绘制视图调用的<code>- (void)drawInMTKView:(nonnull MTKView *)view</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)drawInMTKView:(nonnull MTKView *)view</div><div class="line">&#123;</div><div class="line">    id&lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer];</div><div class="line">    commandBuffer.label = @&quot;MyCommand&quot;;</div><div class="line">    MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;</div><div class="line"></div><div class="line">    if(renderPassDescriptor != nil)</div><div class="line">    &#123;</div><div class="line">        // Create a render command encoder so we can render into something</div><div class="line">        id&lt;MTLRenderCommandEncoder&gt; renderEncoder =</div><div class="line">        [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];</div><div class="line">        renderEncoder.label = @&quot;MyRenderEncoder&quot;;</div><div class="line">        // 设置显示区域</div><div class="line">        [renderEncoder setViewport:(MTLViewport)&#123;0.0, 0.0, _viewportSize.x, _viewportSize.y, -1.0, 1.0 &#125;];</div><div class="line">        // 设置渲染管道，以保证顶点和片元两个shader会被调用</div><div class="line">        [renderEncoder setRenderPipelineState:_pipelineState];</div><div class="line">        // 设置顶点缓存</div><div class="line">        [renderEncoder setVertexBuffer:_vertices</div><div class="line">                                offset:0</div><div class="line">                              atIndex:AAPLVertexInputIndexVertices];</div><div class="line">        [renderEncoder setVertexBytes:&amp;_viewportSize</div><div class="line">                               length:sizeof(_viewportSize)</div><div class="line">                              atIndex:AAPLVertexInputIndexViewportSize];</div><div class="line">        // 设置纹理</div><div class="line">        [renderEncoder setFragmentTexture:_texture</div><div class="line">                                  atIndex:AAPLTextureIndexBaseColor];</div><div class="line">        // // 绘制</div><div class="line">        [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle</div><div class="line">                          vertexStart:0</div><div class="line">                          vertexCount:_numVertices];</div><div class="line">         // 结束</div><div class="line">        [renderEncoder endEncoding];</div><div class="line">        // 显示</div><div class="line">        [commandBuffer presentDrawable:view.currentDrawable];</div><div class="line">    &#125;   </div><div class="line">    // Finalize rendering here &amp; push the command buffer to the GPU</div><div class="line">    [commandBuffer commit];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个环节中:</p>
<ul>
<li>第一步是获取command buffer(命令缓冲区)。 所有进入GPU的工作将被排入此缓冲区。 我们需要前一阶段的command queue来创建一个command buffer(命令缓冲区)。</li>
<li>第二步是设置render pass(渲染通道)。 渲染通道描述符告诉Metal渲染图像时要执行的操作。 配置它需要我们指定我们渲染的颜色纹理。</li>
<li>第三步是实际drawing(绘制)。 我们指定存储顶点的缓冲区，然后指定我们需要绘制的基元。 第四步也是最后一步是commit the command buffer(提交命令缓冲区)给GPU。 调用commit时，command buffer会被编码，发送到命令队列的末尾，并在GPU运行时执行。</li>
</ul>
<p>最后附一张非常详细的流程图：</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_xuanranguocheng.jpg" alt="xuanran"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/" itemprop="url">
                  MLeaksFinder与FBRetainCycleDetector小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-12-15T19:54:38+08:00" content="2018-12-15">
              2018-12-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/" class="leancloud_visitors" data-flag-title="MLeaksFinder与FBRetainCycleDetector小结">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MLeaksFinder"><a href="#MLeaksFinder" class="headerlink" title="MLeaksFinder"></a>MLeaksFinder</h3><p>建议先仔细阅读<a href="http://wereadteam.github.io/2016/07/20/MLeaksFinder2/" target="_blank" rel="external">官方介绍</a>，很多原理性的东西原文档讲的很清楚，这里主要以几个问题来分析一下实现过程。<br>假如给你一个原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 </div><div class="line">UIViewController，它的 view，view 的 subviews 等等是否还存在</div></pre></td></tr></table></figure>
<p>你能想到怎么用代码实现这个功能呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (BOOL)willDealloc &#123;</div><div class="line">    __weak id weakSelf = self;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        [weakSelf assertNotDealloc];</div><div class="line">    &#125;);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line">- (void)assertNotDealloc &#123;</div><div class="line">     NSAssert(NO, @“”);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如何判断一个ViewController被pop或dismiss"><a href="#如何判断一个ViewController被pop或dismiss" class="headerlink" title="如何判断一个ViewController被pop或dismiss"></a>如何判断一个ViewController被pop或dismiss</h4><p>MLeaksFinder通过Runtime hook了<code>viewDidDisappear</code> 和 <code>viewWillAppear</code>方法，但是一个界面消失时，可能是被pop或dismiss了，也有可能是push了一个新的界面，push时当前页面也会调用<code>viewDidDisappear</code>方法。我们要做的是只有被pop或dismiss时，才去监测是否内存泄漏了。MLeaksFinder做法是这样的：</p>
<p>当<code>viewWillAppear</code>被调用时，通过<code>objc_setAssociatedObject</code>方法对ViewController添加一个标记属性值，当ViewController被pop时，获得这个ViewController并改变这个属性值。然后在<code>viewDidDisappear</code>判断一下这个属性值是否被改变了，假如改变了，则是被pop或dismiss了。见代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)swizzled_viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    [self swizzled_viewDidDisappear:animated];</div><div class="line">    </div><div class="line">    BOOL value = [objc_getAssociatedObject(self, kHasBeenPoppedKey) boolValue] ;</div><div class="line">    if (value) &#123;</div><div class="line">        [self willDealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)swizzled_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self swizzled_viewWillAppear:animated];</div><div class="line">    objc_setAssociatedObject(self, kHasBeenPoppedKey, @(NO), OBJC_ASSOCIATION_RETAIN);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">UIViewController *poppedViewController = [self swizzled_popViewControllerAnimated:animated];</div><div class="line"></div><div class="line">extern const void *const kHasBeenPoppedKey;</div><div class="line">    objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(YES), OBJC_ASSOCIATION_RETAIN);</div><div class="line">    </div><div class="line">    return poppedViewController;</div></pre></td></tr></table></figure>
<h4 id="如何构建视图层级信息"><a href="#如何构建视图层级信息" class="headerlink" title="如何构建视图层级信息"></a>如何构建视图层级信息</h4><p>假如一个ViewController的一个view没有释放，找出来这个view所属的层级。</p>
<p>首先先检测ViewController，然后将ViewController的className记录下来，然后遍历ViewController.view的时候，将ViewController的className的赋值给view，以及对ViewController.view.subviews循环遍历,添加弱引用指针前时，都通过赋值传递的方法，先将视图信息记录下来，赋值给这个对象。<code>objc_setAssociatedObject</code>方法将当前遍历的类名string添加到Array里面。假如发生了内存泄漏，通过<code>objc_getAssociatedObject</code>方法获得Array，即记录的视图层级信息.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)willReleaseChildren:(NSArray *)children &#123;</div><div class="line">    </div><div class="line">    NSArray *viewStack = [self viewStack];</div><div class="line">    NSSet *parentPtrs = [self parentPtrs];</div><div class="line">    // 遍历时，添加弱引用指针前，现将之前的视图信息赋值给将要检测的对象</div><div class="line">    for (id child in children) &#123;</div><div class="line">        NSString *className = NSStringFromClass([child class]);</div><div class="line">        [child setViewStack:[viewStack arrayByAddingObject:className]];</div><div class="line">        [child setParentPtrs:[parentPtrs setByAddingObject:@((uintptr_t)child)]];</div><div class="line">        [child willDealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 赋值视图层级信息</div><div class="line">- (NSArray *)viewStack &#123;</div><div class="line">    NSArray *viewStack = objc_getAssociatedObject(self, kViewStackKey);</div><div class="line">    if (viewStack) &#123;</div><div class="line">        return viewStack;</div><div class="line">    &#125;</div><div class="line">    NSString *className = NSStringFromClass([self class]);</div><div class="line">    return @[ className ];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获得视图层级信息</div><div class="line">- (void)setViewStack:(NSArray *)viewStack &#123;</div><div class="line">    NSLog(@&quot;setViewStack -- %@&quot;,NSStringFromClass([self class]));</div><div class="line">    objc_setAssociatedObject(self, kViewStackKey, viewStack, OBJC_ASSOCIATION_RETAIN);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如何判断属于释放不及时的情况"><a href="#如何判断属于释放不及时的情况" class="headerlink" title="如何判断属于释放不及时的情况"></a>如何判断属于释放不及时的情况</h4><p>原文中是这么描述的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，</div><div class="line">对于同一个类不断地报 Object Deallocated 和 Memory Leak。这种情况属于释放不及时的情况。</div></pre></td></tr></table></figure>
<p>意思就是该释放的时候没释放，但是过了一段时间，或触发了某个场景又释放了，这不算严格上的内存泄漏，属于释放不及时的情况，比如这种场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)push &#123;</div><div class="line">    SecViewController *controller = [[SecViewController alloc] init];</div><div class="line">    self.secController = controller;</div><div class="line">    [self.navigationController pushViewController: controller animated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从当前界面push到SecViewController界面，但是当前界面持有SecViewController对象的强引用，所以SecViewController pop时，SecViewController对象时不会释放的，只有当前界面释放了，SecViewController对象才释放。</p>
<p>检测这种情况的方法，也是使用了<code>objc_setAssociatedObject</code>方法。当一个对象发生内存泄漏时，使用<code>objc_setAssociatedObject</code>为该对象添加一个标记对象MLeakedObjectProxy，MLeakedObjectProxy持有这个泄漏对象的弱引用，这样当泄漏的对象释放时，会清除自身关联的AssociatedObject，关联对象MLeakedObjectProxy此时释放，所以关联对象释放的时机即是内存泄漏对象delloc的时机，这个时候会弹一个Object Deallocated的alertView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+ (void)addLeakedObject:(id)object &#123;</div><div class="line">    NSAssert([NSThread isMainThread], @&quot;Must be in main thread.&quot;);</div><div class="line">    </div><div class="line">    MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] init];</div><div class="line">    proxy.object = object;</div><div class="line">    proxy.objectPtr = @((uintptr_t)object);</div><div class="line">    proxy.viewStack = [object viewStack];</div><div class="line">    static const void *const kLeakedObjectProxyKey = &amp;kLeakedObjectProxyKey;</div><div class="line">    objc_setAssociatedObject(object, kLeakedObjectProxyKey, proxy, OBJC_ASSOCIATION_RETAIN);</div><div class="line">    </div><div class="line">    [leakedObjectPtrs addObject:proxy.objectPtr];</div><div class="line">    </div><div class="line">    [MLeaksMessenger alertWithTitle:@&quot;Memory Leak&quot;</div><div class="line">                            message:[NSString stringWithFormat:@&quot;%@&quot;, proxy.viewStack]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSNumber *objectPtr = _objectPtr;</div><div class="line">    NSArray *viewStack = _viewStack;</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [leakedObjectPtrs removeObject:objectPtr];</div><div class="line">        [MLeaksMessenger alertWithTitle:@&quot;Object Deallocated&quot;</div><div class="line">                                message:[NSString stringWithFormat:@&quot;%@&quot;, viewStack]];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="FBRetainCycleDetector"><a href="#FBRetainCycleDetector" class="headerlink" title="FBRetainCycleDetector"></a>FBRetainCycleDetector</h3><p>MLeaksFinder的作用是找出来没有释放的对象，但是要找出哪个对象强引用着这个未释放的对象、哪几个对象造成了循环引用，还要靠<a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="external">FBRetainCycleDetector</a>。它的原理是获得要检查对象的所有强引用对象，按照深入优先搜索的方法遍历所有强引用对象，假如在遍历的过程中又遍历到了自己，表明发生了循环引用，然后输出日志。</p>
<p><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/MLeaksFinder_Cycle.jpg" alt="循环引用"></p>
<p>如上图，搜索过程中 object1 -&gt; object4 -&gt; object6 -&gt; object1 ，造成了循环引用，控制台会输出这些信息。</p>
<p>FB中关于寻找一个对象的所有强引用属性，比如上图中的object1,找出它的所有strong类型的属性：object2,object3,object4以及关联对象，这个过程值得我们去深究，复习下Runtime及Block底层知识。</p>
<p>FBRetainCycleDetector中将需要检查的类型分成了三类，分别是NSObject类型，NSTimer类型，Block类型，对每种类型分别包装成了FBObjectiveCObject，FBObjectiveCNSCFTimer，FBObjectiveCBlock。<br>判断一个对象是否是NSTimer类型非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object_getClass(object) isSubclassOfClass:[NSTimer class]]</div></pre></td></tr></table></figure>
<p>判断一个对象是否是Block的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static Class _BlockClass() &#123;</div><div class="line">  static dispatch_once_t onceToken;</div><div class="line">  static Class blockClass;</div><div class="line">  dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">      void (^testBlock)(void) = [^&#123;&#125; copy];</div><div class="line">    blockClass = [testBlock class];</div><div class="line">    while(class_getSuperclass(blockClass) &amp;&amp; class_getSuperclass(blockClass) != [NSObject class]) &#123;</div><div class="line">      blockClass = class_getSuperclass(blockClass);</div><div class="line">    &#125;</div><div class="line">    [testBlock release];</div><div class="line">  &#125;);</div><div class="line">  return blockClass;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL FBObjectIsBlock(void *object) &#123;</div><div class="line">  Class blockClass = _BlockClass();</div><div class="line">  Class candidate = object_getClass((__bridge id)object);</div><div class="line">  return [candidate isSubclassOfClass:blockClass];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取通过关联对象方式添加的属性"><a href="#获取通过关联对象方式添加的属性" class="headerlink" title="获取通过关联对象方式添加的属性"></a>获取通过关联对象方式添加的属性</h4><p>FBObjectiveCObject，FBObjectiveCNSCFTimer，FBObjectiveCBlock这三个类有一个共同父类FBObjectiveCGraphElement，共用父类的方法<code>- (NSSet *)allRetainedObjects</code>，这个方法用来获得通过<code>objc_setAssociatedObject</code>方法添加的属性。</p>
<p>FBRetainCycleDetector 使用了 <a href="https://github.com/facebook/fishhook" target="_blank" rel="external">fishhook</a> hook了 <code>objc_setAssociatedObject</code> 和 <code>objc_removeAssociatedObjects</code> 方法，在FBAssociationManager类里维护了一个存储关联对象信息的Map, 这样的话通过关联对象的方式添加属性，就能被捕捉到，然后操作维护的Map。这样就能获得一个对象，通过关联对象方式添加强引用属性的所有信息了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface FBAssociationManager : NSObject</div><div class="line"></div><div class="line">+ (void)hook;</div><div class="line"></div><div class="line">+ (void)unhook;</div><div class="line"></div><div class="line">+ (nullable NSArray *)associationsForObject:(nullable id)object;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="对于NSObject类型"><a href="#对于NSObject类型" class="headerlink" title="对于NSObject类型"></a>对于NSObject类型</h4><p>对于通过@property方式添加的属性，在Runtime层面来说，内部都会有一个IvarList存放着实例变量列表。有的人可能会想，不是有api：<code>class_getIvarLayout</code>、<code>class_getWeakIvarLayout</code>可以直接获得strong类型的实例变量和weak类型的实例变量吗？其实不然，ivarLayout和weakIvarLayout存放的只是强ivar和弱ivar的存储规则，并不是真正的实例变量，具体可以看<a href="https://www.jianshu.com/p/6b218d12caae" target="_blank" rel="external">这篇文章</a>。</p>
<p>但是我们可以根据ivarLayout这个存储规则找出强ivar的所在的index,再通过<code>class_copyIvarList</code>获取所有的ivar, 这样就找出了这个对象的强ivar。有了这个强ivar后再通过<code>object_getIvar</code>获得ivar对应的值，从而达成了目的。核心代码主要在FBClassStrongLayout类里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">static NSArray&lt;id&lt;FBObjectReference&gt;&gt; *FBGetStrongReferencesForClass(Class aCls) &#123;</div><div class="line">//    class的引用所有的引用(iVarList)，包括强引用和弱引用</div><div class="line">  NSArray&lt;id&lt;FBObjectReference&gt;&gt; *ivars = [FBGetClassReferences(aCls) filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) &#123;</div><div class="line">    if ([evaluatedObject isKindOfClass:[FBIvarReference class]]) &#123;</div><div class="line">      FBIvarReference *wrapper = evaluatedObject;</div><div class="line">      return wrapper.type != FBUnknownType;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">  &#125;]];</div><div class="line"></div><div class="line">    // 获取属性为strong或copy在内存中的存储规则，结果可能为nil</div><div class="line">  const uint8_t *fullLayout = class_getIvarLayout(aCls);</div><div class="line">  if (!fullLayout) &#123;</div><div class="line">    return nil;</div><div class="line">  &#125;</div><div class="line">    NSLog(@&quot;%@ fullLayout:\n%s&quot;,NSStringFromClass(aCls),fullLayout);</div><div class="line">//获取ivar的最小index</div><div class="line">  NSUInteger minimumIndex = FBGetMinimumIvarIndex(aCls);</div><div class="line">//获取强引用的index区间。 https://www.jianshu.com/p/89ac27684693</div><div class="line">  NSIndexSet *parsedLayout = FBGetLayoutAsIndexesForDescription(minimumIndex, fullLayout);</div><div class="line"></div><div class="line">  NSArray&lt;id&lt;FBObjectReference&gt;&gt; *filteredIvars =</div><div class="line">  [ivars filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id&lt;FBObjectReference&gt; evaluatedObject,</div><div class="line">                                                                           NSDictionary *bindings) &#123;</div><div class="line">    return [parsedLayout containsIndex:[evaluatedObject indexInIvarLayout]];</div><div class="line">  &#125;]];</div><div class="line"></div><div class="line">  return filteredIvars;</div><div class="line">&#125;</div><div class="line">NSArray&lt;id&lt;FBObjectReference&gt;&gt; *FBGetObjectStrongReferences(id obj,</div><div class="line">                                                            NSMutableDictionary&lt;Class, NSArray&lt;id&lt;FBObjectReference&gt;&gt; *&gt; *layoutCache) &#123;</div><div class="line">  NSMutableArray&lt;id&lt;FBObjectReference&gt;&gt; *array = [NSMutableArray new];</div><div class="line"></div><div class="line">  __unsafe_unretained Class previousClass = nil;</div><div class="line">  __unsafe_unretained Class currentClass = object_getClass(obj);</div><div class="line"></div><div class="line">  while (previousClass != currentClass) &#123;</div><div class="line">    NSArray&lt;id&lt;FBObjectReference&gt;&gt; *ivars;</div><div class="line">    </div><div class="line">    if (layoutCache &amp;&amp; currentClass) &#123;</div><div class="line">      ivars = layoutCache[currentClass];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!ivars) &#123;</div><div class="line">      ivars = FBGetStrongReferencesForClass(currentClass);</div><div class="line">      if (layoutCache &amp;&amp; currentClass) &#123;</div><div class="line">        layoutCache[currentClass] = ivars;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    [array addObjectsFromArray:ivars];</div><div class="line"></div><div class="line">    previousClass = currentClass;</div><div class="line">    currentClass = class_getSuperclass(currentClass);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return [array copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 简略流程图为：</p>
<p><img src="http://ww1.sinaimg.cn/mw690/006OKvcNly1fy5f0i5pfzj30q80j0dgu.jpg" alt="循环引用"></p>
<h4 id="对于Block类型"><a href="#对于Block类型" class="headerlink" title="对于Block类型"></a>对于Block类型</h4><p>首先要了解Block的结构是什么，假如引用了对象，这部分的对象存在哪里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct BlockDescriptor &#123;</div><div class="line">  unsigned long int reserved;                // NULL</div><div class="line">  unsigned long int size;</div><div class="line">  // optional helper functions</div><div class="line">  void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25)</div><div class="line">  void (*dispose_helper)(void *src);         // IFF (1&lt;&lt;25)</div><div class="line">  const char *signature;                     // IFF (1&lt;&lt;30)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct BlockLiteral &#123;</div><div class="line">  void *isa;  // initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</div><div class="line">  int flags;</div><div class="line">  int reserved;</div><div class="line">  void (*invoke)(void *, ...);</div><div class="line">  struct BlockDescriptor *descriptor;</div><div class="line">  // imported variables</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>FB中将传入的Blok强转成了BlockLiteral类型的结构体，对于BlockLiteral这个结构体进行操作。</p>
<p>其实最重要的理解dispose_helper这个函数的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispose_helper 向所有捕获的变量发送release消息，对弱引用不会做任何的处理</div></pre></td></tr></table></figure>
<p>我们可以先存一份<code>dispose_helper</code>调用之前的数据，然后调用<code>dispose_helper</code>函数，对比调用后的数据，就能得出所强引用的函数。<br>FBBlockStrongRelationDetector 为<code>dispose_helper</code>的消息接收类，复写了release函数。它的实例在接受release消息时，并不会真正的释放，只会将标记_strong 为YES，<br>只有真正执行<code>trueRelease</code> 的时候才会向对象发送 release 消息。更多详细的信息见<a href="https://github.com/draveness/analyze/blob/master/contents/FBRetainCycleDetector/iOS%20中的%20block%20是如何持有对象的.md" target="_blank" rel="external">这篇文章</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (oneway void)release</div><div class="line">&#123;</div><div class="line">  _strong = YES;</div><div class="line">&#125;</div><div class="line">- (oneway void)trueRelease</div><div class="line">&#123;</div><div class="line">  [super release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_GetBlockStrongLayout</code>核心代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//    获得dispose_helper函数</div><div class="line">  void (*dispose_helper)(void *src) = blockLiteral-&gt;descriptor-&gt;dispose_helper;</div><div class="line">  const size_t ptrSize = sizeof(void *);</div><div class="line"></div><div class="line">  // Figure out the number of pointers it takes to fill out the object, rounding up.</div><div class="line">//    获取 block 持有的指针的数量</div><div class="line">  const size_t elements = (blockLiteral-&gt;descriptor-&gt;size + ptrSize - 1) / ptrSize;</div><div class="line"></div><div class="line">  // Create a fake object of the appropriate length.</div><div class="line">  void *obj[elements];</div><div class="line">  void *detectors[elements];</div><div class="line"></div><div class="line">  for (size_t i = 0; i &lt; elements; ++i) &#123;</div><div class="line">    FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector new];</div><div class="line">    obj[i] = detectors[i] = detector;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @autoreleasepool &#123;</div><div class="line">    dispose_helper(obj);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Run through the release detectors and add each one that got released to the object&apos;s</div><div class="line">  // strong ivar layout.</div><div class="line">  NSMutableIndexSet *layout = [NSMutableIndexSet indexSet];</div><div class="line"></div><div class="line">  for (size_t i = 0; i &lt; elements; ++i) &#123;</div><div class="line">    FBBlockStrongRelationDetector *detector = (FBBlockStrongRelationDetector *)(detectors[i]);</div><div class="line">    if (detector.isStrong) &#123;</div><div class="line">      [layout addIndex:i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Destroy detectors</div><div class="line">    [detector trueRelease];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return layout;</div></pre></td></tr></table></figure>
<h4 id="对于NSTimer类型"><a href="#对于NSTimer类型" class="headerlink" title="对于NSTimer类型"></a>对于NSTimer类型</h4><p>通过<code>CFRunLoopTimerGetContext</code>获得timer的详细信息，包括target</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_FBNSCFTimerInfoStruct infoStruct = *(_FBNSCFTimerInfoStruct *)(context.info);</div><div class="line"></div><div class="line">typedef struct &#123;</div><div class="line">  long _unknown; // This is always 1</div><div class="line">  id target;</div><div class="line">  SEL selector;</div><div class="line">  NSDictionary *userInfo;</div><div class="line">&#125; _FBNSCFTimerInfoStruct;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>阅读优秀的开源框架能够学习很深层次的知识点，以及如何正确使用这些知识。比如MLeaksFinder中大量使用了<code>objc_setAssociatedObject</code>来实现想要的功能。再比如即使我们知道了Block的数据结构，那么能用这些知识来实现什么功能呢，FBRetainCycleDetector中使用了Block中的<code>dispose_helper</code>函数来筛选引用到的对象，使用了fishhook来hook Runtime层面的api。你知道了消息转发的过程和原理，假如你去阅读<a href="https://github.com/steipete/Aspects" target="_blank" rel="external">Aspects</a>源码的话，就会更加了解如何去用正确使用消息转发，并且惊叹消息转发用处原来这么强大。优秀的人无处不在，所以不仅仅是自己研究，也要多汲取别人的思路想法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/02/平凡的世界/" itemprop="url">
                  《平凡的世界》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-10-02T09:54:10+08:00" content="2018-10-02">
              2018-10-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/读书与感悟/" itemprop="url" rel="index">
                    <span itemprop="name">读书与感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/02/平凡的世界/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/02/平凡的世界/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/10/02/平凡的世界/" class="leancloud_visitors" data-flag-title="《平凡的世界》">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>《平凡的世界》记录的是一九七四年至一九八四年，十年间以乡下的一个小村庄双水村的变化，反映了中国快速发展的面貌。我大部分都是在晚上读这本小说，花了三个多月的时间读完了这本书，共三部。书中一些情节，人物的刻画，故事的发展，以及作者对人生的思考，都给了我很大的帮助，以至于现在有一种想读第二遍的冲动。所以，我觉得我有必要写一些东西记录下我读后的感悟。</p>
<h3 id="关于爱情与婚姻"><a href="#关于爱情与婚姻" class="headerlink" title="关于爱情与婚姻"></a>关于爱情与婚姻</h3><p>书中关于爱情的情节，有两条线，一条是孙少安与田润叶，一条是孙少平与田晓霞。他们双方都深爱着对方，但最后都没能走到一起。前者是因为孙少安是社会最底层的农民，觉得自己配不上干部家庭及文化高的田润叶，后者是因为田晓霞因为在洪水中救人而牺牲了。哎，很可惜，特别是孙少平与田晓霞，它们俩一开始就互相帮助对方，本以为它们会走到最后，没想到…</p>
<p>《阿甘正传》里有一句台词：人生就像一盒巧克力，你永远无法知道下一颗是什么滋味。在青涩的年纪，就像爱情一样，你也无法知道最后陪伴你一生的那个人是谁，人生总是充满了插曲。两个人在一起爱情和婚姻是不同的，爱情的可以轰轰烈烈，但婚姻平平淡淡最好。每个人都会有青涩的初恋，刻骨的爱情，但爱情的尽头呢？会是婚姻吗？在过程中会有各种阻隔让你们分开，你们或许让对方尝到了爱情的滋味，但未必给的了婚姻的幸福，一生的呵护。</p>
<h3 id="对于苦难"><a href="#对于苦难" class="headerlink" title="对于苦难"></a>对于苦难</h3><p>记忆最深刻的就是孙少平不想永远呆在小山村，想出去闯荡，于是一个人去煤矿打工，受了很多苦。书中是这样描述这一经历的，原文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">有文化，但是没有幸运的进入大学或参加工作，因此似乎没有充分的条件直接参与到目前社会发展的主潮之</div><div class="line">中，而另一方面，他们往往又不甘心，把自己局限在狭小生活的天地里。因此，他们带着一种悲壮的激情，在</div><div class="line">一条最为艰难的道路上进行人生的搏斗。他们顾不得高谈论阔，或愤世嫉俗的忧患人类的命运。他们首先得改</div><div class="line">变自己的生存条件，同时也不放弃最主要的精神追求。他们既不鄙视普通人的世俗生活，但又竭力使自己对生</div><div class="line">活的认识达到更深的层次。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">是的，他是在社会最底层挣扎，为了几个钱而受尽折磨，但他已不仅仅将此看做是谋生活命——职业的高低贵</div><div class="line">贱，不能说明一个人的价值。恰恰相反，他现在倒很“热爱”自己的苦难。通过这一段血火般的洗礼，他相信，</div><div class="line">自己历经千辛万苦而酿造出的生活之蜜，肯定比轻而易举拿来的更有滋味。</div></pre></td></tr></table></figure>
<p>苦难是对自己的磨难，在磨难中，在压力中你才能更加快速的成长。苦难过后，你再看看自己曾经走过的路，你会感谢他们，正是因为他们，你才有了许多人生的感悟，人生的道理，而这些是别人不能给你的，只能自己去经历，自己去体会。</p>
<p>很遗憾，直到书的结尾，孙少平还在经历苦难的磨炼。但我相信，他会创出自己的天地，走向更广阔的天空。</p>
<h3 id="要有一颗不屈于现状的心"><a href="#要有一颗不屈于现状的心" class="headerlink" title="要有一颗不屈于现状的心"></a>要有一颗不屈于现状的心</h3><p>孙少安虽然在农村老家勤恳务农，但他却觉得一直这样的话，无疑是在走父辈的老路。所以就有了开砖厂的想法，第一次由于经营不善，用人不善倒闭了。过了一年，重整旗鼓，吸取教训，最后终于办的有模有样，成了家乡的富翁。</p>
<p>孙少平从上高中开始就有读书的习惯，通过阅报一直在关注世界各地的发展形势，所以就有了一个不安分的心，想要到外面闯荡。所以后来独自一人去了煤矿，得到了一份令人羡慕不已的工作。</p>
<p>书中也反映了现实中的道理，有一句话，“比你优秀的人比你更努力”，假如觉得现在的生活可以了，不想再奋斗了，但是别人都在朝着自己的目标努力，若干时间后，你还会这样想吗？</p>
<h3 id="风雨过后就是彩虹"><a href="#风雨过后就是彩虹" class="headerlink" title="风雨过后就是彩虹"></a>风雨过后就是彩虹</h3><p>社会总是在不断发展的，美好的事物总会来临，就像中国这几十年来的发展一样，一天比一天好。不管怎样，属于你的终究是属于你的。不要抱有太多的悲观情绪，可以对比下自己，把现在的自己和一年前的自己，五年前的自己比比，是不是成长了许多。所以，奋斗吧骚年，风雨过后就是彩虹！！！</p>
<p>(软文一篇 😝)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/30/NSNotificationCenter防Crash守护/" itemprop="url">
                  NSNotificationCenter防Crash守护
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-30T15:08:47+08:00" content="2018-08-30">
              2018-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/30/NSNotificationCenter防Crash守护/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/30/NSNotificationCenter防Crash守护/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/08/30/NSNotificationCenter防Crash守护/" class="leancloud_visitors" data-flag-title="NSNotificationCenter防Crash守护">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于NSNotificationCenter，使用不当会造成Crash错误，比如没有在dealloc中removeObserver，或者在分线程中进行接收、发送通知等等。</p>
<ul>
<li>注：在iOS 9.0 或 macOS 10.11 以后，不需要在dealloc中调用removeObserver方法了,见<a href="https://developer.apple.com/documentation/foundation/nsnotificationcenter/1413994-removeobserver?language=objc" target="_blank" rel="external">官方文档</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">If your app targets iOS 9.0 and later or macOS 10.11 and later, you don&apos;t need to unregister an observer</div><div class="line"> in its dealloc method. Otherwise, you should call this method or removeObserver:name:object: before </div><div class="line"> observer or any object specified in addObserverForName:object:queue:usingBlock: or </div><div class="line"> addObserver:selector:name:object: is deallocated.</div></pre></td></tr></table></figure>
<p>当向通知中心注册的时候，NSNotificationCenter不会对observer强引用，在iOS 9.0以前，会持有一个<code>__unsafe_unretained</code>的指针，假如observer释放了，指针不会置为nil，变成不安全的指针。而在iOS 9.0及以后，使用<code>weak</code>修饰指针，解决了这个问题。详细见<a href="https://developer.apple.com/library/archive/releasenotes/Foundation/RN-FoundationOlderNotes/index.html#X10_11Notes" target="_blank" rel="external">官方更新说明</a>中关于NSNotificationCenter部分。</p>
<p>虽然不用移除了。但是探讨如何在dealloc方法中实现自动removeObserver还是有好处的。</p>
<h3 id="Swillze-dealloc-方法"><a href="#Swillze-dealloc-方法" class="headerlink" title="Swillze dealloc 方法"></a>Swillze dealloc 方法</h3><p>既然需要在dealloc方法中调用removeObserver方法，那么我们Swillze dealloc不就好了吗，在交换的dealloc方法里调用removeObserver。那么又有了一个问题，我们hook的dealloc方法是所有对象的dealloc，即所有对象的dealloc方法都会走我们自己的交换方法，怎么判定这个对象被注册到通知中心了呢？</p>
<p>所以，也需要hook <code>- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject</code> 这个方法，在hook方法里使用Rumtime AssociatedObject为observer添加一个标记。然后在自己的dealloc方法里通过判断是否有标记，来移除observer。</p>
<p>分析：<br>dealloc方法算是在整个项目里调用最频繁的方法之一了，hook dealloc方法感觉有点得不偿失，对性能有点影响。所以，我对这个 Swillze dealloc方法没有具体写代码去实现。</p>
<h3 id="AssociatedObject-Weak"><a href="#AssociatedObject-Weak" class="headerlink" title="AssociatedObject + Weak"></a>AssociatedObject + Weak</h3><p>我们先来看看dealloc底层都实现了什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void *objc_destructInstance(id obj) </div><div class="line">&#123;</div><div class="line">    if (obj) &#123;</div><div class="line">        // Read all of the flags at once for performance.</div><div class="line">        bool cxx = obj-&gt;hasCxxDtor();</div><div class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</div><div class="line"></div><div class="line">        // This order is important.</div><div class="line">        if (cxx) object_cxxDestruct(obj);</div><div class="line">        if (assoc) _object_remove_assocations(obj);</div><div class="line">        obj-&gt;clearDeallocating();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中有重要的两步，就是释放关联对象及弱引用，这个自动removeObserver就是用这两个知识点实现的。</p>
<p>当向通知中心注册的时候，用AssociatedObject为observer添加一个属性标记，这里使用的是分类的方式添加的，对NSObject添加一个分类，在分类里添加一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface NSObject (Tag)</div><div class="line">@property (nonatomic, strong) ZJNotificationTag *tag;</div><div class="line">@end</div><div class="line"></div><div class="line">static void *NSObject_ZJTag_Key = &amp;NSObject_ZJTag_Key;</div><div class="line"></div><div class="line">@implementation NSObject (ZJTag)</div><div class="line"></div><div class="line">- (void)setTag:(ZJNotificationTag *)tag &#123;</div><div class="line">    objc_setAssociatedObject(self, NSObject_ZJTag_Key, tag, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(ZJNotificationTag *)tag &#123;</div><div class="line">    return (ZJNotificationTag *)objc_getAssociatedObject(self, NSObject_ZJTag_Key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>ZJNotificationTag是自定义的，继承自NSObject的子类，持有observer的弱引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@interface ZJNotificationTag: NSObject</div><div class="line">@property (nonatomic, weak) id observer;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZJNotificationTag</div><div class="line"></div><div class="line">- (void)setObserver:(id)observer &#123;</div><div class="line">    _observer = observer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self.observer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>思路就是当observer释放，即dealloc的时候，dealloc内部会清除与之相关联的对象，即上述代码中的<code>tag</code>对象，而tag对象弱引用observer，所以不会产生循环引用，所以在tag对象的dealloc方法里，通过<code>tag.observer</code>得到了observer对象，从而将observer对象从通知中心移除。</p>
<p>下面简述一下实现过程中遇到的问题：</p>
<h4 id="保证observer对象只调用一次remove方法"><a href="#保证observer对象只调用一次remove方法" class="headerlink" title="保证observer对象只调用一次remove方法"></a>保证observer对象只调用一次remove方法</h4><p>假如在ViewController里同时注册多个不同通知，那么在dealloc里也只需移除一次。所以在添加标记时，先判断一下是否已经添加了标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSObject *_observer = (NSObject *)observer;</div><div class="line">if(!_observer.tag)&#123;</div><div class="line">    ZJNotificationTag *tag = [[ZJNotificationTag alloc] init];</div><div class="line">    _observer.tag = tag;</div><div class="line">    tag.observer = _observer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="保证不会重复注册observer"><a href="#保证不会重复注册observer" class="headerlink" title="保证不会重复注册observer"></a>保证不会重复注册observer</h4><p>对于同一个通知，即<code>NSNotificationName</code>相同的通知，如果重复注册，就会重复收到回调方法，在这里我维护了一个NSMutableDictionary，来处理这种由于不小心可能造成的bug：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary &lt;NSString*, NSHashTable*&gt;*_dic;</div></pre></td></tr></table></figure>
<p>key为<code>NSNotificationName</code>，value为<code>NSHashTable</code>，即能实现对内部对象弱引用的Set，当addObserver时先判断是否已经存在了，如果存在，即证明已经注册过了，直接返回，不再调用addObserver方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSHashTable *hashTable = [_dic objectForKey:name];</div><div class="line">if(!hashTable) &#123;</div><div class="line">    hashTable = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];</div><div class="line">    [self _addObserver:observer selector:selector name:name object:object hashTable:hashTable];</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">    if(![hashTable containsObject:observer]) &#123;</div><div class="line">        [self _addObserver:observer selector:selector name:name object:object hashTable:hashTable];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">[_dic setObject:hashTable forKey:name];</div></pre></td></tr></table></figure>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>注册observer、添加标记、添加对象到hashTable等操作方法都加了锁，保证线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_init(&amp;_lock, NULL);</div><div class="line"></div><div class="line">pthread_mutex_lock(&amp;_lock);</div><div class="line"></div><div class="line">pthread_mutex_unlock(&amp;_lock);</div></pre></td></tr></table></figure>
<p>在发送通知时，为了防止多线程可能引起的问题，在这里统一在主线程发出通知，这样的话，就保证了接收通知时一定在主线程，见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/NotificationCenters.html#//apple_ref/doc/uid/20000216-111349" target="_blank" rel="external">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In a multithreaded application, notifications are always delivered in the thread in which the </div><div class="line">notification was posted, which may not be the same thread in which an observer registered itself.</div></pre></td></tr></table></figure>
<p>借鉴了SDWebImage的做法(站在巨人的肩膀上😝)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)postNotificationName:(NSString *)name object:(id)object &#123;</div><div class="line">    </div><div class="line">    dispatch_main_async_safe(^&#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:name object:object];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在ViewController中添加监听的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[ZJNotificationCenter defaultCenter] addObserver:self selector:@selector(didReceiveNotification) name:@&quot;TestNotificationName&quot; object:nil];</div></pre></td></tr></table></figure>
<p>发送通知的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[ZJNotificationCenter defaultCenter] postNotificationName:@&quot;TestNotificationName&quot; object:nil];</div></pre></td></tr></table></figure>
<p>本文研究如何实现自动removeObserver，只是想到了这一个思路，文中的代码并未在正式环境中使用，如果错误，请指正。</p>
<p>代码已传至<a href="https://github.com/coderZhou10496/NotificationDemo" target="_blank" rel="external">Github</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/02/YYCache中的细节/" itemprop="url">
                  YYCache中的细节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-02T22:36:33+08:00" content="2018-08-02">
              2018-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/02/YYCache中的细节/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/02/YYCache中的细节/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/08/02/YYCache中的细节/" class="leancloud_visitors" data-flag-title="YYCache中的细节">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近花了点时间看了下<a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>的源码，觉得其中的一些代码细节非常好，遂记录之，虽然这些知识可能被别人写烂了，但自己总结下总归是好的。</p>
<h3 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h3><p>作者在YYMemoryCache中使用了C语言中的<code>pthread_mutex_t</code>来加锁解锁保证线程安全，而在YYDiskCache中使用<code>dispatch_semaphore信号量</code>，<code>dispatch_semaphore</code>不算锁，但可以实现锁的功能。</p>
<p>YYMemoryCache中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (id)objectForKey:(id)key &#123;</div><div class="line">    if (!key) return nil;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key));</div><div class="line">    if (node) &#123;</div><div class="line">        node-&gt;_time = CACurrentMediaTime();</div><div class="line">        [_lru bringNodeToHead:node];</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    return node ? node-&gt;_value : nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>YYDiskCache中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123;</div><div class="line">    if (!key) return nil;</div><div class="line">    dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER);</div><div class="line">    YYKVStorageItem *item = [_kv getItemForKey:key];</div><div class="line">    dispatch_semaphore_signal(self-&gt;_lock);</div><div class="line">    if (!item.value) return nil;</div><div class="line">    </div><div class="line">    id object = nil;</div><div class="line">    if (_customUnarchiveBlock) &#123;</div><div class="line">        object = _customUnarchiveBlock(item.value);</div><div class="line">    &#125; else &#123;</div><div class="line">        @try &#123;</div><div class="line">            object = [NSKeyedUnarchiver unarchiveObjectWithData:item.value];</div><div class="line">        &#125;</div><div class="line">        @catch (NSException *exception) &#123;</div><div class="line">            // nothing to do...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (object &amp;&amp; item.extendedData) &#123;</div><div class="line">        [YYDiskCache setExtendedData:item.extendedData toObject:object];</div><div class="line">    &#125;</div><div class="line">    return object;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在YYMemoryCache中，作者原先是使用自旋锁OSSpinLock来实现线程安全的，原理就是do while 忙等，缺点是等待时间会消耗大量 CPU 资源，所以它不适用于较长时间的任务，固在YYDiskCache中用<code>dispatch_semaphore</code>，<code>dispatch_semaphore</code>优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>
<p>但是由于OSSpinLock有安全问题，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。具体见<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">不再安全的 OSSpinLock</a>。所以就换成了<code>pthread_mutex_lock</code>互斥锁。</p>
<h3 id="GCD中使用-weak"><a href="#GCD中使用-weak" class="headerlink" title="GCD中使用__weak"></a>GCD中使用__weak</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)_trimRecursively &#123;</div><div class="line">    __weak typeof(self) _self = self;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</div><div class="line">        __strong typeof(_self) self = _self;</div><div class="line">        if (!self) return;</div><div class="line">        [self _trimInBackground];</div><div class="line">        [self _trimRecursively];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是YYDiskCache中的一段代码，目的是循环调用<code>_trimInBackground</code>方法来检查磁盘中的存储是否大于限制，大于限制的话就删除数据直到符合限制。这里作者使用了<code>__weak</code>来防止Block持有self。刚开始看到这句代码，我也不理解为什么要使用<code>__weak</code>，按理来说GCD中Block执行完后会释放self，不会存在内存泄露，在<a href="https://github.com/ibireme/YYKit/issues/41" target="_blank" rel="external">issues</a>也有关于这个问题的讨论。看了issues中的讨论，后来想了想，因为这是个递归调用，自己调用自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (!self) return;</div></pre></td></tr></table></figure>
<p>假如block中的self一直有值，那么这个循环会一直调用下去。那什么情况下block中self为nil呢。请看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">YYCache *cache = [[YYCache alloc] initWithPath:path];</div><div class="line">[cache setObject:@&quot;ZhangSan&quot; forKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>假如我们在ViewController中使用YYCache进行存储数据，但ViewController并没有持有YYCache实例，那么这两行代码执行完，cache这个对象就释放了，这是完美的结果。</p>
<p>但是假如在上述的源码里，没有使用<code>__weak</code>，而是直接使用了self，即使ViewController没有持有YYCache实例，cache这个对象也不会释放，YYDiskCache中的dealloc方法一直不会调用。因为Block一直在持有cache对象，并且这个方法是递归方法，所以就发生了“假的内存泄露”。</p>
<p>既然我们在ViewController中没有强引用cache，就希望使用它后自己释放掉，所以使用了<code>__weak</code>。假如在ViewController中强引用cache对象，那么使不使用<code>__weak</code>都是无关紧要的了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) YYCache *cache;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>另外提一点，因为YYCache中可以自己控制内存占用大小，磁盘占用大小，即超过限制自动删除尾部数据。假如我们不需要这个功能的时候，即对缓存大小无限制，可以注释掉相关检查操作的代码，因为它每隔一段时间(YYDiskCache默认为60s，YYMemoryCache默认为5s)会调用方法自动检查并操作数据，算是一个小优化吧。</p>
<h3 id="UIAppliaction对象"><a href="#UIAppliaction对象" class="headerlink" title="UIAppliaction对象"></a>UIAppliaction对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static UIApplication *_YYSharedApplication() &#123;</div><div class="line">    static BOOL isAppExtension = NO;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class cls = NSClassFromString(@&quot;UIApplication&quot;);</div><div class="line">        if(!cls || ![cls respondsToSelector:@selector(sharedApplication)]) isAppExtension = YES;</div><div class="line">        if ([[[NSBundle mainBundle] bundlePath] hasSuffix:@&quot;.appex&quot;]) isAppExtension = YES;</div><div class="line">    &#125;);</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</div><div class="line">    return isAppExtension ? nil : [UIApplication performSelector:@selector(sharedApplication)];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码是获得当前UIAppliaction对象，里面判断了当在App Extension里返回nil。假如是我们自己设计一个SDK给别人使用，会不会注意到这些细节呢？</p>
<h3 id="指定queue中子线程中释放对象"><a href="#指定queue中子线程中释放对象" class="headerlink" title="指定queue中子线程中释放对象"></a>指定queue中子线程中释放对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *holder = [NSMutableArray new];</div><div class="line">while (!finish) &#123;</div><div class="line">    if (pthread_mutex_trylock(&amp;_lock) == 0) &#123;</div><div class="line">        if (_lru-&gt;_tail &amp;&amp; (now - _lru-&gt;_tail-&gt;_time) &gt; ageLimit) &#123;</div><div class="line">            _YYLinkedMapNode *node = [_lru removeTailNode];</div><div class="line">            if (node) [holder addObject:node];</div><div class="line">        &#125; else &#123;</div><div class="line">            finish = YES;</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_unlock(&amp;_lock);</div><div class="line">    &#125; else &#123;</div><div class="line">        usleep(10 * 1000); //10 ms</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">if (holder.count) &#123;</div><div class="line">    dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        [holder count]; // release in queue</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在当前线程中创建一个NSMutableArray，然后将要删除释放的对象添加到数组中，再在子线程中调用count方法，这样就达到了在子线程中释放对象的目的了。</p>
<p>原因：当把将要删除的对象添加到array中，此时array不会释放，array中的对象也不会释放，因为在另外的线程中又调用了count方法，持有了array。当block执行完，就会释放持有的array，也达到了释放删除对象的目的，即在指定的queue中子线程释放对象。(说实话，看源码之前从来没有想到过这个需求，在指定的queue中释放对象，汗颜!)</p>
<h3 id="双向链表的选择"><a href="#双向链表的选择" class="headerlink" title="双向链表的选择"></a>双向链表的选择</h3><p>在YYMemoryCache中使用了双向链表来实现LRU的策略缓存，不止iOS平台，在其他平台，安卓，Linux等实现LRU算法都是使用双向链表+Map的方法。使用Map是为了更快找到要删除或移动的节点，链表是将经常使用的数据放到头部节点，删除的时候删除尾部节点的数据。一开始我想，这个明明用单向链表+Map就能实现，为什么要使用更加复杂的双线链表呢？</p>
<p>后来我又对比了双向链表与单向链表的的不同，单向链表每个节点只知道下个节点的内存地址，而不知道它上个节点的地址，双向链表既知道下个节点的地址，也知道上个节点的地址。正是因为这个原因，当我们要移动某个节点，比如移动中间的节点使它作为头部节点，假如用的是单向链表，因为它不知道它的上一个节点，所以还要遍历整个链表，找到上个节点，然后才能衔接起来。而双向链表不用遍历整个链表，它自己就知道它的上个节点地址。虽然双向链表更加复杂了一点，但是带来的好处，对性能的提升也是不言而喻的。</p>
<h3 id="接口的设计"><a href="#接口的设计" class="headerlink" title="接口的设计"></a>接口的设计</h3><p>YYCache里的接口及架构设计可以说是简洁明了，YYCache持有YYMemoryCache和YYDiskCache，两者分别负责内存缓存及磁盘缓存，两者之间互不影响。再来看下相关的api</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@interface YYCache : NSObject</div><div class="line"></div><div class="line">@property (copy, readonly) NSString *name</div><div class="line">@property (strong, readonly) YYMemoryCache *memoryCache</div><div class="line">@property (strong, readonly) YYDiskCache *diskCache</div><div class="line"></div><div class="line">- (nullable instancetype)initWithName:(NSString *)name</div><div class="line">- (nullable instancetype)initWithPath:(NSString *)path</div><div class="line">+ (nullable instancetype)cacheWithName:(NSString *)name</div><div class="line"></div><div class="line">- (BOOL)containsObjectForKey:(NSString *)key</div><div class="line">- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block</div><div class="line"> </div><div class="line">- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key</div><div class="line">- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block</div><div class="line"> </div><div class="line">- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key</div><div class="line">- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block</div><div class="line">- (void)removeObjectForKey:(NSString *)key</div><div class="line">- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block</div><div class="line">- (void)removeAllObjects</div><div class="line">- (void)removeAllObjectsWithBlock:(void(^)(void))block</div><div class="line">- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress</div><div class="line">                                 endBlock:(nullable void(^)(BOOL error))end</div></pre></td></tr></table></figure>
<p>可以说不用看注释，看方法名就可以直接知道该方法的作用，并且没有一个多余的方法。哪些方法该放在<code>.h</code>文件里声明给外部调用，哪些方法该放在<code>.m</code>文件里私有操作，都控制的完美无瑕。</p>
<p>YYCache里的接口及架构设计可以说是作为一个SDK的典范，并且代码也对每一个细节追求到极致。正因为设计的这么漂亮，源码读起来才会通俗易懂，让人赞叹👍！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/26/dispatch_once线程安全/" itemprop="url">
                  dispatch_once线程安全
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-26T22:04:18+08:00" content="2018-07-26">
              2018-07-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/26/dispatch_once线程安全/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/26/dispatch_once线程安全/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/07/26/dispatch_once线程安全/" class="leancloud_visitors" data-flag-title="dispatch_once线程安全">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">   ...</div><div class="line">&#125;);</div><div class="line">return instance;</div></pre></td></tr></table></figure>
<p>说到单例，大家都会想到用<code>dispatch_once</code>实现，今天来探究一下<code>dispatch_once</code>内部如何操作的，如何保证线程安全的。</p>
<p><code>dispatch_once_t</code>实质就是个<code>long</code>类型的基本变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef long dispatch_once_t</div></pre></td></tr></table></figure>
<p><code>dispatch_once</code> 函数实现为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void  dispatch_once(dispatch_once_t *val, dispatch_block_t block) &#123;</div><div class="line"></div><div class="line">	dispatch_once_f(val, block, _dispatch_Block_invoke(block));</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将基本变量的指针及block传进去，<code>dispatch_block_t</code> 是自定义的 ，这个<code>block</code>就是我们要实现的初始化方法，无参数，无返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void (^dispatch_block_t)(void);</div></pre></td></tr></table></figure>
<p><code>_dispatch_Block_invoke</code>也是个宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define _dispatch_Block_invoke(bb) \</div><div class="line">		((dispatch_function_t)((struct Block_layout *)bb)-&gt;invoke)</div></pre></td></tr></table></figure>
<p>它的作用是获得<code>block</code>内部的<code>invoke</code>的函数指针，这个指针指向的具体的<code>block</code>实现函数的调用地址，就是我们自己在<code>dispatch_block_t</code>里写的那段代码的具体实现地址。</p>
<p>将变量地址，<code>block</code>，<code>invoke</code>三个参数传入<code>dispatch_once_f</code>方法里，下面继续分析<code>dispatch_once_f</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)</div><div class="line">&#123;</div><div class="line">#if !DISPATCH_ONCE_INLINE_FASTPATH</div><div class="line">	if (likely(os_atomic_load(val, acquire) == DLOCK_ONCE_DONE)) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">#endif // !DISPATCH_ONCE_INLINE_FASTPATH</div><div class="line">	return dispatch_once_f_slow(val, ctxt, func);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>DISPATCH_ONCE_INLINE_FASTPATH</code>是判断当前编译环境，是真机还是模拟器。最终实现方法来到了<code>dispatch_once_f_slow</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">dispatch_once_f_slow(dispatch_once_t *val, void *ctxt, dispatch_function_t func)</div><div class="line">&#123;</div><div class="line">#if DISPATCH_GATE_USE_FOR_DISPATCH_ONCE</div><div class="line">	dispatch_once_gate_t l = (dispatch_once_gate_t)val;</div><div class="line"></div><div class="line">	if (_dispatch_once_gate_tryenter(l)) &#123;</div><div class="line">		_dispatch_client_callout(ctxt, func);</div><div class="line">		_dispatch_once_gate_broadcast(l);</div><div class="line">	&#125; else &#123;</div><div class="line">		_dispatch_once_gate_wait(l);</div><div class="line">	&#125;</div><div class="line">#else</div><div class="line">	_dispatch_once_waiter_t volatile *vval = (_dispatch_once_waiter_t*)val;</div><div class="line">	struct _dispatch_once_waiter_s dow = &#123; &#125;;</div><div class="line">	_dispatch_once_waiter_t tail = &amp;dow, next, tmp;</div><div class="line">	dispatch_thread_event_t event;</div><div class="line"></div><div class="line">	if (os_atomic_cmpxchg(vval, NULL, tail, acquire)) &#123;</div><div class="line">		dow.dow_thread = _dispatch_tid_self();</div><div class="line">		_dispatch_client_callout(ctxt, func);</div><div class="line"></div><div class="line">		next = (_dispatch_once_waiter_t)_dispatch_once_xchg_done(val);</div><div class="line">		while (next != tail) &#123;</div><div class="line">			tmp = (_dispatch_once_waiter_t)_dispatch_wait_until(next-&gt;dow_next);</div><div class="line">			event = &amp;next-&gt;dow_event;</div><div class="line">			next = tmp;</div><div class="line">			_dispatch_thread_event_signal(event);</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		_dispatch_thread_event_init(&amp;dow.dow_event);</div><div class="line">		next = *vval;</div><div class="line">		for (;;) &#123;</div><div class="line">			if (next == DISPATCH_ONCE_DONE) &#123;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			if (os_atomic_cmpxchgv(vval, next, tail, &amp;next, release)) &#123;</div><div class="line">				dow.dow_thread = next-&gt;dow_thread;</div><div class="line">				dow.dow_next = next;</div><div class="line">				if (dow.dow_thread) &#123;</div><div class="line">					pthread_priority_t pp = _dispatch_get_priority();</div><div class="line">					_dispatch_thread_override_start(dow.dow_thread, pp, val);</div><div class="line">				&#125;</div><div class="line">				_dispatch_thread_event_wait(&amp;dow.dow_event);</div><div class="line">				if (dow.dow_thread) &#123;</div><div class="line">					_dispatch_thread_override_end(dow.dow_thread, val);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		_dispatch_thread_event_destroy(&amp;dow.dow_event);</div><div class="line">	&#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很长，逐段分析：</p>
<p>首先初始化了一系列的变量，<code>_dispatch_once_waiter_s</code>类似于链表中的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct _dispatch_once_waiter_s &#123;</div><div class="line">	volatile struct _dispatch_once_waiter_s *volatile dow_next; // 下一个节点</div><div class="line">	dispatch_thread_event_s dow_event; // 信号量</div><div class="line">	mach_port_t dow_thread; // 线程端口</div><div class="line">&#125; *_dispatch_once_waiter_t;</div></pre></td></tr></table></figure>
<p><code>if (os_atomic_cmpxchg(vval, NULL, tail, acquire))</code>这行代码展开为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (*vval == NULL) &#123;</div><div class="line">	*vval = tail = &amp;dow;</div><div class="line">	return true;</div><div class="line">&#125; else &#123;</div><div class="line">	return false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>意思是传入的<code>*vval == NULL</code>如果为nil，则赋值，并返回true，并且这个方法是原子操作的。当我们第一次进来，<code>val=0</code>接下来执行<code>if</code>里面的代码。</p>
<p><code>_dispatch_client_callout</code>表示执行<code>block</code>，然后将next标记为<code>DISPATCH_ONCE_DONE</code>。</p>
<p>假如整个过程只有一个线程，那么下面的while循环不会执行，执行到这里就结束了，。假如有其他线程进来，就会进入else分支里。</p>
<p>else分支里，是一个死循环，先判断<code>if (next == DISPATCH_ONCE_DONE)</code>，如果是，直接跳出循环。每进来一次，都会生成一个<code>_dispatch_once_waiter_s</code>的节点，添加到链表的尾部，然后调用信号量等待。而链表的头部是第一次进来的，进入到if代码段的那个节点。当if分支执行完后，会进入while循环遍历链表，依次发送信号将线程唤醒。</p>
<p>这就是全部的执行过程，用到的知识点主要是原子性操作、链表。由此可以看出大家都说<code>dispatch_once</code>只执行一次这种说话是不严谨的，它本质上可以执行多次，只是把每次执行请求放到了内部的链表里。<br>还是画个图吧。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/dispatch_once%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/10/iOS国际化/" itemprop="url">
                  iOS国际化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-10T20:19:13+08:00" content="2018-07-10">
              2018-07-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/10/iOS国际化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/10/iOS国际化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/07/10/iOS国际化/" class="leancloud_visitors" data-flag-title="iOS国际化">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目里添加了国际化及应用内语言切换功能，遂整理下。</p>
<h3 id="简单国际化"><a href="#简单国际化" class="headerlink" title="简单国际化"></a>简单国际化</h3><p>当我们创建一个新应用时，文件目录下会默认有一个 <code>Base.lproj</code> 文件，这个文件就是项目在英文语言环境下的默认本地化文件夹。当我们不做国际化时，这个文件没什么用。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/international_baselproj.png" alt="image"><br>假如我们想支持更多的语言，可以在项目里这里设置</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/international_addLanguage.png" alt="image"></p>
<p>添加完成之后项目文件目录就多了几个语言文件，比如我们新添加了两种：简体中文和繁体中文</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/international_wenjain.png" alt="image"></p>
<h4 id="应用名称国际化"><a href="#应用名称国际化" class="headerlink" title="应用名称国际化"></a>应用名称国际化</h4><p>创建InfoPlist.strings文件(InfoPlist.strings，名称不要写错…)<br><img src="http://ocauxqtbu.bkt.clouddn.com/international_strings.png" alt="image"><br>然后分别在 <code>InfoPlist.strings</code> 文件里添加不同语言的key value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFBundleDisplayName = &quot;international&quot;;// 英文</div><div class="line">CFBundleDisplayName = &quot;国际化Demo&quot;;// 中文</div></pre></td></tr></table></figure>
<p>不仅应用名称可以国际化，其他 <code>info.plist</code> 中的字段可以设置，比如隐私权限设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSPhotoLibraryUsageDescription = &quot;请点击&apos;好&apos;以允许访问。如果不允许,你将无法使用图片功能&quot;;</div><div class="line">NSCameraUsageDescription = &quot;请点击&apos;好&apos;以允许访问。如果不允许,你将无法使用拍摄功能&quot;;</div><div class="line">NSMicrophoneUsageDescription = &quot;请点击&apos;好&apos;以允许访问。如果不允许,你将无法使用麦克风功能&quot;;</div><div class="line">NSLocationWhenInUseUsageDescription = &quot;请点击&apos;好&apos;以允许访问。如果不允许,你将无法使用位置功能&quot;;</div></pre></td></tr></table></figure>
<p>添加完之后切换语言应用名称会跟着更换：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/international_test4.jpg" alt="image"></p>
<h4 id="应用内容国际化"><a href="#应用内容国际化" class="headerlink" title="应用内容国际化"></a>应用内容国际化</h4><p>创建一个strings文件来用作内容国际化，下面会有三个子文件分别用来操作对应语言的国际化内容<br><img src="http://ocauxqtbu.bkt.clouddn.com/international_localizable.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;LabelText&quot;=&quot;hello,world&quot;;//英文</div><div class="line">&quot;LabelText&quot;=&quot;你好,世界&quot;;//中文</div></pre></td></tr></table></figure>
<p>当我们在代码中这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 100, 30)];</div><div class="line">label.text = NSLocalizedStringFromTable(@&quot;LabelText&quot;, @&quot;Localizable&quot;, nil);</div><div class="line">[self.view addSubview:label];</div></pre></td></tr></table></figure>
<p>那么这个lable就会当前手机系统的语言环境，根据 <code>LabelText</code> 这个key去取对应语言的value，如果应用没有对手机系统的语言进行国际化，则取默认语言，比如英文。</p>
<p>以上就是对APP进行简单国际化，但是这样有一点不好，就是只能根据手机系统自适应处理，无法进行APP内语言的切换。所以语言的国际化和应用内切换语言要我们自己来实现。 </p>
<h3 id="国际化的本质"><a href="#国际化的本质" class="headerlink" title="国际化的本质"></a>国际化的本质</h3><p>国际化的本质就是根据指定的language，找到本地此语言对应的资源文件(bundle)，在文件中查找key对应的字符串。应用名称的国际化，和APP内容的国际化都是这一个原理，那么我们就从这个原理入手，简述一下实现流程</p>
<ul>
<li>1.启动应用后，先查看本地有没有上次保存的语言id，如果有，则设这个语言为当前APP语言</li>
<li>2.如果没有，证明为第一次打开，即从APPStore下载后第一次打开，此时获取手机系统语言，假如APP内对这个语言进行国际化了，则把这个语言设置APP内语言，如果没有，使用默认语言，比如英语。(比如手机系统里语言为德语，但是没有对这个语言进行国际化)</li>
<li>3.后续的APP名称及APP内界面内容都根据设置的语言来进行国际化处理</li>
<li>4.APP内切换语言,就是改变了查找的bundle文件。比如，之前是英语，翻译字符串value从英语环境下的bundle文件下查找，切换成中文后，从中文环境下的bundle文件中查找value。最后，保存切换后的语言id到本地，以便下次使用。</li>
</ul>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="自建-lproj文件"><a href="#自建-lproj文件" class="headerlink" title="自建 lproj文件"></a>自建 <code>lproj</code>文件</h4><p>刚才提到了，添加语言后会在项目目录下自动生成对应语言的 <code>lproj</code> 文件。在这里，我们可以手动创建 <code>lproj</code> 文件。然后将这些文件放到一个文件夹下，统一管理<br><img src="http://ocauxqtbu.bkt.clouddn.com/international_addlproj.png" alt="image"><br>切换语言后，将bundle路径换成切换后语言的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// self.currentLanguage 为 zh-hans 或 zh-Hant 或 en</div><div class="line">NSString *path = [[NSBundle mainBundle]pathForResource:self.currentLanguage ofType:@&quot;lproj&quot;];</div><div class="line">self.bundle = [NSBundle bundleWithPath:path];</div></pre></td></tr></table></figure>
<p>获取key对应的value时，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(NSString *)getStringForKey:(NSString *)key withTable:(NSString *)table</div><div class="line">&#123;</div><div class="line">    if (self.bundle)</div><div class="line">    &#123;</div><div class="line">        return NSLocalizedStringFromTableInBundle(key, table, self.bundle, @&quot;&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return NSLocalizedStringFromTable(key, table, @&quot;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>-(NSString *)getStringForKey:(NSString *)key withTable:(NSString *)table</code> 这个方法为语言管理单例类的public方法，在 <code>.h</code>文件中声明，value都是通过单例类调用这个方法来获得各个语言的value。</p>
<h4 id="和服务端的同步"><a href="#和服务端的同步" class="headerlink" title="和服务端的同步"></a>和服务端的同步</h4><p>当我们从APPStore下载APP后，第一次打开应用获得当前手机系统的语言，还要把这个语言同步到服务端，告诉服务端我们使用的是哪个语言，并且后续的接口调用都要用到这个语言id。</p>
<p>服务端保存一份手机系统上所有语言的字符串列表，分安卓和iOS，这个需要安卓开发人员和iOS开发人员提供给后台，比如我提供的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@&quot;zh-Hans&quot;  //简体中文</div><div class="line">@&quot;zh-Hant&quot; //繁体中文</div><div class="line">@&quot;en&quot; //英语</div><div class="line">@&quot;ja&quot; //日文</div></pre></td></tr></table></figure>
<p>第一次启动时，通过 <code>[NSLocale preferredLanguages].firstObject</code> 这个方法获得当前手机系统语言，调用服务端语言接口后，拿当前手机系统语言和接口数据对比，获得语言id，然后后续的接口调用都可以使用这个语言id了。</p>
<h4 id="第三方库的国际化"><a href="#第三方库的国际化" class="headerlink" title="第三方库的国际化"></a>第三方库的国际化</h4><p>项目里采用了 <code>MJRefresh</code> 第三方刷新库，控件里的刷新状态文字也要国际化。但是这个库的国际化是自己做的，当APP内切换语言后，控件上的文字还是之前语言的文字。看了下源码，最后通过 <code>NSBundle+MJRefresh</code> 文件里的这个方法来获得不同语言的value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)mj_localizedStringForKey:(NSString *)key value:(NSString *)value &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是通过当前语言，获得bundle资源文件，然后在资源文件里得到value后返回。因为它自己有bundle资源文件，我们只需要把bundle文件的路径换成当前语言的文件路径就可以了。</p>
<p>当然了，不只这个刷新控件，其他有使用道的第三方库，也要国际化一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/06/我的产品体会/" itemprop="url">
                  我的产品体会
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-06T11:18:04+08:00" content="2018-07-06">
              2018-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/读书与感悟/" itemprop="url" rel="index">
                    <span itemprop="name">读书与感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/06/我的产品体会/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/06/我的产品体会/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/07/06/我的产品体会/" class="leancloud_visitors" data-flag-title="我的产品体会">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>踏入互联网移动开发这个行业也有三年了，从当初的懵懵懂懂到现在略有思考，这里说思考有点夸大了，只是从码农的角度，对于产品有自己的一点体会。可能与其他程序员不同，其他从事技术的程序员，都想成为全栈工程师，学学后端，学学前端，但是自己在闲暇之余，更多的是思考如何做好一个产品，给用户更好的体验。最近自己也看了几本关于互联网及产品的书籍，结合自己的经验，说一下自己的拙见。<br>我觉得一个好产品，应该有以下几个特点：</p>
<ul>
<li>有用</li>
<li>好用</li>
<li>改进的能力</li>
<li>商业模式</li>
</ul>
<h3 id="对我有用"><a href="#对我有用" class="headerlink" title="对我有用"></a>对我有用</h3><p>有用，即你这个产品对于我到底有什么用处，我能从中得到什么方便，核心思想就是定位你的核心功能以及核心用户。比如，你向我介绍一个小说类APP，说它内容如何丰富，体验如何良好，但是我从来不看小说，何来用这个小说APP之说。在做产品的时候，开发一个功能的时候，尽量多想想这个功能是否对用户有用处，是否对产品的核心用户有好处。当要加入一个功能时，多听听核心用户的声音。</p>
<p>如何定位你的核心用户，用户是什么样的人，用户需要什么，用户喜欢什么，用户讨厌什么，对于不同的行业平台，要有不同的思考方式。比如对于知乎，简书，掘金这种注重内容的，那些能够产生高质的博客的用户，就是核心用户；对于打车类的APP而言，经常出差的用户就是核心用户；YY语音的核心用户是游戏玩家。</p>
<p>当你的核心功能定位以后，不要轻易转型，也可以说，想转型也不是那么容易的。</p>
<p>比如我现在做的这个美甲APP，它的核心功能就是视频教学，美图展示；它的核心用户就是那些有强烈的学习欲望，通过这个平台能够提升自己的能力，购买所需要的物品。</p>
<h3 id="好用"><a href="#好用" class="headerlink" title="好用"></a>好用</h3><p>好用，即你这个产品用起来是否方便，对比与同行的竞争品，有什么特别的地方吸引我。</p>
<p>我一直提倡的是，保证内容优质的情况下，界面越简洁越好。这里不得不说一下微信，微信自从上线以来，界面一直保持简洁清爽的风格，并且可控制界面的显示内容，比如发现页面的管理。这里就体现出界面设计师的重要性了，一个界面该显示什么，不该显示什么，显示的话，应该以怎样的方式去呈现，这些都应该是好好斟酌的东西。再比如我有时候会看一下游戏直播，虎牙，斗鱼，熊猫这些APP都用过，其中最喜欢虎牙APP的界面风格，很简洁，没有杂乱无章的内容。我就只是想简单的看个直播而已，其他APP确给我推荐了很多无用的信息。</p>
<p>这里举个例子，设置界面如何排版。设置界面包括对账号的管理、APP设置的管理以及其他辅助的小功能。这里要分清什么功能要归到账号管理类目下，什么功能归到APP设置管理类目下，内容定下来，呈现风格就按平台的风格来呈现。iOS APP的风格就按苹果手机本身设置里的风格来，安卓APP就按安卓手机本身的设置风格来，没必要完全统一。</p>
<p>这里额外提一点，尽量少用弹框，这是用户很反感的信息呈现形式。</p>
<h3 id="改进的能力"><a href="#改进的能力" class="headerlink" title="改进的能力"></a>改进的能力</h3><p>意思就是你的产品要有持续的改进等能力，不要一直原地踏步，比如其他APP上有一些优秀的交互设计，可以借鉴一下。但是有一点特别重要，如果只是一味的抄袭借鉴，那么永远也学不到它的精髓。</p>
<p>当你加入了一个功能时，比如社区等，用这个功能的人很少，这时就要思考这个功能对于你这个APP的意义是什么，是否真的给用户带来了好处？</p>
<p>当你的核心用户给你的产品提建议时，不要忽视它，因为这是真真正正使用你产品的人的想法。如果他的建议被采纳，下个版本中更新了他的建议，那么他肯定会认为这个产品是个不断成长的产品，他认可了这个产品，说不一定他还会向同事朋友去推销你的产品。</p>
<h3 id="商业模式"><a href="#商业模式" class="headerlink" title="商业模式"></a>商业模式</h3><p>商业模式，我理解的分为两个部分，一个推广模式，二是盈利模式。</p>
<p>对于如何推广，一味的砸钱是行不通的，只能解决得了一时。一个推广模式是否为好的推广模式，最简单的方法就是，不再砸钱了，看用户数是否还在增长。对于盈利模式，在找投资时，投资人都会问，你的产品将来怎么赢利，有没有找到好的盈利模式。在周鸿祎的《我的互联网方法论》中提到了互联网的盈利模式有三种：</p>
<p>1.在网上卖东西。卖真实的东西，衣服鞋子，这种叫电子商务；卖股票基金等理财产品，叫互联网金融；卖虚拟的服务，叫O2O.</p>
<p>2.依靠广告收入。</p>
<p>3.以网游为代表的增值服务。</p>
<p>这三种方式都很常见，而对于移动APP来说，最普遍的就是广告收入了，通过接入广告，来赚取利益。但是，接入广告也要有好的方法，不要让用户反感。</p>
<p>总的来说，一个产品要有一个好的想法，好的方向，是否能为大众群体提供方便，加上可靠的技术团队实力和推广手段。唉，这话说起来容易，实现起来何其难啊！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/zhoujian_headerImage.jpeg"
               alt="Zhou Jian" />
          <p class="site-author-name" itemprop="name">Zhou Jian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coderZhou10496" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"coderzhou"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Bw40KBIPanRkt0iqTr7NLT6I-gzGzoHsz", "MQjFPSYkEazqnUv2rS7TOsui");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
