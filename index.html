<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Jianless的博客">
<meta property="og:url" content="http://coderzhou.com/index.html">
<meta property="og:site_name" content="Jianless的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jianless的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coderzhou.com/"/>

  <title> Jianless的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Jianless的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">专注于iOS开发</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/06/WebSocket/" itemprop="url">
                  WebSocket
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-04-06T21:42:48+08:00" content="2019-04-06">
              2019-04-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/04/06/WebSocket/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/06/WebSocket/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/04/06/WebSocket/" class="leancloud_visitors" data-flag-title="WebSocket">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目里的直播聊天系统使用了WebSocket进行通信，故了解了一番WebSocket的知识。</p>
<h3 id="WebSocket协议细解"><a href="#WebSocket协议细解" class="headerlink" title="WebSocket协议细解"></a>WebSocket协议细解</h3><p>WebSocket协议和HTTP协议一样，也是应用层协议，都是基于TCP的，可靠性的传输协议。不同点主要有两点：</p>
<ul>
<li><ol>
<li>WebSocket是双向通信协议，客户端与服务端都可以发送或接收信息</li>
</ol>
</li>
<li><ol>
<li>WebSocket的连接需要HTTP的一次握手</li>
</ol>
</li>
</ul>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>首先客户端发送一个请求，报文格式规定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">方法必须位GET方法</div><div class="line">HTTP版本不能低于1.1</div><div class="line">必须包含Upgrade头部，值必须为websocket</div><div class="line">必须包含Sec-WebSocket-Key头部，值是一个Base64编码的16字节随机字符串。</div><div class="line">必须包含Sec-WebSocket-Version头部，值必须为13</div></pre></td></tr></table></figure>
<p>其中Upgrade、Connection字段，就是告诉服务端，我要建立一个WebSocket的连接。即为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://example.com</div></pre></td></tr></table></figure>
<p>上面是建立WebSocket连接的一个请求头，类似HTTP的连接。</p>
<p>服务端验证客户端的握手包符合规范之后也会发送一个握手包给客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure>
<p>规范为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">必须包含Connection头部，值必须为Upgrade</div><div class="line">必须包含一个Upgrade头部，值必须为websocket</div><div class="line">必须包含一个Sec-Websocket-Accept头部</div></pre></td></tr></table></figure>
<p>Sec-WebSocket-Accept的值与Sec-WebSocket-Key是对应的，由计算方式计算而来:</p>
<ol>
<li>将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。</li>
<li>通过SHA1计算出摘要，并转成base64字符串。</li>
</ol>
<p>客户端收到服务端的握手包之后，验证Sec-Websocket-Accept的值，验证正确后连接成功，之后就跟HTTP协议没有什么关系了，数据传输完全就是WebSocket协议的内容。</p>
<h4 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h4><p>在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。从<a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="external">RFC文档</a>可以看出数据帧格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0                   1                   2                   3</div><div class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</div><div class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</div><div class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</div><div class="line">| |1|2|3|       |K|             |                               |</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|     Extended payload length continued, if payload len == 127  |</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|                               |Masking-key, if MASK set to 1  |</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">| Masking-key (continued)       |          Payload Data         |</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|                     Payload Data continued ...                |</div><div class="line">+---------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>FIN: 如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>
<p>RSV1, RSV2, RSV3：扩展使用，一般情况下全为0。</p>
<p>opcode：操作代码，Opcode的值决定了应该如何解析后续的数据（data payload）。如果操作代码是不认识的，那么接收端应该断开连接。代码如下</p>
<ul>
<li>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片</li>
<li>%x1：表示这是一个文本帧（frame）</li>
<li>%x2：表示这是一个二进制帧（frame）</li>
<li>%x3-7：保留的操作代码，用于后续定义的非控制帧。</li>
<li>%x8：表示连接断开。</li>
<li>%x9：表示这是一个ping操作。</li>
<li>%xA：表示这是一个pong操作。</li>
<li>%xB-F：保留的操作代码，用于后续定义的控制帧。</li>
</ul>
<p>Mask：表示是否要对数据（data payload）进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p>
<p>Payload length：数据的长度，单位是字节。</p>
<p>Payload Data：传输的数据。</p>
<p>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。<br>WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>
<p>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p>
<h4 id="连接保持-心跳"><a href="#连接保持-心跳" class="headerlink" title="连接保持(心跳)"></a>连接保持(心跳)</h4><p>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<ul>
<li>发送方-&gt;接收方：ping</li>
<li>接收方-&gt;发送方：pong</li>
</ul>
<p>ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。</p>
<h3 id="iOS端WebScoket实现"><a href="#iOS端WebScoket实现" class="headerlink" title="iOS端WebScoket实现"></a>iOS端WebScoket实现</h3><p>我们iOS客户端使用了FaceBook的<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="external">SocketRocket</a>来进行通信，SocketRocket内部实现了握手连接，发送与接收数据，发送ping，接收pong功能。我们使用暂时没有发现什么问题，唯一需要注意的是要自己实现心跳包及重连的代码。</p>
<p>建立连接方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)initWithURLRequest:(NSURLRequest *)request</div></pre></td></tr></table></figure>
<p>代理方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)webSocketDidOpen:(SRWebSocket *)webSocket;</div><div class="line">- (void)webSocket:(SRWebSocket *)webSocket didFailWithError:(NSError *)error;</div><div class="line">- (void)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(NSInteger)code reason:(NSString *)reason wasClean:(BOOL)wasClean;</div><div class="line">- (void)webSocket:(SRWebSocket *)webSocket didReceivePong:(NSData *)pongPayload;</div></pre></td></tr></table></figure>
<p>打开与关闭：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)open;</div><div class="line">- (void)close;</div></pre></td></tr></table></figure>
<p>发送数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)send:(id)data;</div></pre></td></tr></table></figure>
<p>发送ping:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)sendPing:(NSData *)data;</div></pre></td></tr></table></figure>
<p>基本上用这几个方法就能实现想要的功能。因为我们要自己维持心跳连接及重连，所以还要再封装一层，代码见<a href="https://github.com/coderZhou10496/ZJWebSocket" target="_blank" rel="external">Github</a>。</p>
<p>建立连接的时候，调用了SocketRocket的<code>- (void)setDelegateDispatchQueue:(dispatch_queue_t)queue</code>方法，用意是数据的接收全都在指定的队列里，放在子线程中进行，因为聊天功能要频繁的接收消息。所有我们创建了一个串行队列传给SocketRocket。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.delegateRecQueue = dispatch_queue_create(&quot;com.zj.socket.queue&quot;,DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">[self.webSocket setDelegateDispatchQueue:self.delegateRecQueue];</div></pre></td></tr></table></figure>
<p>判断是否重连的机制为：</p>
<p>当收到 <code>didFailWithError</code> 和 <code>didCloseWithCode</code>方法时，先判断是否是自己主动关闭了WebSocket连接，如果是自己主动关闭了连接，则不做处理；如果是未知错误而关闭了连接，则进行重连机制。重连的时候先判断是否有网，如果无网络的话，也没有重连的必要了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)reConnect &#123;</div><div class="line">    if(self.connectType == WebSocketConnect) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    [self webSocketClose];</div><div class="line">    </div><div class="line">    if (self.reConnectTime &gt;= 32) &#123;</div><div class="line">        self.reConnectTime = 1;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    __block NSInteger time = self.reConnectTime;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;重连&quot;);</div><div class="line">        time = time * 2;</div><div class="line">        self.reConnectTime = time;</div><div class="line">        [self webSocketOpen];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重连之前要确保在主线程中进行，并且确保之前的连接已经关闭了。</p>
<p>连接成功后创建心跳定时器，定时发送ping数据，调用SocketRocket的<code>sendPing</code>方法就行，这个方法内部是做数据处理，标记这个数据为ping数据：<br>，心跳的数据格式和服务端协商好就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#pragma mark - 心跳定时器</div><div class="line">- (void)createHeartBeat &#123;</div><div class="line">    dispatch_main_async_safe(^&#123;</div><div class="line">        [self cancelHeartBeat];</div><div class="line">        </div><div class="line">        self.heartBeat = [NSTimer timerWithTimeInterval:30 target:self selector:@selector(heartBeatFire) userInfo:nil repeats:YES];</div><div class="line">        </div><div class="line">        [[NSRunLoop currentRunLoop]addTimer:self.heartBeat forMode:NSRunLoopCommonModes];</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)sendPing &#123;</div><div class="line">    if([self netWorkReachable]) &#123;</div><div class="line">        NSDictionary *dicData = @&#123;&#125;;</div><div class="line">        NSData *data = [NSJSONSerialization dataWithJSONObject:dicData options:NSJSONWritingPrettyPrinted error:nil];</div><div class="line">        [self.webSocket sendPing:data];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在代码里我专门创建了一个用于接收消息的类<code>ZJMessageHandler</code>，WebSocket收到的消息都会交由这个类进行处理，处理后再交给上层不同的业务方。</p>
<p>详细代码见<a href="https://github.com/coderZhou10496/ZJWebSocket" target="_blank" rel="external">Github</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/16/自律以自救/" itemprop="url">
                  自律以自救
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-03-16T17:22:58+08:00" content="2019-03-16">
              2019-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/读书与感悟/" itemprop="url" rel="index">
                    <span itemprop="name">读书与感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/03/16/自律以自救/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/16/自律以自救/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/03/16/自律以自救/" class="leancloud_visitors" data-flag-title="自律以自救">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进入新公司已半年有余，不知道怎的，感觉每天时间过的特别快，什么都还没做一天时间就过去了。上个月更是独立负责一个新的项目，工作节奏也更加紧凑，接触新的工作环境，融入新的团队，也只有在今天周末的时候有时间写下最近的生活工作感想。</p>
<p>之前在小的公司工作，每天有大量的业余时间，每天六点下班，下班之后想干嘛干嘛，那个时候还订了个目标来约束自己:每个月看一本书，或技术类，或文学类，或职场类。工作状态对于现在的我简直天差地别，新的工作单位工作更加忙碌，压力也更加大。感触比较深的一点是，大公司的开发流程是如此的规范。</p>
<p>其实我有的时候在想，忙碌的工作真的让我成长了吗？</p>
<p>成长是什么？我觉得就是今天的你，比昨天的你更优秀。比如写代码，你学到了一个新的api，学到了更好的代码方法实现功能，你的技能得到了成长；你认识了一个新朋友，你的人脉得到了成长；你今天生活中遇到的一个事，让你悟到了一个道理，你的生活阅历得到了成长。</p>
<p>互联网公司人才辈出，发展也迅速，也可能是这个原因是我有了一种焦虑感，觉得自己付出的不够多，学到的不够多。其实我自己内心的想法很多，但真正能够付诸实践，坚持下来的却很少。我觉得生活就应该被”打鸡血”(为何此时想到了传销)，应该活的更加激情一些，更加有意义一些，许三多说过，生活就应该做很多有意义的事，尝试一下没有没有做过的生活。</p>
<p>有新的目标真的挺重要的。我之前在小公司，目标是进入稳定的大公司工作，为了这个目标，去学习底层知识，去重新看计算机，HTPP相关的知识，去刷算法题，至少技术方面收获了很多。现在在规模稍大的公司，目标是提高自我管理能力，项目把控能力，问题分析能力，团队沟通能力，。在一个技术行业三年后，就不应该纯粹的关注于技术了，自己的软实力同等重要。前段时间看了一篇文章讲的很好，说的是程序员的阶段:</p>
<p>第一阶段 – 三年：</p>
<p>这个阶段将会淘汰掉一批不适合写代码的人。这一阶段，我们走出校园，迈入社会，成为一名程序员，正式从书本上的内容迈向真正的企业级开发。我们知道如何团队协作、如何使用项目管理工具、项目版本如何控制、我们写的代码如何测试如何在线上运行等等，积累了一定的开发经验，也对代码有了一定深入的认识，是一个比较纯粹的Coder的阶段。</p>
<p>第二阶段 – 五年</p>
<p>有些人在三年里，除了完成工作，在空余时间基本不会研究别的东西，这些人永远就是个Coder，年纪大一些势必被更年轻的人给顶替；有些人在三年里，除了写代码之外，还热衷于研究各种技术实现细节、看了N多好书、写一些博客、在Github上分享技术，这些人在五年后必然具备在技术上独当一面的能力并且清楚自己未来的发展方向，从一个Coder逐步走向系统分析师或是架构师，成为项目组中不可或缺的人物</p>
<p>第三阶段 – 十年</p>
<p>十年又是另一个门槛了，转行或是继续做一名程序员就在这个节点上。如果在前几年就抱定不转行的思路并且为之努力的话，那么在十年的这个节点上，有些人必然成长为一名对行业有着深入认识、对技术有着深入认识、能从零开始对一个产品进行分析的程序员，这样的人在公司基本担任的都是CTO、技术专家、首席架构师等最关键的职位。</p>
<p>可以看出，越来越注重团队。自己毕业三年多了，感觉自己还是处于第一阶段，惭愧惭愧。</p>
<p>关于业务与技术，之前一直比较注重于技术，而忽略了业务同等重要。业务理解能力，应该是程序员除了技术之外，最具价值的能力。技术本身很难赚钱，业务落地才能赚钱。单纯的技术进步不难，难得是如何在业务中发现问题，解决问题。一切的技术都是为业务服务的。拿我的实际情况来说，公司内部会有技术分享，假如你分享的技术能够与当前的业务相结合，解决当前的技术难题，那么这就是一场很有价值的分享；假如分享的技术跟业务没有一点关系，就算再高深，再牛X，我觉得也是没有达到分享的标准。</p>
<p>本来有个小目标，每天刷一道算法题，刷《剑指Offer》,也是因为新项目而没能坚持下去，中断了。最近关于学习这方面有些怠慢了，也有可能是新项目压力比较大，工作上有些烦躁，所以写这篇感想来激励自己，自律以自救，严格要求自己，希望自己每天抽出时间，读会书，看会技术博客，充实下自己。</p>
<p>上帝是公平的，你付出什么，总会得到成果的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/" itemprop="url">
                  Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-21T20:36:51+08:00" content="2019-02-21">
              2019-02-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/02/21/Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节/" class="leancloud_visitors" data-flag-title="Metal学习(三)：实战之LUT滤镜及饱和度模糊度调节">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>闲暇时间用Metal撸了一个图片处理demo，也查阅参考了很多大佬的文章，demo代码已上传至<a href="https://github.com/coderZhou10496/Filter" target="_blank" rel="external">Github</a></p>
<h3 id="LUT滤镜"><a href="#LUT滤镜" class="headerlink" title="LUT滤镜"></a>LUT滤镜</h3><p>LUT是look up table，查找表的缩写，所有的颜色都可以在一张表(图片)上找到。我们知道R、G、B三种颜色分别有256种取值，所有的颜色组合就有256X256X256种情况，大约占48MB空间，占用很大的内存，但是有了LUT映射表后，我就可以对任意一张图片进行相同的滤镜变换。</p>
<p>我们遍历图片的像素点，对于每一个像素点，获得其 RGB 组合，在 LUT 表格中查找此 RGB 组合及其对应的 RGB 映射值，然后用 RGB 映射值替换原图的像素点，就可以完成滤镜变换了。但是如何在一张图片中存储三种颜色值的组合呢？</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/original.png" width="50%"><br></div>

<p><br></p>
<p>上图就是一张标准的颜色查找表。它在横竖方向上分成了 8X8 一共 64 个小方格，每一个小方格内的 B 分量为一个定值，总共就表示了 B 分量的 64 种可能值。同时对于每一个小方格，横竖方向又各自分为 64 个小格，横向小格的 R 分量依次增加，纵向小格的 G 分量依次增加。即：</p>
<ul>
<li>整体对每个小方块而言，从左上往右下 B 从 0 到 1 ，是 z 字型的顺序</li>
<li>单独对每个小方块而言，从左到右 R 从 0 到 1，代表 x</li>
<li>单独对每个小方块而言，从上到下 G 从 0 到 1，代表 y</li>
</ul>
<p>那么根据颜色查找表得到转换后的颜色步骤为：</p>
<p>1、用蓝色值R计算正方形的位置，假如一个像素点原来rgb是(0.1, 0.2, 0.4)，那么B = 0.4，则(0.4 <em> 63 = 25.6)/8 = 3，（25 - 3 </em> 8）= 1，即第3行第1列的那个大正方形，quad1.y = 3，quad1.x = 1.</p>
<p>2、根据红色值和绿色值计算对应位置在整个纹理的坐标。</p>
<p>texPos1.x = (quad1.x <em> 64 + rgb.r </em> 63 + 0.5)/512.0</p>
<p>texPos1.y = (quad1.y <em> 64 + rgb.g </em> 63 + 0.5)/512.0</p>
<p>这里，quad1.x * 64意思是：quad1.x和quad1.y是大正方形的坐标，每个大正方形是64格，所以乘以64；</p>
<p>rgb.r * 63意思是：每个大正方形是64格，即(0,63)；</p>
<p>加上0.5表示每个最小的小正方形的中心点；最后除以512.0是因为整个lut图片是512 * 512的，被放大了512倍。最后得到的是每个小正方格中心在整个lut大图中的坐标。</p>
<p>3、根据texPos1和texPos2读取映射结果，再用蓝色值的小数部分进行mix操作</p>
<p>shader代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">fragment float4</div><div class="line">lookUpTableShader(RasterizerData input [[stage_in]], // stage_in表示这个数据来自光栅化。（光栅化是顶点处理之后的步骤，业务层无法修改）</div><div class="line">               texture2d&lt;float&gt; normalTexture [[ texture(LYFragmentTextureIndexNormal) ]], // texture表明是纹理数据，LYFragmentTextureIndexNormal是索引</div><div class="line">               texture2d&lt;float&gt; lookupTableTexture [[ texture(LYFragmentTextureIndexLookupTable) ]]) // texture表明</div><div class="line">&#123;</div><div class="line">    constexpr sampler textureSampler (mag_filter::linear,</div><div class="line">                                      min_filter::linear); // sampler是采样器</div><div class="line">    float4 textureColor = normalTexture.sample(textureSampler, input.textureCoordinate); //正常的纹理颜色</div><div class="line">    </div><div class="line">    float blueColor = textureColor.b * 63.0; // 蓝色部分[0, 63] 共64种</div><div class="line">    </div><div class="line">    float2 quad1; // 第一个正方形的位置, 假如blueColor=22.5，则y=22/8=2，x=22-8*2=6，即是第2行，第6个正方形；（因为y是纵坐标）</div><div class="line">    quad1.y = floor(floor(blueColor) * 0.125);</div><div class="line">    quad1.x = floor(blueColor) - (quad1.y * 8.0);</div><div class="line">    </div><div class="line">    float2 quad2; // 第二个正方形的位置，同上。注意x、y坐标的计算，还有这里用int值也可以，但是为了效率使用float</div><div class="line">    quad2.y = floor(ceil(blueColor) * 0.125);</div><div class="line">    quad2.x = ceil(blueColor) - (quad2.y * 8.0);</div><div class="line">    </div><div class="line">    float2 texPos1; // 计算颜色(r,b,g)在第一个正方形中对应位置</div><div class="line">    texPos1.x = ((quad1.x * 64) +  textureColor.r*63 + 0.5)/512.0;</div><div class="line">    texPos1.y = ((quad1.y * 64) +  textureColor.g*63 + 0.5)/512.0;</div><div class="line">    </div><div class="line">    </div><div class="line">    float2 texPos2; // 同上</div><div class="line">    texPos2.x = ((quad2.x * 64) +  textureColor.r*63 + 0.5)/512.0;</div><div class="line">    texPos2.y = ((quad2.y * 64) +  textureColor.g*63 + 0.5)/512.0;</div><div class="line">    </div><div class="line">    float4 newColor1 = lookupTableTexture.sample(textureSampler, texPos1); // 正方形1的颜色值</div><div class="line">    float4 newColor2 = lookupTableTexture.sample(textureSampler, texPos2); // 正方形2的颜色值</div><div class="line">    </div><div class="line">    float4 newColor = mix(newColor1, newColor2, fract(blueColor)); // 根据小数点的部分进行mix</div><div class="line">    return float4(newColor.rgb, textureColor.w); //不修改alpha值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话我们就能从颜色查找表中得到了对应的转换后的颜色。</p>
<p>如果使用lut进行滤镜，那么每一种滤镜效果都对应着一张颜色查找表。上面给出的图片是原色的颜色查找表，所以使用这张查找表对要滤镜的图片进行处理的话，要滤镜的图片不会有任何变化。</p>
<p>而使用有滤镜效果的查找表进行处理，会有滤镜的效果</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_xiaoguo_1.jpg" width="70%" height="50%"><br></div>

<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_xiaoguo_2.jpg" width="70%" height="50%"><br></div>

<p><br></p>
<p>代码里，我封装了一个<code>ZJLookupTableImageFilter</code>工具类来进行lut滤镜，只需要传入一个MTKView和lut图片就可以进行lut滤镜</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface ZJLookupTableImageFilter : ZJBaseImageFilter</div><div class="line"></div><div class="line">+ (void)filterWithImageView:(ZJShaderLookupImageView *)imageView lookupTableImage:(UIImage *)lutImage;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的lookUpTableShader代码里传入了两个参数，一个是正常图片的texture，另一个是lut图片的texture，所以每选中一个lut图片对原图片进行滤镜处理时，需要得到lut图片的texture.这里我通过<code>ZJTextureProvider</code>这个工具类来获得一张图片的texture。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</div><div class="line">                                                                                             width:width</div><div class="line">                                                                                            height:height</div><div class="line">                                                                                         mipmapped:NO];</div><div class="line">textureDescriptor.usage = MTLTextureUsageShaderRead;</div><div class="line">id&lt;MTLTexture&gt; texture = [context.device newTextureWithDescriptor:textureDescriptor];</div><div class="line"></div><div class="line"></div><div class="line">MTLRegion region = &#123;&#123; 0, 0, 0 &#125;, &#123;image.size.width, image.size.height, 1&#125;&#125;; // 纹理上传的范围</div><div class="line">[texture replaceRegion:region mipmapLevel:0 withBytes:spriteData bytesPerRow:4 * image.size.width];</div><div class="line">free(spriteData);</div></pre></td></tr></table></figure>
<p>然后通过这行代码传入shader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[renderEncoder setFragmentTexture:self.lookupTableTexture</div><div class="line">                                  atIndex:1];</div></pre></td></tr></table></figure>
<p>注意这里index要传1，要和shader中的<code>LYFragmentTextureIndexLookupTable</code>对应</p>
<h3 id="颜色饱和度、模糊度"><a href="#颜色饱和度、模糊度" class="headerlink" title="颜色饱和度、模糊度"></a>颜色饱和度、模糊度</h3><p>模糊后的图片，可调节颜色饱和度及模糊度:</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_blur.jpg" width="50%" height="50%"><br></div>

<p><br></p>
<p>（本来是录制了一个视频的，但是有4M多，半天显示不出来，只好放图片了。）</p>
<p>无论是lut滤镜，还是模糊度调节，都是使用<code>MTLComputeCommandEncoder</code>来处理的。通过<code>computeCommandEncoder</code>方法来获得对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id&lt;MTLComputeCommandEncoder&gt; computeEncoder = [commandBuffer computeCommandEncoder]</div></pre></td></tr></table></figure>
<p>其中有一个地方要设置编码的线程组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[computeEncoder dispatchThreadgroups:self.groupCount</div><div class="line">                   threadsPerThreadgroup:self.groupSize];</div></pre></td></tr></table></figure>
<p>代码里使用<code>ZJShaderImageFilter</code>来进行饱和度模糊度调节，传入需要调节的图片及颜色饱和度value(0,1.0)，模糊度value(0,1.0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (void)shaderImageViewWithView:(ZJShaderImageView *)imageView </div><div class="line">   					saturationValue:(float)saturationValue </div><div class="line">   					blurRadiusValue:(float)blurRadiusValue</div></pre></td></tr></table></figure>
<p>两种效果的shader代码分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">kernel void adjust_saturation(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</div><div class="line">                              texture2d&lt;float, access::write&gt; outTexture [[texture(1)]],</div><div class="line">                              constant AdjustSaturationUniforms &amp;uniforms [[buffer(0)]],</div><div class="line">                              uint2 gid [[thread_position_in_grid]])</div><div class="line">&#123;</div><div class="line">    float4 inColor = inTexture.read(gid);</div><div class="line">    float value = dot(inColor.rgb, float3(0.299, 0.587, 0.114));</div><div class="line">    float4 grayColor(value, value, value, 1.0);</div><div class="line">    float4 outColor = mix(grayColor, inColor, uniforms.saturationFactor);</div><div class="line">    outTexture.write(outColor, gid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">kernel void gaussian_blur_2d(texture2d&lt;float, access::read&gt; inTexture [[texture(0)]],</div><div class="line">                             texture2d&lt;float, access::write&gt; outTexture [[texture(1)]],</div><div class="line">                             texture2d&lt;float, access::read&gt; weights [[texture(2)]],</div><div class="line">                             uint2 gid [[thread_position_in_grid]])</div><div class="line">&#123;</div><div class="line">    int size = weights.get_width();</div><div class="line">    int radius = size / 2;</div><div class="line">    </div><div class="line">    float4 accumColor(0, 0, 0, 0);</div><div class="line">    for (int j = 0; j &lt; size; ++j)</div><div class="line">    &#123;</div><div class="line">        for (int i = 0; i &lt; size; ++i)</div><div class="line">        &#123;</div><div class="line">            uint2 kernelIndex(i, j);</div><div class="line">            uint2 textureIndex(gid.x + (i - radius), gid.y + (j - radius));</div><div class="line">            float4 color = inTexture.read(textureIndex).rgba;</div><div class="line">            float4 weight = weights.read(kernelIndex).rrrr;</div><div class="line">            accumColor += weight * color;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    outTexture.write(float4(accumColor.rgb, 1), gid);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只需要处理texture，把最终的处理结果传给片元函数就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[renderEncoder setFragmentTexture:_texture</div><div class="line">                                  atIndex:0];</div></pre></td></tr></table></figure>
<p>即这里的_texture需要由外部控制，由<code>ZJShaderImageFilter</code>分别经过饱和度处理，模糊度处理后将最终需要传给shader的texture传入。</p>
<p>饱和度处理时，需要额外传入buffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct AdjustSaturationUniforms uniforms;</div><div class="line">    uniforms.saturationFactor = self.isDirty ? self.saturValue : 1.0;</div><div class="line">    id&lt;MTLBuffer&gt; buffer = [self.metalContext.device newBufferWithLength:sizeof(uniforms)</div><div class="line">                                                                 options:MTLResourceOptionCPUCacheModeDefault];</div><div class="line">    memcpy([buffer contents], &amp;uniforms, sizeof(uniforms));</div><div class="line">    </div><div class="line">    [computeEncoder setBuffer:buffer offset:0 atIndex:0];</div></pre></td></tr></table></figure>
<p>而对于模糊度处理，需要额外传入texture:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(self.blurTexture == nil) &#123;</div><div class="line">            [self configBlurTexture];</div><div class="line">        &#125;</div><div class="line">        [computeEncoder setTexture:self.blurTexture</div><div class="line">                           atIndex:2];</div></pre></td></tr></table></figure>
<p>当texture经过编码器(Command Encoder)分别经过饱和度处理和模糊处理时<br>我们是先处理饱和度，后处理模糊度，即饱和度的texture输出outputTexture,为模糊度的输入inputTexture,而模糊度的输出为shader的输入。所以一定要保证饱和度经过编码器(Command Encoder)处理后，再去进行模糊操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[commandBuffer waitUntilCompleted]</div></pre></td></tr></table></figure>
<p>最后一张简单的框架处理流程：</p>
<p><br></p>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_liucheng.jpg" width="100%"><br></div>

<p><br></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/21/Metal学习(一)：基本概念介绍/" itemprop="url">
                  Metal学习(一)：基本概念介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-21T20:13:10+08:00" content="2019-02-21">
              2019-02-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/21/Metal学习(一)：基本概念介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/21/Metal学习(一)：基本概念介绍/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/02/21/Metal学习(一)：基本概念介绍/" class="leancloud_visitors" data-flag-title="Metal学习(一)：基本概念介绍">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>断断续续的学习了<a href="https://developer.apple.com/documentation/metal?language=objc" target="_blank" rel="external">Metal</a>，整理下。</p>
<p>关于Metal的介绍，先引用官方文档的一句话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The Metal framework supports GPU-accelerated advanced 3D graphics rendering and data-parallel computation workloads. </div><div class="line">Metal provides a modern and streamlined API for fine-grained, low-level control of the organization, processing, </div><div class="line">and submission of graphics and computation commands, as well as the management of the associated data and resources </div><div class="line">for these commands. A primary goal of Metal is to minimize the CPU overhead incurred by executing GPU workloads.</div></pre></td></tr></table></figure>
<p>意思就是Metal框架提供了GPU加速的高级3D图形渲染功能和数据并行计算的功能，能够更有效地集成图形和计算任务，减小CPU消耗。</p>
<p>Metal优点：</p>
<ul>
<li>GPU 支持的 3D 渲染</li>
<li>和 CPU 并行处理数据 （深度学习）</li>
<li>提供低功耗接口</li>
<li>与 CPU 共享资源内存</li>
</ul>
<div align="center"><br><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/Metal_kuangjia.jpg" width="50%" height="50%"><br></div>



<p>Core Animation 依赖于 Metal 做 GPU 渲染，Core Graphics 做 CPU 渲染.</p>
<p>并且在iOS12中，苹果已经弃用了<a href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">OpenGL ES</a>对底层的支持，全面由Metal渲染。可见，苹果对于Metal框架越来越重视。研究Metal框架对于我们了解iOS系统是如何运作的，是怎么支持CoreAnimation框架进行渲染的有很大的帮助。并且用Metal能帮助我们实现一些很有意思的功能，比如图像处理，视频滤镜，高并发运算等。</p>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>在Metal架构中，<code>MTLDevice</code>协议定义了代表单个GPU的接口。与Metal交互所需的对象都来自于获取的<code>MTLDevice</code>。我们可以通过<code>MTLCreateSystemDefaultDevice</code>来获取所需要操作的GPU对象</p>
<h3 id="MLBuffer"><a href="#MLBuffer" class="headerlink" title="MLBuffer"></a>MLBuffer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A memory allocation for storing unformatted data that is accessible to the GPU.</div></pre></td></tr></table></figure>
<p>MLBuffer可以理解为一块连续的内存，它里面存储的数据，是没有格式、类型限制的，即可以存储任意类型的数据，是GPU可访问的专用容器，使图形渲染管道能够从中读取顶点数据。在Metal中用于存储顶点数据。</p>
<p>一般使用这个方法来创建MTLBuffer对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;MTLBuffer&gt;)newBufferWithBytes:(const void *)pointer </div><div class="line">									 length:(NSUInteger)length </div><div class="line">									 options:(MTLResourceOptions)options</div></pre></td></tr></table></figure>
<h3 id="MTLTexture"><a href="#MTLTexture" class="headerlink" title="MTLTexture"></a>MTLTexture</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A memory allocation for storing formatted image data that is accessible to the GPU.</div></pre></td></tr></table></figure>
<p>从开发者角度来看，texture 是一个名词，我们通常说的纹理，指的是一张二维的图片，把它像贴纸一样贴在视图上（采样），使得屏幕显示出我们想要的样子。</p>
<p>但在物理上， texture 指的是 GPU 显存中一段连续的空间，用来存放图像数据。</p>
<p>创建一个MTLTexture对象，需要用到MTLTextureDescriptor，即对纹理相关属性的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">MTLTextureDescriptor *textureDescriptor = [[MTLTextureDescriptor alloc] init];</div><div class="line"></div><div class="line">//  表明每个像素都有一个蓝色，绿色，红色和alpha通道，每个通道都是一个8位无符号标准化值</div><div class="line">textureDescriptor.pixelFormat = MTLPixelFormatBGRA8Unorm;</div><div class="line"></div><div class="line"> //设置纹理的像素尺寸</div><div class="line">textureDescriptor.width = image.width;</div><div class="line">textureDescriptor.height = image.height;</div><div class="line"></div><div class="line">// 通过 descriptor 创建纹理对象</div><div class="line">_texture = [_device newTextureWithDescriptor:textureDescriptor];</div><div class="line"></div><div class="line">// Calculate the number of bytes per row of our image.</div><div class="line">NSUInteger bytesPerRow = 4 * image.width;</div><div class="line"></div><div class="line">//MTLRegion结构用于识别纹理的特定区域。 此示例使用图像数据填充整个纹理; 因此，覆盖整个纹理的像素区域等于纹理的尺寸</div><div class="line">MTLRegion region = &#123;</div><div class="line">    &#123; 0, 0, 0 &#125;,                   // MTLOrigin</div><div class="line">    &#123;image.width, image.height, 1&#125; // MTLSize</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* 与存储多种自定义数据的MTLBuffer对象不同，MTLTexture对象专门用于存储格式化的图像数据。 尽管MTLTextureDescriptor对象指定足够的信息来分配纹理内存，但需要额外的信息来填充空纹理容器。 </div><div class="line">MTLTexture对象由replaceRegion：mipmapLevel：withBytes：bytesPerRow：方法填充图像数据。</div><div class="line">*/</div><div class="line">[_texture replaceRegion:region</div><div class="line">            mipmapLevel:0</div><div class="line">              withBytes:image.data.bytes</div><div class="line">            bytesPerRow:bytesPerRow];</div></pre></td></tr></table></figure>
<p>这里MTLRegion指的是texture中对应的图像区域，一般和图片大小保持一致。纹理坐标(0,0)默认在左下角，右上角为(1,1).</p>
<div align="center"><br><br><br><img src="https://docs-assets.developer.apple.com/published/a8fcc3ae6f/bd9ffd7d-01bf-45f2-8678-779fd47a7f9c.png" width="50%" height="50%"><br><br><br></div>


<h3 id="MTLLibrary"><a href="#MTLLibrary" class="headerlink" title="MTLLibrary"></a>MTLLibrary</h3><p>MTLLibrary负责加载定义在<code>.metal</code>文件中的着色器程序。通过MTLLibrary可以获得MTLFunction对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;MTLFunction&gt;) newFunctionWithName:(NSString *)functionName;</div></pre></td></tr></table></figure>
<h3 id="MTLCommandQueue，MTLCommandBuffer"><a href="#MTLCommandQueue，MTLCommandBuffer" class="headerlink" title="MTLCommandQueue，MTLCommandBuffer"></a>MTLCommandQueue，MTLCommandBuffer</h3><p>MTLCommandQueue由device创建，是整个app绘制的队列，而command buffer存放每次渲染的指令,即包含了每次渲染所需要的信息，直到指令被提交到GPU执行。Command queue用于创建和组织MTLCommandBuffer，其内部存在着多个command buffer，并且保证指令（command buffer）有序地发送到GPU。</p>
<p>command buffer是“一次性对象”，不支持重用。一旦command buffer被提交执行，唯一能做的是等待command buffer被调度或完成。</p>
<ul>
<li>Command buffers是从command queue里创建的</li>
<li>Command encoders将渲染指令command填充到command buffers</li>
<li>Command buffers将数据提交到GPU</li>
<li>GPU开始执行，呈现结果</li>
</ul>
<p><img src="https://docs-assets.developer.apple.com/published/6aedb538f8/b5ff0489-1079-441a-8a24-8f8c75dd2b1e.png" alt="MTLCommandBuffer"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">// Create a new command buffer for each render pass to the current drawable</div><div class="line">id&lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer];</div><div class="line">commandBuffer.label = @&quot;MyCommand&quot;;</div><div class="line">// Obtain a renderPassDescriptor generated from the view&apos;s drawable textures</div><div class="line">MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;</div><div class="line"></div><div class="line">if(renderPassDescriptor != nil)</div><div class="line">&#123;</div><div class="line">    // Create a render command encoder so we can render into something</div><div class="line">    id&lt;MTLRenderCommandEncoder&gt; renderEncoder =</div><div class="line">    [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];</div><div class="line">    renderEncoder.label = @&quot;MyRenderEncoder&quot;;</div><div class="line"></div><div class="line">    // 设置显示区域</div><div class="line">    [renderEncoder setViewport:(MTLViewport)&#123;0.0, 0.0, _viewportSize.x, _viewportSize.y, -1.0, 1.0 &#125;];</div><div class="line"></div><div class="line">    // 设置渲染管道，以保证顶点和片元两个shader会被调用</div><div class="line">    [renderEncoder setRenderPipelineState:_pipelineState];</div><div class="line"></div><div class="line">    // 设置顶点缓存</div><div class="line">    [renderEncoder setVertexBuffer:_vertices</div><div class="line">                            offset:0</div><div class="line">                          atIndex:AAPLVertexInputIndexVertices];</div><div class="line">    </div><div class="line">    [renderEncoder setVertexBytes:&amp;_viewportSize</div><div class="line">                           length:sizeof(_viewportSize)</div><div class="line">                          atIndex:AAPLVertexInputIndexViewportSize];</div><div class="line">    // 设置纹理</div><div class="line">    [renderEncoder setFragmentTexture:_texture</div><div class="line">                              atIndex:AAPLTextureIndexBaseColor];</div><div class="line">    // // 绘制</div><div class="line">    [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle</div><div class="line">                      vertexStart:0</div><div class="line">                      vertexCount:_numVertices];</div><div class="line">     // 结束</div><div class="line">    [renderEncoder endEncoding];</div><div class="line">    // 显示</div><div class="line">    [commandBuffer presentDrawable:view.currentDrawable];</div><div class="line">&#125;</div><div class="line">// Finalize rendering here &amp; push the command buffer to the GPU</div><div class="line">[commandBuffer commit];</div></pre></td></tr></table></figure>
<h3 id="MTLCommandEncoder"><a href="#MTLCommandEncoder" class="headerlink" title="MTLCommandEncoder"></a>MTLCommandEncoder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">An encoder that writes GPU commands into a command buffer</div></pre></td></tr></table></figure>
<p>编码器(Command Encoder)，将我们描述的高级指令，编码转换成GPU可以理解的低级指令(GPU commands)，写入command buffer中。</p>
<pre><code>Protocol | Description |  
------ | -------- | 
MTLRenderCommandEncoder | 用于图形渲染任务的编码器 |  
MTLComputeCommandEncoder | 用于计算任务的编码器 | 
MTLBlitCommandEncoder | 用于内存管理任务的编码器 |  
MTLParallelRenderCommandEncoder | 用于并行编码的多个图形渲染任务的编码器 | 
</code></pre><p>关于buffer，texture，Command Encoder,Command Queue之间的关系，借用官方的一张图，理得很清楚</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Cmd-Model-1_2x.png" alt="blockchain"></p>
<h3 id="Metal-Shader-Language"><a href="#Metal-Shader-Language" class="headerlink" title="Metal Shader Language"></a>Metal Shader Language</h3><p><a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf" target="_blank" rel="external">Metal Shader Language</a>我觉得是学Metal遇到的最大阻力了，并且只能看官方文档来学习，网上讲解的资料也很少，我也只是了解了个大概。</p>
<p>shader有三个基本函数：</p>
<p>顶点函数（vertex），对每个顶点进行处理，生成数据并输出到绘制管线，作为片元函数的输入；</p>
<p>片元函数（fragment），对光栅化后的每个像素点进行处理，生成数据并输出到绘制管线；</p>
<p>通用计算函数（kernel），是并行计算的函数，其返回值类型必须为void；</p>
<p>比如一个顶点函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    float4 clipSpacePosition [[position]]; // position的修饰符表示这个是顶点</div><div class="line">    </div><div class="line">    float2 textureCoordinate; // 纹理坐标，会做插值处理</div><div class="line">    </div><div class="line">&#125; RasterizerData;</div><div class="line"></div><div class="line">vertex RasterizerData // 返回给片元着色器的结构体</div><div class="line">vertexShader(uint vertexID [[ vertex_id ]], // vertex_id是顶点shader每次处理的index，用于定位当前的顶点</div><div class="line">             constant  ZJVertex*vertexArray [[ buffer(0) ]]) &#123; // buffer表明是缓存数据，0是索引</div><div class="line">    RasterizerData out;</div><div class="line">    out.clipSpacePosition = vertexArray[vertexID].position;</div><div class="line">    out.textureCoordinate = vertexArray[vertexID].textureCoordinate;</div><div class="line">    return out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的功能是把从 Metal API 绑定的数据从ZJVertex结构体封装成RasterizerData结构体并交给片元着色器。</p>
<p>比如一个片元函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fragment float4</div><div class="line">samplingShader(RasterizerData input [[stage_in]], // stage_in表示这个数据来自光栅化。（光栅化是顶点处理之后的步骤，业务层无法修改）</div><div class="line">               texture2d&lt;half&gt; colorTexture [[ texture(0) ]]) // texture表明是纹理数据，0是索引</div><div class="line">&#123;</div><div class="line">    constexpr sampler textureSampler (mag_filter::linear,</div><div class="line">                                      min_filter::linear); // sampler是采样器 决定如何对一个纹理进行采样操作。寻址模式，过滤模式，归一化坐标，比较函数</div><div class="line">    </div><div class="line">    half4 colorSample = colorTexture.sample(textureSampler, input.textureCoordinate); // 得到纹理对应位置的颜色</div><div class="line">    </div><div class="line">    float4 color = float4(colorSample);</div><div class="line">    return color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>片元着色器用于处理片元，它的返回值是这个片元的颜色，是一个四维向量。从输入的结构体中取出纹理坐标，利用采样器对纹理采样，拿到对应坐标的颜色值的RGB值，最后返回这个片元的颜色值。</p>
<p>对于没接触过图形学人来说，这些名词比较陌生，可能一时难于理解，主要是多看多练，写多了就理解它们的意义了。</p>
<p>接下会写一下Metal的渲染过程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/02/Metal学习(二)：渲染过程/" itemprop="url">
                  Metal学习(二)：渲染过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-02-02T16:54:54+08:00" content="2019-02-02">
              2019-02-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/02/02/Metal学习(二)：渲染过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/02/Metal学习(二)：渲染过程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2019/02/02/Metal学习(二)：渲染过程/" class="leancloud_visitors" data-flag-title="Metal学习(二)：渲染过程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="渲染管线Pipeline"><a href="#渲染管线Pipeline" class="headerlink" title="渲染管线Pipeline"></a>渲染管线Pipeline</h3><p>在图形处理中中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，所以我们大部分工作都是把3D坐标转变为适应屏幕的2D像素。3D坐标转为2D坐标的处理过程是由的图形渲染管线（Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p>
<p>图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>
<h3 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h3><p>以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。</p>
<a href="!--![Pipeline](https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/PipelineState_2x.png)--">!--![Pipeline](https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/PipelineState_2x.png)--</a>
<h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p>为了让系统知道我们的坐标和颜色值构成的到底是什么，需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一个点？一个三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元。</p>
<p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状。</p>
<h3 id="Vertex-function："><a href="#Vertex-function：" class="headerlink" title="Vertex function："></a>Vertex function：</h3><p>接收一组顶点数据数组，每个顶点执行一次运算，计算该顶点的坐标，颜色，光照，纹理坐标等，在渲染管线中每个顶点都是独立地被执行。每个图元由一个或者多个顶点组成，每个顶点定义一个点，一条边的一端或者三角形的一个角。每个顶点关联一些数据，这些数据包括顶点坐标，颜色，法向量以及纹理坐标等。所有这些顶点相关的信息就构成顶点数据。<br>Vertex function的返回值会被作为片元着色器函数的输入。</p>
<h3 id="Rasterization："><a href="#Rasterization：" class="headerlink" title="Rasterization："></a>Rasterization：</h3><p>在光栅化阶段，基本图元被转换为供片段着色器使用的片段。简单来说，就是将数据转化成可见像素的过程。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。在Metal中，这一步是用户控制不了的，由系统自动处理</p>
<h3 id="Fragment-function"><a href="#Fragment-function" class="headerlink" title="Fragment function"></a>Fragment function</h3><p>片段着色器的主要作用是计算一个像素的最终颜色<br>在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样(从纹理坐标获取纹理颜色叫做采样(Sampling))，以计算该片段的颜色值。从而调整成各种各样不同的效果图，这也是所有OpenGL或Metal高级效果产生的地方<br>片段着色器的返回值是一个四维向量，即是这个片元的颜色 RGBA 值</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/gfx-pipeline_2x.png" alt="Pipeline"></p>
<p>渲染过程：<br>读取顶点数据——执行顶点着色器——组装图元——光栅化图元——执行片元着色器——写入帧缓冲区——显示到屏幕上。</p>
<p>下面就以实际代码来看一下,以<a href="https://developer.apple.com/documentation/metal/basic_texturing?language=objc" target="_blank" rel="external">官方Demo</a>为例：</p>
<p>初始化顶点数据，然后根据顶点数据来计算顶点数量及MTLBuffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Set up a simple MTLBuffer with our vertices which include texture coordinates</div><div class="line">static const AAPLVertex quadVertices[] =</div><div class="line">&#123;</div><div class="line">    // Pixel positions, Texture coordinates</div><div class="line">    &#123; &#123;  250,  -250 &#125;,  &#123; 1.f, 0.f &#125; &#125;,</div><div class="line">    &#123; &#123; -250,  -250 &#125;,  &#123; 0.f, 0.f &#125; &#125;,</div><div class="line">    &#123; &#123; -250,   250 &#125;,  &#123; 0.f, 1.f &#125; &#125;,</div><div class="line"></div><div class="line">    &#123; &#123;  250,  -250 &#125;,  &#123; 1.f, 0.f &#125; &#125;,</div><div class="line">    &#123; &#123; -250,   250 &#125;,  &#123; 0.f, 1.f &#125; &#125;,</div><div class="line">    &#123; &#123;  250,   250 &#125;,  &#123; 1.f, 1.f &#125; &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// Create our vertex buffer, and initialize it with our quadVertices array</div><div class="line">_vertices = [_device newBufferWithBytes:quadVertices</div><div class="line">                                 length:sizeof(quadVertices)</div><div class="line">                                options:MTLResourceStorageModeShared];</div><div class="line"></div><div class="line"> // 通过将字节长度除以每个顶点的大小来计算顶点的数量</div><div class="line">_numVertices = sizeof(quadVertices) / sizeof(AAPLVertex);</div></pre></td></tr></table></figure>
<p>然后获得图片数据，根据图片数据来设置MTLTexture</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">NSURL *imageFileLocation = [[NSBundle mainBundle] URLForResource:@&quot;Image&quot;</div><div class="line">                                                   withExtension:@&quot;tga&quot;];</div><div class="line">AAPLImage * image = [[AAPLImage alloc] initWithTGAFileAtLocation:imageFileLocation];</div><div class="line">if(!image)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;Failed to create the image from %@&quot;, imageFileLocation.absoluteString);</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line">MTLTextureDescriptor *textureDescriptor = [[MTLTextureDescriptor alloc] init];</div><div class="line"></div><div class="line">//  表明每个像素都有一个蓝色，绿色，红色和alpha通道，每个通道都是一个8位无符号标准化值</div><div class="line">textureDescriptor.pixelFormat = MTLPixelFormatBGRA8Unorm;</div><div class="line"> //设置纹理的像素尺寸</div><div class="line">textureDescriptor.width = image.width;</div><div class="line">textureDescriptor.height = image.height;</div><div class="line">// 通过 descriptor 创建纹理对象</div><div class="line">_texture = [_device newTextureWithDescriptor:textureDescriptor];</div><div class="line">// Calculate the number of bytes per row of our image.</div><div class="line">NSUInteger bytesPerRow = 4 * image.width;</div><div class="line"></div><div class="line">//MTLRegion结构用于识别纹理的特定区域。 此示例使用图像数据填充整个纹理; 因此，覆盖整个纹理的像素区域等于纹理的尺寸</div><div class="line">MTLRegion region = &#123;</div><div class="line">    &#123; 0, 0, 0 &#125;,                   // MTLOrigin</div><div class="line">    &#123;image.width, image.height, 1&#125; // MTLSize</div><div class="line">&#125;;</div><div class="line">// 与存储多种自定义数据的MTLBuffer对象不同，MTLTexture对象专门用于存储格式化的图像数据。 尽管MTLTextureDescriptor对象指定足够的信息来分配纹理内存，但需要额外的信息来填充空纹理容器。 MTLTexture对象由replaceRegion：mipmapLevel：withBytes：bytesPerRow：方法填充图像数据。</div><div class="line">[_texture replaceRegion:region</div><div class="line">            mipmapLevel:0</div><div class="line">              withBytes:image.data.bytes</div><div class="line">            bytesPerRow:bytesPerRow];</div></pre></td></tr></table></figure>
<p>因为demo中给的是tga文件格式的图片，所以专门封装了一个类<code>AAPLImage</code>来处理图片。当然，我们也可以使用一下代码来获得texture</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">CGImageRef spriteImage = image.CGImage;</div><div class="line">// 1 读取图片的大小</div><div class="line">size_t width = CGImageGetWidth(spriteImage);</div><div class="line">size_t height = CGImageGetHeight(spriteImage);</div><div class="line">Byte * spriteData = (Byte *) calloc(width * height * 4, sizeof(Byte)); //rgba共4个byte</div><div class="line">CGContextRef spriteContext = CGBitmapContextCreate(spriteData, width, height, 8, width*4,</div><div class="line">                                                   CGImageGetColorSpace(spriteImage), kCGImageAlphaPremultipliedLast);</div><div class="line">    </div><div class="line">// 2 在CGContextRef上绘图</div><div class="line">CGContextDrawImage(spriteContext, CGRectMake(0, 0, width, height), spriteImage);</div><div class="line">CGContextRelease(spriteContext);</div><div class="line">    </div><div class="line">MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm</div><div class="line">                                                                                             width:width</div><div class="line">                                                                                            height:height</div><div class="line">                                                                                         mipmapped:NO];</div><div class="line">textureDescriptor.usage = MTLTextureUsageShaderRead;</div><div class="line">id&lt;MTLTexture&gt; texture = [context.device newTextureWithDescriptor:textureDescriptor];</div><div class="line">    </div><div class="line">    </div><div class="line">MTLRegion region = &#123;&#123; 0, 0, 0 &#125;, &#123;image.size.width, image.size.height, 1&#125;&#125;; // 纹理上传的范围</div><div class="line">[texture replaceRegion:region mipmapLevel:0 withBytes:spriteData bytesPerRow:4 * image.size.width];</div><div class="line">free(spriteData);</div></pre></td></tr></table></figure>
<p>接下来就是初始化MTLRenderPipelineState及MTLCommandQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// Load all the shader files with a metal file extension in the project</div><div class="line">id&lt;MTLLibrary&gt; defaultLibrary = [_device newDefaultLibrary];</div><div class="line"></div><div class="line">// Load the vertex function from the library</div><div class="line">id&lt;MTLFunction&gt; vertexFunction = [defaultLibrary newFunctionWithName:@&quot;vertexShader&quot;];</div><div class="line"></div><div class="line">// Load the fragment function from the library</div><div class="line">id&lt;MTLFunction&gt; fragmentFunction = [defaultLibrary newFunctionWithName:@&quot;samplingShader&quot;];</div><div class="line"></div><div class="line">// Set up a descriptor for creating a pipeline state object</div><div class="line">MTLRenderPipelineDescriptor *pipelineStateDescriptor = [[MTLRenderPipelineDescriptor alloc] init];</div><div class="line">pipelineStateDescriptor.label = @&quot;Texturing Pipeline&quot;;</div><div class="line">pipelineStateDescriptor.vertexFunction = vertexFunction;</div><div class="line">pipelineStateDescriptor.fragmentFunction = fragmentFunction;</div><div class="line">pipelineStateDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat;</div><div class="line"></div><div class="line">NSError *error = NULL;</div><div class="line">_pipelineState = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor</div><div class="line">                                                         error:&amp;error];</div><div class="line"></div><div class="line">// Create the command queue</div><div class="line">_commandQueue = [_device newCommandQueue];</div></pre></td></tr></table></figure>
<p>最后就是绘制视图调用的<code>- (void)drawInMTKView:(nonnull MTKView *)view</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)drawInMTKView:(nonnull MTKView *)view</div><div class="line">&#123;</div><div class="line">    id&lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer];</div><div class="line">    commandBuffer.label = @&quot;MyCommand&quot;;</div><div class="line">    MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;</div><div class="line"></div><div class="line">    if(renderPassDescriptor != nil)</div><div class="line">    &#123;</div><div class="line">        // Create a render command encoder so we can render into something</div><div class="line">        id&lt;MTLRenderCommandEncoder&gt; renderEncoder =</div><div class="line">        [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];</div><div class="line">        renderEncoder.label = @&quot;MyRenderEncoder&quot;;</div><div class="line">        // 设置显示区域</div><div class="line">        [renderEncoder setViewport:(MTLViewport)&#123;0.0, 0.0, _viewportSize.x, _viewportSize.y, -1.0, 1.0 &#125;];</div><div class="line">        // 设置渲染管道，以保证顶点和片元两个shader会被调用</div><div class="line">        [renderEncoder setRenderPipelineState:_pipelineState];</div><div class="line">        // 设置顶点缓存</div><div class="line">        [renderEncoder setVertexBuffer:_vertices</div><div class="line">                                offset:0</div><div class="line">                              atIndex:AAPLVertexInputIndexVertices];</div><div class="line">        [renderEncoder setVertexBytes:&amp;_viewportSize</div><div class="line">                               length:sizeof(_viewportSize)</div><div class="line">                              atIndex:AAPLVertexInputIndexViewportSize];</div><div class="line">        // 设置纹理</div><div class="line">        [renderEncoder setFragmentTexture:_texture</div><div class="line">                                  atIndex:AAPLTextureIndexBaseColor];</div><div class="line">        // // 绘制</div><div class="line">        [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle</div><div class="line">                          vertexStart:0</div><div class="line">                          vertexCount:_numVertices];</div><div class="line">         // 结束</div><div class="line">        [renderEncoder endEncoding];</div><div class="line">        // 显示</div><div class="line">        [commandBuffer presentDrawable:view.currentDrawable];</div><div class="line">    &#125;   </div><div class="line">    // Finalize rendering here &amp; push the command buffer to the GPU</div><div class="line">    [commandBuffer commit];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个环节中:</p>
<ul>
<li>第一步是获取command buffer(命令缓冲区)。 所有进入GPU的工作将被排入此缓冲区。 我们需要前一阶段的command queue来创建一个command buffer(命令缓冲区)。</li>
<li>第二步是设置render pass(渲染通道)。 渲染通道描述符告诉Metal渲染图像时要执行的操作。 配置它需要我们指定我们渲染的颜色纹理。</li>
<li>第三步是实际drawing(绘制)。 我们指定存储顶点的缓冲区，然后指定我们需要绘制的基元。 第四步也是最后一步是commit the command buffer(提交命令缓冲区)给GPU。 调用commit时，command buffer会被编码，发送到命令队列的末尾，并在GPU运行时执行。</li>
</ul>
<p>最后附一张非常详细的流程图：</p>
<p><img src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/metal_xuanranguocheng.jpg" alt="xuanran"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/" itemprop="url">
                  MLeaksFinder与FBRetainCycleDetector小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-12-15T19:54:38+08:00" content="2018-12-15">
              2018-12-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/12/15/MLeaksFinder与FBRetainCycleDetector小结/" class="leancloud_visitors" data-flag-title="MLeaksFinder与FBRetainCycleDetector小结">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MLeaksFinder"><a href="#MLeaksFinder" class="headerlink" title="MLeaksFinder"></a>MLeaksFinder</h3><p>建议先仔细阅读<a href="http://wereadteam.github.io/2016/07/20/MLeaksFinder2/" target="_blank" rel="external">官方介绍</a>，很多原理性的东西原文档讲的很清楚，这里主要以几个问题来分析一下实现过程。<br>假如给你一个原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 </div><div class="line">UIViewController，它的 view，view 的 subviews 等等是否还存在</div></pre></td></tr></table></figure>
<p>你能想到怎么用代码实现这个功能呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (BOOL)willDealloc &#123;</div><div class="line">    __weak id weakSelf = self;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        [weakSelf assertNotDealloc];</div><div class="line">    &#125;);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line">- (void)assertNotDealloc &#123;</div><div class="line">     NSAssert(NO, @“”);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如何判断一个ViewController被pop或dismiss"><a href="#如何判断一个ViewController被pop或dismiss" class="headerlink" title="如何判断一个ViewController被pop或dismiss"></a>如何判断一个ViewController被pop或dismiss</h4><p>MLeaksFinder通过Runtime hook了<code>viewDidDisappear</code> 和 <code>viewWillAppear</code>方法，但是一个界面消失时，可能是被pop或dismiss了，也有可能是push了一个新的界面，push时当前页面也会调用<code>viewDidDisappear</code>方法。我们要做的是只有被pop或dismiss时，才去监测是否内存泄漏了。MLeaksFinder做法是这样的：</p>
<p>当<code>viewWillAppear</code>被调用时，通过<code>objc_setAssociatedObject</code>方法对ViewController添加一个标记属性值，当ViewController被pop时，获得这个ViewController并改变这个属性值。然后在<code>viewDidDisappear</code>判断一下这个属性值是否被改变了，假如改变了，则是被pop或dismiss了。见代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)swizzled_viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    [self swizzled_viewDidDisappear:animated];</div><div class="line">    </div><div class="line">    BOOL value = [objc_getAssociatedObject(self, kHasBeenPoppedKey) boolValue] ;</div><div class="line">    if (value) &#123;</div><div class="line">        [self willDealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)swizzled_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self swizzled_viewWillAppear:animated];</div><div class="line">    objc_setAssociatedObject(self, kHasBeenPoppedKey, @(NO), OBJC_ASSOCIATION_RETAIN);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">UIViewController *poppedViewController = [self swizzled_popViewControllerAnimated:animated];</div><div class="line"></div><div class="line">extern const void *const kHasBeenPoppedKey;</div><div class="line">    objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(YES), OBJC_ASSOCIATION_RETAIN);</div><div class="line">    </div><div class="line">    return poppedViewController;</div></pre></td></tr></table></figure>
<h4 id="如何构建视图层级信息"><a href="#如何构建视图层级信息" class="headerlink" title="如何构建视图层级信息"></a>如何构建视图层级信息</h4><p>假如一个ViewController的一个view没有释放，找出来这个view所属的层级。</p>
<p>首先先检测ViewController，然后将ViewController的className记录下来，然后遍历ViewController.view的时候，将ViewController的className的赋值给view，以及对ViewController.view.subviews循环遍历,添加弱引用指针前时，都通过赋值传递的方法，先将视图信息记录下来，赋值给这个对象。<code>objc_setAssociatedObject</code>方法将当前遍历的类名string添加到Array里面。假如发生了内存泄漏，通过<code>objc_getAssociatedObject</code>方法获得Array，即记录的视图层级信息.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)willReleaseChildren:(NSArray *)children &#123;</div><div class="line">    </div><div class="line">    NSArray *viewStack = [self viewStack];</div><div class="line">    NSSet *parentPtrs = [self parentPtrs];</div><div class="line">    // 遍历时，添加弱引用指针前，现将之前的视图信息赋值给将要检测的对象</div><div class="line">    for (id child in children) &#123;</div><div class="line">        NSString *className = NSStringFromClass([child class]);</div><div class="line">        [child setViewStack:[viewStack arrayByAddingObject:className]];</div><div class="line">        [child setParentPtrs:[parentPtrs setByAddingObject:@((uintptr_t)child)]];</div><div class="line">        [child willDealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 赋值视图层级信息</div><div class="line">- (NSArray *)viewStack &#123;</div><div class="line">    NSArray *viewStack = objc_getAssociatedObject(self, kViewStackKey);</div><div class="line">    if (viewStack) &#123;</div><div class="line">        return viewStack;</div><div class="line">    &#125;</div><div class="line">    NSString *className = NSStringFromClass([self class]);</div><div class="line">    return @[ className ];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获得视图层级信息</div><div class="line">- (void)setViewStack:(NSArray *)viewStack &#123;</div><div class="line">    NSLog(@&quot;setViewStack -- %@&quot;,NSStringFromClass([self class]));</div><div class="line">    objc_setAssociatedObject(self, kViewStackKey, viewStack, OBJC_ASSOCIATION_RETAIN);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如何判断属于释放不及时的情况"><a href="#如何判断属于释放不及时的情况" class="headerlink" title="如何判断属于释放不及时的情况"></a>如何判断属于释放不及时的情况</h4><p>原文中是这么描述的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，</div><div class="line">对于同一个类不断地报 Object Deallocated 和 Memory Leak。这种情况属于释放不及时的情况。</div></pre></td></tr></table></figure>
<p>意思就是该释放的时候没释放，但是过了一段时间，或触发了某个场景又释放了，这不算严格上的内存泄漏，属于释放不及时的情况，比如这种场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)push &#123;</div><div class="line">    SecViewController *controller = [[SecViewController alloc] init];</div><div class="line">    self.secController = controller;</div><div class="line">    [self.navigationController pushViewController: controller animated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从当前界面push到SecViewController界面，但是当前界面持有SecViewController对象的强引用，所以SecViewController pop时，SecViewController对象时不会释放的，只有当前界面释放了，SecViewController对象才释放。</p>
<p>检测这种情况的方法，也是使用了<code>objc_setAssociatedObject</code>方法。当一个对象发生内存泄漏时，使用<code>objc_setAssociatedObject</code>为该对象添加一个标记对象MLeakedObjectProxy，MLeakedObjectProxy持有这个泄漏对象的弱引用，这样当泄漏的对象释放时，会清除自身关联的AssociatedObject，关联对象MLeakedObjectProxy此时释放，所以关联对象释放的时机即是内存泄漏对象delloc的时机，这个时候会弹一个Object Deallocated的alertView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+ (void)addLeakedObject:(id)object &#123;</div><div class="line">    NSAssert([NSThread isMainThread], @&quot;Must be in main thread.&quot;);</div><div class="line">    </div><div class="line">    MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] init];</div><div class="line">    proxy.object = object;</div><div class="line">    proxy.objectPtr = @((uintptr_t)object);</div><div class="line">    proxy.viewStack = [object viewStack];</div><div class="line">    static const void *const kLeakedObjectProxyKey = &amp;kLeakedObjectProxyKey;</div><div class="line">    objc_setAssociatedObject(object, kLeakedObjectProxyKey, proxy, OBJC_ASSOCIATION_RETAIN);</div><div class="line">    </div><div class="line">    [leakedObjectPtrs addObject:proxy.objectPtr];</div><div class="line">    </div><div class="line">    [MLeaksMessenger alertWithTitle:@&quot;Memory Leak&quot;</div><div class="line">                            message:[NSString stringWithFormat:@&quot;%@&quot;, proxy.viewStack]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSNumber *objectPtr = _objectPtr;</div><div class="line">    NSArray *viewStack = _viewStack;</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [leakedObjectPtrs removeObject:objectPtr];</div><div class="line">        [MLeaksMessenger alertWithTitle:@&quot;Object Deallocated&quot;</div><div class="line">                                message:[NSString stringWithFormat:@&quot;%@&quot;, viewStack]];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="FBRetainCycleDetector"><a href="#FBRetainCycleDetector" class="headerlink" title="FBRetainCycleDetector"></a>FBRetainCycleDetector</h3><p>MLeaksFinder的作用是找出来没有释放的对象，但是要找出哪个对象强引用着这个未释放的对象、哪几个对象造成了循环引用，还要靠<a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="external">FBRetainCycleDetector</a>。它的原理是获得要检查对象的所有强引用对象，按照深入优先搜索的方法遍历所有强引用对象，假如在遍历的过程中又遍历到了自己，表明发生了循环引用，然后输出日志。</p>
<p><img src="http://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/MLeaksFinder_Cycle.jpg" alt="循环引用"></p>
<p>如上图，搜索过程中 object1 -&gt; object4 -&gt; object6 -&gt; object1 ，造成了循环引用，控制台会输出这些信息。</p>
<p>FB中关于寻找一个对象的所有强引用属性，比如上图中的object1,找出它的所有strong类型的属性：object2,object3,object4以及关联对象，这个过程值得我们去深究，复习下Runtime及Block底层知识。</p>
<p>FBRetainCycleDetector中将需要检查的类型分成了三类，分别是NSObject类型，NSTimer类型，Block类型，对每种类型分别包装成了FBObjectiveCObject，FBObjectiveCNSCFTimer，FBObjectiveCBlock。<br>判断一个对象是否是NSTimer类型非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object_getClass(object) isSubclassOfClass:[NSTimer class]]</div></pre></td></tr></table></figure>
<p>判断一个对象是否是Block的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static Class _BlockClass() &#123;</div><div class="line">  static dispatch_once_t onceToken;</div><div class="line">  static Class blockClass;</div><div class="line">  dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">      void (^testBlock)(void) = [^&#123;&#125; copy];</div><div class="line">    blockClass = [testBlock class];</div><div class="line">    while(class_getSuperclass(blockClass) &amp;&amp; class_getSuperclass(blockClass) != [NSObject class]) &#123;</div><div class="line">      blockClass = class_getSuperclass(blockClass);</div><div class="line">    &#125;</div><div class="line">    [testBlock release];</div><div class="line">  &#125;);</div><div class="line">  return blockClass;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BOOL FBObjectIsBlock(void *object) &#123;</div><div class="line">  Class blockClass = _BlockClass();</div><div class="line">  Class candidate = object_getClass((__bridge id)object);</div><div class="line">  return [candidate isSubclassOfClass:blockClass];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取通过关联对象方式添加的属性"><a href="#获取通过关联对象方式添加的属性" class="headerlink" title="获取通过关联对象方式添加的属性"></a>获取通过关联对象方式添加的属性</h4><p>FBObjectiveCObject，FBObjectiveCNSCFTimer，FBObjectiveCBlock这三个类有一个共同父类FBObjectiveCGraphElement，共用父类的方法<code>- (NSSet *)allRetainedObjects</code>，这个方法用来获得通过<code>objc_setAssociatedObject</code>方法添加的属性。</p>
<p>FBRetainCycleDetector 使用了 <a href="https://github.com/facebook/fishhook" target="_blank" rel="external">fishhook</a> hook了 <code>objc_setAssociatedObject</code> 和 <code>objc_removeAssociatedObjects</code> 方法，在FBAssociationManager类里维护了一个存储关联对象信息的Map, 这样的话通过关联对象的方式添加属性，就能被捕捉到，然后操作维护的Map。这样就能获得一个对象，通过关联对象方式添加强引用属性的所有信息了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface FBAssociationManager : NSObject</div><div class="line"></div><div class="line">+ (void)hook;</div><div class="line"></div><div class="line">+ (void)unhook;</div><div class="line"></div><div class="line">+ (nullable NSArray *)associationsForObject:(nullable id)object;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="对于NSObject类型"><a href="#对于NSObject类型" class="headerlink" title="对于NSObject类型"></a>对于NSObject类型</h4><p>对于通过@property方式添加的属性，在Runtime层面来说，内部都会有一个IvarList存放着实例变量列表。有的人可能会想，不是有api：<code>class_getIvarLayout</code>、<code>class_getWeakIvarLayout</code>可以直接获得strong类型的实例变量和weak类型的实例变量吗？其实不然，ivarLayout和weakIvarLayout存放的只是强ivar和弱ivar的存储规则，并不是真正的实例变量，具体可以看<a href="https://www.jianshu.com/p/6b218d12caae" target="_blank" rel="external">这篇文章</a>。</p>
<p>但是我们可以根据ivarLayout这个存储规则找出强ivar的所在的index,再通过<code>class_copyIvarList</code>获取所有的ivar, 这样就找出了这个对象的强ivar。有了这个强ivar后再通过<code>object_getIvar</code>获得ivar对应的值，从而达成了目的。核心代码主要在FBClassStrongLayout类里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">static NSArray&lt;id&lt;FBObjectReference&gt;&gt; *FBGetStrongReferencesForClass(Class aCls) &#123;</div><div class="line">//    class的引用所有的引用(iVarList)，包括强引用和弱引用</div><div class="line">  NSArray&lt;id&lt;FBObjectReference&gt;&gt; *ivars = [FBGetClassReferences(aCls) filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) &#123;</div><div class="line">    if ([evaluatedObject isKindOfClass:[FBIvarReference class]]) &#123;</div><div class="line">      FBIvarReference *wrapper = evaluatedObject;</div><div class="line">      return wrapper.type != FBUnknownType;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">  &#125;]];</div><div class="line"></div><div class="line">    // 获取属性为strong或copy在内存中的存储规则，结果可能为nil</div><div class="line">  const uint8_t *fullLayout = class_getIvarLayout(aCls);</div><div class="line">  if (!fullLayout) &#123;</div><div class="line">    return nil;</div><div class="line">  &#125;</div><div class="line">    NSLog(@&quot;%@ fullLayout:\n%s&quot;,NSStringFromClass(aCls),fullLayout);</div><div class="line">//获取ivar的最小index</div><div class="line">  NSUInteger minimumIndex = FBGetMinimumIvarIndex(aCls);</div><div class="line">//获取强引用的index区间。 https://www.jianshu.com/p/89ac27684693</div><div class="line">  NSIndexSet *parsedLayout = FBGetLayoutAsIndexesForDescription(minimumIndex, fullLayout);</div><div class="line"></div><div class="line">  NSArray&lt;id&lt;FBObjectReference&gt;&gt; *filteredIvars =</div><div class="line">  [ivars filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id&lt;FBObjectReference&gt; evaluatedObject,</div><div class="line">                                                                           NSDictionary *bindings) &#123;</div><div class="line">    return [parsedLayout containsIndex:[evaluatedObject indexInIvarLayout]];</div><div class="line">  &#125;]];</div><div class="line"></div><div class="line">  return filteredIvars;</div><div class="line">&#125;</div><div class="line">NSArray&lt;id&lt;FBObjectReference&gt;&gt; *FBGetObjectStrongReferences(id obj,</div><div class="line">                                                            NSMutableDictionary&lt;Class, NSArray&lt;id&lt;FBObjectReference&gt;&gt; *&gt; *layoutCache) &#123;</div><div class="line">  NSMutableArray&lt;id&lt;FBObjectReference&gt;&gt; *array = [NSMutableArray new];</div><div class="line"></div><div class="line">  __unsafe_unretained Class previousClass = nil;</div><div class="line">  __unsafe_unretained Class currentClass = object_getClass(obj);</div><div class="line"></div><div class="line">  while (previousClass != currentClass) &#123;</div><div class="line">    NSArray&lt;id&lt;FBObjectReference&gt;&gt; *ivars;</div><div class="line">    </div><div class="line">    if (layoutCache &amp;&amp; currentClass) &#123;</div><div class="line">      ivars = layoutCache[currentClass];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!ivars) &#123;</div><div class="line">      ivars = FBGetStrongReferencesForClass(currentClass);</div><div class="line">      if (layoutCache &amp;&amp; currentClass) &#123;</div><div class="line">        layoutCache[currentClass] = ivars;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    [array addObjectsFromArray:ivars];</div><div class="line"></div><div class="line">    previousClass = currentClass;</div><div class="line">    currentClass = class_getSuperclass(currentClass);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return [array copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 简略流程图为：</p>
<p><img src="http://ww1.sinaimg.cn/mw690/006OKvcNly1fy5f0i5pfzj30q80j0dgu.jpg" alt="循环引用"></p>
<h4 id="对于Block类型"><a href="#对于Block类型" class="headerlink" title="对于Block类型"></a>对于Block类型</h4><p>首先要了解Block的结构是什么，假如引用了对象，这部分的对象存在哪里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct BlockDescriptor &#123;</div><div class="line">  unsigned long int reserved;                // NULL</div><div class="line">  unsigned long int size;</div><div class="line">  // optional helper functions</div><div class="line">  void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25)</div><div class="line">  void (*dispose_helper)(void *src);         // IFF (1&lt;&lt;25)</div><div class="line">  const char *signature;                     // IFF (1&lt;&lt;30)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct BlockLiteral &#123;</div><div class="line">  void *isa;  // initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</div><div class="line">  int flags;</div><div class="line">  int reserved;</div><div class="line">  void (*invoke)(void *, ...);</div><div class="line">  struct BlockDescriptor *descriptor;</div><div class="line">  // imported variables</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>FB中将传入的Blok强转成了BlockLiteral类型的结构体，对于BlockLiteral这个结构体进行操作。</p>
<p>其实最重要的理解dispose_helper这个函数的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispose_helper 向所有捕获的变量发送release消息，对弱引用不会做任何的处理</div></pre></td></tr></table></figure>
<p>我们可以先存一份<code>dispose_helper</code>调用之前的数据，然后调用<code>dispose_helper</code>函数，对比调用后的数据，就能得出所强引用的函数。<br>FBBlockStrongRelationDetector 为<code>dispose_helper</code>的消息接收类，复写了release函数。它的实例在接受release消息时，并不会真正的释放，只会将标记_strong 为YES，<br>只有真正执行<code>trueRelease</code> 的时候才会向对象发送 release 消息。更多详细的信息见<a href="https://github.com/draveness/analyze/blob/master/contents/FBRetainCycleDetector/iOS%20中的%20block%20是如何持有对象的.md" target="_blank" rel="external">这篇文章</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (oneway void)release</div><div class="line">&#123;</div><div class="line">  _strong = YES;</div><div class="line">&#125;</div><div class="line">- (oneway void)trueRelease</div><div class="line">&#123;</div><div class="line">  [super release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_GetBlockStrongLayout</code>核心代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//    获得dispose_helper函数</div><div class="line">  void (*dispose_helper)(void *src) = blockLiteral-&gt;descriptor-&gt;dispose_helper;</div><div class="line">  const size_t ptrSize = sizeof(void *);</div><div class="line"></div><div class="line">  // Figure out the number of pointers it takes to fill out the object, rounding up.</div><div class="line">//    获取 block 持有的指针的数量</div><div class="line">  const size_t elements = (blockLiteral-&gt;descriptor-&gt;size + ptrSize - 1) / ptrSize;</div><div class="line"></div><div class="line">  // Create a fake object of the appropriate length.</div><div class="line">  void *obj[elements];</div><div class="line">  void *detectors[elements];</div><div class="line"></div><div class="line">  for (size_t i = 0; i &lt; elements; ++i) &#123;</div><div class="line">    FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector new];</div><div class="line">    obj[i] = detectors[i] = detector;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @autoreleasepool &#123;</div><div class="line">    dispose_helper(obj);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Run through the release detectors and add each one that got released to the object&apos;s</div><div class="line">  // strong ivar layout.</div><div class="line">  NSMutableIndexSet *layout = [NSMutableIndexSet indexSet];</div><div class="line"></div><div class="line">  for (size_t i = 0; i &lt; elements; ++i) &#123;</div><div class="line">    FBBlockStrongRelationDetector *detector = (FBBlockStrongRelationDetector *)(detectors[i]);</div><div class="line">    if (detector.isStrong) &#123;</div><div class="line">      [layout addIndex:i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Destroy detectors</div><div class="line">    [detector trueRelease];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return layout;</div></pre></td></tr></table></figure>
<h4 id="对于NSTimer类型"><a href="#对于NSTimer类型" class="headerlink" title="对于NSTimer类型"></a>对于NSTimer类型</h4><p>通过<code>CFRunLoopTimerGetContext</code>获得timer的详细信息，包括target</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_FBNSCFTimerInfoStruct infoStruct = *(_FBNSCFTimerInfoStruct *)(context.info);</div><div class="line"></div><div class="line">typedef struct &#123;</div><div class="line">  long _unknown; // This is always 1</div><div class="line">  id target;</div><div class="line">  SEL selector;</div><div class="line">  NSDictionary *userInfo;</div><div class="line">&#125; _FBNSCFTimerInfoStruct;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>阅读优秀的开源框架能够学习很深层次的知识点，以及如何正确使用这些知识。比如MLeaksFinder中大量使用了<code>objc_setAssociatedObject</code>来实现想要的功能。再比如即使我们知道了Block的数据结构，那么能用这些知识来实现什么功能呢，FBRetainCycleDetector中使用了Block中的<code>dispose_helper</code>函数来筛选引用到的对象，使用了fishhook来hook Runtime层面的api。你知道了消息转发的过程和原理，假如你去阅读<a href="https://github.com/steipete/Aspects" target="_blank" rel="external">Aspects</a>源码的话，就会更加了解如何去用正确使用消息转发，并且惊叹消息转发用处原来这么强大。优秀的人无处不在，所以不仅仅是自己研究，也要多汲取别人的思路想法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/02/平凡的世界/" itemprop="url">
                  《平凡的世界》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-10-02T09:54:10+08:00" content="2018-10-02">
              2018-10-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/读书与感悟/" itemprop="url" rel="index">
                    <span itemprop="name">读书与感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/02/平凡的世界/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/02/平凡的世界/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/10/02/平凡的世界/" class="leancloud_visitors" data-flag-title="《平凡的世界》">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>《平凡的世界》记录的是一九七四年至一九八四年，十年间以乡下的一个小村庄双水村的变化，反映了中国快速发展的面貌。我大部分都是在晚上读这本小说，花了三个多月的时间读完了这本书，共三部。书中一些情节，人物的刻画，故事的发展，以及作者对人生的思考，都给了我很大的帮助，以至于现在有一种想读第二遍的冲动。所以，我觉得我有必要写一些东西记录下我读后的感悟。</p>
<h3 id="关于爱情与婚姻"><a href="#关于爱情与婚姻" class="headerlink" title="关于爱情与婚姻"></a>关于爱情与婚姻</h3><p>书中关于爱情的情节，有两条线，一条是孙少安与田润叶，一条是孙少平与田晓霞。他们双方都深爱着对方，但最后都没能走到一起。前者是因为孙少安是社会最底层的农民，觉得自己配不上干部家庭及文化高的田润叶，后者是因为田晓霞因为在洪水中救人而牺牲了。哎，很可惜，特别是孙少平与田晓霞，它们俩一开始就互相帮助对方，本以为它们会走到最后，没想到…</p>
<p>《阿甘正传》里有一句台词：人生就像一盒巧克力，你永远无法知道下一颗是什么滋味。在青涩的年纪，就像爱情一样，你也无法知道最后陪伴你一生的那个人是谁，人生总是充满了插曲。两个人在一起爱情和婚姻是不同的，爱情的可以轰轰烈烈，但婚姻平平淡淡最好。每个人都会有青涩的初恋，刻骨的爱情，但爱情的尽头呢？会是婚姻吗？在过程中会有各种阻隔让你们分开，你们或许让对方尝到了爱情的滋味，但未必给的了婚姻的幸福，一生的呵护。</p>
<h3 id="对于苦难"><a href="#对于苦难" class="headerlink" title="对于苦难"></a>对于苦难</h3><p>记忆最深刻的就是孙少平不想永远呆在小山村，想出去闯荡，于是一个人去煤矿打工，受了很多苦。书中是这样描述这一经历的，原文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">有文化，但是没有幸运的进入大学或参加工作，因此似乎没有充分的条件直接参与到目前社会发展的主潮之</div><div class="line">中，而另一方面，他们往往又不甘心，把自己局限在狭小生活的天地里。因此，他们带着一种悲壮的激情，在</div><div class="line">一条最为艰难的道路上进行人生的搏斗。他们顾不得高谈论阔，或愤世嫉俗的忧患人类的命运。他们首先得改</div><div class="line">变自己的生存条件，同时也不放弃最主要的精神追求。他们既不鄙视普通人的世俗生活，但又竭力使自己对生</div><div class="line">活的认识达到更深的层次。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">是的，他是在社会最底层挣扎，为了几个钱而受尽折磨，但他已不仅仅将此看做是谋生活命——职业的高低贵</div><div class="line">贱，不能说明一个人的价值。恰恰相反，他现在倒很“热爱”自己的苦难。通过这一段血火般的洗礼，他相信，</div><div class="line">自己历经千辛万苦而酿造出的生活之蜜，肯定比轻而易举拿来的更有滋味。</div></pre></td></tr></table></figure>
<p>苦难是对自己的磨难，在磨难中，在压力中你才能更加快速的成长。苦难过后，你再看看自己曾经走过的路，你会感谢他们，正是因为他们，你才有了许多人生的感悟，人生的道理，而这些是别人不能给你的，只能自己去经历，自己去体会。</p>
<p>很遗憾，直到书的结尾，孙少平还在经历苦难的磨炼。但我相信，他会创出自己的天地，走向更广阔的天空。</p>
<h3 id="要有一颗不屈于现状的心"><a href="#要有一颗不屈于现状的心" class="headerlink" title="要有一颗不屈于现状的心"></a>要有一颗不屈于现状的心</h3><p>孙少安虽然在农村老家勤恳务农，但他却觉得一直这样的话，无疑是在走父辈的老路。所以就有了开砖厂的想法，第一次由于经营不善，用人不善倒闭了。过了一年，重整旗鼓，吸取教训，最后终于办的有模有样，成了家乡的富翁。</p>
<p>孙少平从上高中开始就有读书的习惯，通过阅报一直在关注世界各地的发展形势，所以就有了一个不安分的心，想要到外面闯荡。所以后来独自一人去了煤矿，得到了一份令人羡慕不已的工作。</p>
<p>书中也反映了现实中的道理，有一句话，“比你优秀的人比你更努力”，假如觉得现在的生活可以了，不想再奋斗了，但是别人都在朝着自己的目标努力，若干时间后，你还会这样想吗？</p>
<h3 id="风雨过后就是彩虹"><a href="#风雨过后就是彩虹" class="headerlink" title="风雨过后就是彩虹"></a>风雨过后就是彩虹</h3><p>社会总是在不断发展的，美好的事物总会来临，就像中国这几十年来的发展一样，一天比一天好。不管怎样，属于你的终究是属于你的。不要抱有太多的悲观情绪，可以对比下自己，把现在的自己和一年前的自己，五年前的自己比比，是不是成长了许多。所以，奋斗吧骚年，风雨过后就是彩虹！！！</p>
<p>(软文一篇 😝)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/30/NSNotificationCenter防Crash守护/" itemprop="url">
                  NSNotificationCenter防Crash守护
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-30T15:08:47+08:00" content="2018-08-30">
              2018-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/30/NSNotificationCenter防Crash守护/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/30/NSNotificationCenter防Crash守护/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/08/30/NSNotificationCenter防Crash守护/" class="leancloud_visitors" data-flag-title="NSNotificationCenter防Crash守护">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于NSNotificationCenter，使用不当会造成Crash错误，比如没有在dealloc中removeObserver，或者在分线程中进行接收、发送通知等等。</p>
<ul>
<li>注：在iOS 9.0 或 macOS 10.11 以后，不需要在dealloc中调用removeObserver方法了,见<a href="https://developer.apple.com/documentation/foundation/nsnotificationcenter/1413994-removeobserver?language=objc" target="_blank" rel="external">官方文档</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">If your app targets iOS 9.0 and later or macOS 10.11 and later, you don&apos;t need to unregister an observer</div><div class="line"> in its dealloc method. Otherwise, you should call this method or removeObserver:name:object: before </div><div class="line"> observer or any object specified in addObserverForName:object:queue:usingBlock: or </div><div class="line"> addObserver:selector:name:object: is deallocated.</div></pre></td></tr></table></figure>
<p>当向通知中心注册的时候，NSNotificationCenter不会对observer强引用，在iOS 9.0以前，会持有一个<code>__unsafe_unretained</code>的指针，假如observer释放了，指针不会置为nil，变成不安全的指针。而在iOS 9.0及以后，使用<code>weak</code>修饰指针，解决了这个问题。详细见<a href="https://developer.apple.com/library/archive/releasenotes/Foundation/RN-FoundationOlderNotes/index.html#X10_11Notes" target="_blank" rel="external">官方更新说明</a>中关于NSNotificationCenter部分。</p>
<p>虽然不用移除了。但是探讨如何在dealloc方法中实现自动removeObserver还是有好处的。</p>
<h3 id="Swillze-dealloc-方法"><a href="#Swillze-dealloc-方法" class="headerlink" title="Swillze dealloc 方法"></a>Swillze dealloc 方法</h3><p>既然需要在dealloc方法中调用removeObserver方法，那么我们Swillze dealloc不就好了吗，在交换的dealloc方法里调用removeObserver。那么又有了一个问题，我们hook的dealloc方法是所有对象的dealloc，即所有对象的dealloc方法都会走我们自己的交换方法，怎么判定这个对象被注册到通知中心了呢？</p>
<p>所以，也需要hook <code>- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject</code> 这个方法，在hook方法里使用Rumtime AssociatedObject为observer添加一个标记。然后在自己的dealloc方法里通过判断是否有标记，来移除observer。</p>
<p>分析：<br>dealloc方法算是在整个项目里调用最频繁的方法之一了，hook dealloc方法感觉有点得不偿失，对性能有点影响。所以，我对这个 Swillze dealloc方法没有具体写代码去实现。</p>
<h3 id="AssociatedObject-Weak"><a href="#AssociatedObject-Weak" class="headerlink" title="AssociatedObject + Weak"></a>AssociatedObject + Weak</h3><p>我们先来看看dealloc底层都实现了什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void *objc_destructInstance(id obj) </div><div class="line">&#123;</div><div class="line">    if (obj) &#123;</div><div class="line">        // Read all of the flags at once for performance.</div><div class="line">        bool cxx = obj-&gt;hasCxxDtor();</div><div class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</div><div class="line"></div><div class="line">        // This order is important.</div><div class="line">        if (cxx) object_cxxDestruct(obj);</div><div class="line">        if (assoc) _object_remove_assocations(obj);</div><div class="line">        obj-&gt;clearDeallocating();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中有重要的两步，就是释放关联对象及弱引用，这个自动removeObserver就是用这两个知识点实现的。</p>
<p>当向通知中心注册的时候，用AssociatedObject为observer添加一个属性标记，这里使用的是分类的方式添加的，对NSObject添加一个分类，在分类里添加一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface NSObject (Tag)</div><div class="line">@property (nonatomic, strong) ZJNotificationTag *tag;</div><div class="line">@end</div><div class="line"></div><div class="line">static void *NSObject_ZJTag_Key = &amp;NSObject_ZJTag_Key;</div><div class="line"></div><div class="line">@implementation NSObject (ZJTag)</div><div class="line"></div><div class="line">- (void)setTag:(ZJNotificationTag *)tag &#123;</div><div class="line">    objc_setAssociatedObject(self, NSObject_ZJTag_Key, tag, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(ZJNotificationTag *)tag &#123;</div><div class="line">    return (ZJNotificationTag *)objc_getAssociatedObject(self, NSObject_ZJTag_Key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>ZJNotificationTag是自定义的，继承自NSObject的子类，持有observer的弱引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@interface ZJNotificationTag: NSObject</div><div class="line">@property (nonatomic, weak) id observer;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZJNotificationTag</div><div class="line"></div><div class="line">- (void)setObserver:(id)observer &#123;</div><div class="line">    _observer = observer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self.observer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>思路就是当observer释放，即dealloc的时候，dealloc内部会清除与之相关联的对象，即上述代码中的<code>tag</code>对象，而tag对象弱引用observer，所以不会产生循环引用，所以在tag对象的dealloc方法里，通过<code>tag.observer</code>得到了observer对象，从而将observer对象从通知中心移除。</p>
<p>下面简述一下实现过程中遇到的问题：</p>
<h4 id="保证observer对象只调用一次remove方法"><a href="#保证observer对象只调用一次remove方法" class="headerlink" title="保证observer对象只调用一次remove方法"></a>保证observer对象只调用一次remove方法</h4><p>假如在ViewController里同时注册多个不同通知，那么在dealloc里也只需移除一次。所以在添加标记时，先判断一下是否已经添加了标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSObject *_observer = (NSObject *)observer;</div><div class="line">if(!_observer.tag)&#123;</div><div class="line">    ZJNotificationTag *tag = [[ZJNotificationTag alloc] init];</div><div class="line">    _observer.tag = tag;</div><div class="line">    tag.observer = _observer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="保证不会重复注册observer"><a href="#保证不会重复注册observer" class="headerlink" title="保证不会重复注册observer"></a>保证不会重复注册observer</h4><p>对于同一个通知，即<code>NSNotificationName</code>相同的通知，如果重复注册，就会重复收到回调方法，在这里我维护了一个NSMutableDictionary，来处理这种由于不小心可能造成的bug：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary &lt;NSString*, NSHashTable*&gt;*_dic;</div></pre></td></tr></table></figure>
<p>key为<code>NSNotificationName</code>，value为<code>NSHashTable</code>，即能实现对内部对象弱引用的Set，当addObserver时先判断是否已经存在了，如果存在，即证明已经注册过了，直接返回，不再调用addObserver方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSHashTable *hashTable = [_dic objectForKey:name];</div><div class="line">if(!hashTable) &#123;</div><div class="line">    hashTable = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];</div><div class="line">    [self _addObserver:observer selector:selector name:name object:object hashTable:hashTable];</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">    if(![hashTable containsObject:observer]) &#123;</div><div class="line">        [self _addObserver:observer selector:selector name:name object:object hashTable:hashTable];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">[_dic setObject:hashTable forKey:name];</div></pre></td></tr></table></figure>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>注册observer、添加标记、添加对象到hashTable等操作方法都加了锁，保证线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_init(&amp;_lock, NULL);</div><div class="line"></div><div class="line">pthread_mutex_lock(&amp;_lock);</div><div class="line"></div><div class="line">pthread_mutex_unlock(&amp;_lock);</div></pre></td></tr></table></figure>
<p>在发送通知时，为了防止多线程可能引起的问题，在这里统一在主线程发出通知，这样的话，就保证了接收通知时一定在主线程，见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/NotificationCenters.html#//apple_ref/doc/uid/20000216-111349" target="_blank" rel="external">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In a multithreaded application, notifications are always delivered in the thread in which the </div><div class="line">notification was posted, which may not be the same thread in which an observer registered itself.</div></pre></td></tr></table></figure>
<p>借鉴了SDWebImage的做法(站在巨人的肩膀上😝)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)postNotificationName:(NSString *)name object:(id)object &#123;</div><div class="line">    </div><div class="line">    dispatch_main_async_safe(^&#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:name object:object];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在ViewController中添加监听的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[ZJNotificationCenter defaultCenter] addObserver:self selector:@selector(didReceiveNotification) name:@&quot;TestNotificationName&quot; object:nil];</div></pre></td></tr></table></figure>
<p>发送通知的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[ZJNotificationCenter defaultCenter] postNotificationName:@&quot;TestNotificationName&quot; object:nil];</div></pre></td></tr></table></figure>
<p>本文研究如何实现自动removeObserver，只是想到了这一个思路，文中的代码并未在正式环境中使用，如果错误，请指正。</p>
<p>代码已传至<a href="https://github.com/coderZhou10496/NotificationDemo" target="_blank" rel="external">Github</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/02/YYCache中的细节/" itemprop="url">
                  YYCache中的细节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-02T22:36:33+08:00" content="2018-08-02">
              2018-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/02/YYCache中的细节/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/02/YYCache中的细节/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/08/02/YYCache中的细节/" class="leancloud_visitors" data-flag-title="YYCache中的细节">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近花了点时间看了下<a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>的源码，觉得其中的一些代码细节非常好，遂记录之，虽然这些知识可能被别人写烂了，但自己总结下总归是好的。</p>
<h3 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h3><p>作者在YYMemoryCache中使用了C语言中的<code>pthread_mutex_t</code>来加锁解锁保证线程安全，而在YYDiskCache中使用<code>dispatch_semaphore信号量</code>，<code>dispatch_semaphore</code>不算锁，但可以实现锁的功能。</p>
<p>YYMemoryCache中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (id)objectForKey:(id)key &#123;</div><div class="line">    if (!key) return nil;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key));</div><div class="line">    if (node) &#123;</div><div class="line">        node-&gt;_time = CACurrentMediaTime();</div><div class="line">        [_lru bringNodeToHead:node];</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    return node ? node-&gt;_value : nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>YYDiskCache中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123;</div><div class="line">    if (!key) return nil;</div><div class="line">    dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER);</div><div class="line">    YYKVStorageItem *item = [_kv getItemForKey:key];</div><div class="line">    dispatch_semaphore_signal(self-&gt;_lock);</div><div class="line">    if (!item.value) return nil;</div><div class="line">    </div><div class="line">    id object = nil;</div><div class="line">    if (_customUnarchiveBlock) &#123;</div><div class="line">        object = _customUnarchiveBlock(item.value);</div><div class="line">    &#125; else &#123;</div><div class="line">        @try &#123;</div><div class="line">            object = [NSKeyedUnarchiver unarchiveObjectWithData:item.value];</div><div class="line">        &#125;</div><div class="line">        @catch (NSException *exception) &#123;</div><div class="line">            // nothing to do...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (object &amp;&amp; item.extendedData) &#123;</div><div class="line">        [YYDiskCache setExtendedData:item.extendedData toObject:object];</div><div class="line">    &#125;</div><div class="line">    return object;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在YYMemoryCache中，作者原先是使用自旋锁OSSpinLock来实现线程安全的，原理就是do while 忙等，缺点是等待时间会消耗大量 CPU 资源，所以它不适用于较长时间的任务，固在YYDiskCache中用<code>dispatch_semaphore</code>，<code>dispatch_semaphore</code>优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>
<p>但是由于OSSpinLock有安全问题，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。具体见<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">不再安全的 OSSpinLock</a>。所以就换成了<code>pthread_mutex_lock</code>互斥锁。</p>
<h3 id="GCD中使用-weak"><a href="#GCD中使用-weak" class="headerlink" title="GCD中使用__weak"></a>GCD中使用__weak</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)_trimRecursively &#123;</div><div class="line">    __weak typeof(self) _self = self;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</div><div class="line">        __strong typeof(_self) self = _self;</div><div class="line">        if (!self) return;</div><div class="line">        [self _trimInBackground];</div><div class="line">        [self _trimRecursively];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是YYDiskCache中的一段代码，目的是循环调用<code>_trimInBackground</code>方法来检查磁盘中的存储是否大于限制，大于限制的话就删除数据直到符合限制。这里作者使用了<code>__weak</code>来防止Block持有self。刚开始看到这句代码，我也不理解为什么要使用<code>__weak</code>，按理来说GCD中Block执行完后会释放self，不会存在内存泄露，在<a href="https://github.com/ibireme/YYKit/issues/41" target="_blank" rel="external">issues</a>也有关于这个问题的讨论。看了issues中的讨论，后来想了想，因为这是个递归调用，自己调用自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (!self) return;</div></pre></td></tr></table></figure>
<p>假如block中的self一直有值，那么这个循环会一直调用下去。那什么情况下block中self为nil呢。请看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">YYCache *cache = [[YYCache alloc] initWithPath:path];</div><div class="line">[cache setObject:@&quot;ZhangSan&quot; forKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>假如我们在ViewController中使用YYCache进行存储数据，但ViewController并没有持有YYCache实例，那么这两行代码执行完，cache这个对象就释放了，这是完美的结果。</p>
<p>但是假如在上述的源码里，没有使用<code>__weak</code>，而是直接使用了self，即使ViewController没有持有YYCache实例，cache这个对象也不会释放，YYDiskCache中的dealloc方法一直不会调用。因为Block一直在持有cache对象，并且这个方法是递归方法，所以就发生了“假的内存泄露”。</p>
<p>既然我们在ViewController中没有强引用cache，就希望使用它后自己释放掉，所以使用了<code>__weak</code>。假如在ViewController中强引用cache对象，那么使不使用<code>__weak</code>都是无关紧要的了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) YYCache *cache;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>另外提一点，因为YYCache中可以自己控制内存占用大小，磁盘占用大小，即超过限制自动删除尾部数据。假如我们不需要这个功能的时候，即对缓存大小无限制，可以注释掉相关检查操作的代码，因为它每隔一段时间(YYDiskCache默认为60s，YYMemoryCache默认为5s)会调用方法自动检查并操作数据，算是一个小优化吧。</p>
<h3 id="UIAppliaction对象"><a href="#UIAppliaction对象" class="headerlink" title="UIAppliaction对象"></a>UIAppliaction对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static UIApplication *_YYSharedApplication() &#123;</div><div class="line">    static BOOL isAppExtension = NO;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class cls = NSClassFromString(@&quot;UIApplication&quot;);</div><div class="line">        if(!cls || ![cls respondsToSelector:@selector(sharedApplication)]) isAppExtension = YES;</div><div class="line">        if ([[[NSBundle mainBundle] bundlePath] hasSuffix:@&quot;.appex&quot;]) isAppExtension = YES;</div><div class="line">    &#125;);</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</div><div class="line">    return isAppExtension ? nil : [UIApplication performSelector:@selector(sharedApplication)];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码是获得当前UIAppliaction对象，里面判断了当在App Extension里返回nil。假如是我们自己设计一个SDK给别人使用，会不会注意到这些细节呢？</p>
<h3 id="指定queue中子线程中释放对象"><a href="#指定queue中子线程中释放对象" class="headerlink" title="指定queue中子线程中释放对象"></a>指定queue中子线程中释放对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *holder = [NSMutableArray new];</div><div class="line">while (!finish) &#123;</div><div class="line">    if (pthread_mutex_trylock(&amp;_lock) == 0) &#123;</div><div class="line">        if (_lru-&gt;_tail &amp;&amp; (now - _lru-&gt;_tail-&gt;_time) &gt; ageLimit) &#123;</div><div class="line">            _YYLinkedMapNode *node = [_lru removeTailNode];</div><div class="line">            if (node) [holder addObject:node];</div><div class="line">        &#125; else &#123;</div><div class="line">            finish = YES;</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_unlock(&amp;_lock);</div><div class="line">    &#125; else &#123;</div><div class="line">        usleep(10 * 1000); //10 ms</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">if (holder.count) &#123;</div><div class="line">    dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        [holder count]; // release in queue</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在当前线程中创建一个NSMutableArray，然后将要删除释放的对象添加到数组中，再在子线程中调用count方法，这样就达到了在子线程中释放对象的目的了。</p>
<p>原因：当把将要删除的对象添加到array中，此时array不会释放，array中的对象也不会释放，因为在另外的线程中又调用了count方法，持有了array。当block执行完，就会释放持有的array，也达到了释放删除对象的目的，即在指定的queue中子线程释放对象。(说实话，看源码之前从来没有想到过这个需求，在指定的queue中释放对象，汗颜!)</p>
<h3 id="双向链表的选择"><a href="#双向链表的选择" class="headerlink" title="双向链表的选择"></a>双向链表的选择</h3><p>在YYMemoryCache中使用了双向链表来实现LRU的策略缓存，不止iOS平台，在其他平台，安卓，Linux等实现LRU算法都是使用双向链表+Map的方法。使用Map是为了更快找到要删除或移动的节点，链表是将经常使用的数据放到头部节点，删除的时候删除尾部节点的数据。一开始我想，这个明明用单向链表+Map就能实现，为什么要使用更加复杂的双线链表呢？</p>
<p>后来我又对比了双向链表与单向链表的的不同，单向链表每个节点只知道下个节点的内存地址，而不知道它上个节点的地址，双向链表既知道下个节点的地址，也知道上个节点的地址。正是因为这个原因，当我们要移动某个节点，比如移动中间的节点使它作为头部节点，假如用的是单向链表，因为它不知道它的上一个节点，所以还要遍历整个链表，找到上个节点，然后才能衔接起来。而双向链表不用遍历整个链表，它自己就知道它的上个节点地址。虽然双向链表更加复杂了一点，但是带来的好处，对性能的提升也是不言而喻的。</p>
<h3 id="接口的设计"><a href="#接口的设计" class="headerlink" title="接口的设计"></a>接口的设计</h3><p>YYCache里的接口及架构设计可以说是简洁明了，YYCache持有YYMemoryCache和YYDiskCache，两者分别负责内存缓存及磁盘缓存，两者之间互不影响。再来看下相关的api</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@interface YYCache : NSObject</div><div class="line"></div><div class="line">@property (copy, readonly) NSString *name</div><div class="line">@property (strong, readonly) YYMemoryCache *memoryCache</div><div class="line">@property (strong, readonly) YYDiskCache *diskCache</div><div class="line"></div><div class="line">- (nullable instancetype)initWithName:(NSString *)name</div><div class="line">- (nullable instancetype)initWithPath:(NSString *)path</div><div class="line">+ (nullable instancetype)cacheWithName:(NSString *)name</div><div class="line"></div><div class="line">- (BOOL)containsObjectForKey:(NSString *)key</div><div class="line">- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block</div><div class="line"> </div><div class="line">- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key</div><div class="line">- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block</div><div class="line"> </div><div class="line">- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key</div><div class="line">- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block</div><div class="line">- (void)removeObjectForKey:(NSString *)key</div><div class="line">- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block</div><div class="line">- (void)removeAllObjects</div><div class="line">- (void)removeAllObjectsWithBlock:(void(^)(void))block</div><div class="line">- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress</div><div class="line">                                 endBlock:(nullable void(^)(BOOL error))end</div></pre></td></tr></table></figure>
<p>可以说不用看注释，看方法名就可以直接知道该方法的作用，并且没有一个多余的方法。哪些方法该放在<code>.h</code>文件里声明给外部调用，哪些方法该放在<code>.m</code>文件里私有操作，都控制的完美无瑕。</p>
<p>YYCache里的接口及架构设计可以说是作为一个SDK的典范，并且代码也对每一个细节追求到极致。正因为设计的这么漂亮，源码读起来才会通俗易懂，让人赞叹👍！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/26/dispatch_once线程安全/" itemprop="url">
                  dispatch_once线程安全
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-26T22:04:18+08:00" content="2018-07-26">
              2018-07-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/分类/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/26/dispatch_once线程安全/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/26/dispatch_once线程安全/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/07/26/dispatch_once线程安全/" class="leancloud_visitors" data-flag-title="dispatch_once线程安全">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">   ...</div><div class="line">&#125;);</div><div class="line">return instance;</div></pre></td></tr></table></figure>
<p>说到单例，大家都会想到用<code>dispatch_once</code>实现，今天来探究一下<code>dispatch_once</code>内部如何操作的，如何保证线程安全的。</p>
<p><code>dispatch_once_t</code>实质就是个<code>long</code>类型的基本变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef long dispatch_once_t</div></pre></td></tr></table></figure>
<p><code>dispatch_once</code> 函数实现为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void  dispatch_once(dispatch_once_t *val, dispatch_block_t block) &#123;</div><div class="line"></div><div class="line">	dispatch_once_f(val, block, _dispatch_Block_invoke(block));</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将基本变量的指针及block传进去，<code>dispatch_block_t</code> 是自定义的 ，这个<code>block</code>就是我们要实现的初始化方法，无参数，无返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void (^dispatch_block_t)(void);</div></pre></td></tr></table></figure>
<p><code>_dispatch_Block_invoke</code>也是个宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define _dispatch_Block_invoke(bb) \</div><div class="line">		((dispatch_function_t)((struct Block_layout *)bb)-&gt;invoke)</div></pre></td></tr></table></figure>
<p>它的作用是获得<code>block</code>内部的<code>invoke</code>的函数指针，这个指针指向的具体的<code>block</code>实现函数的调用地址，就是我们自己在<code>dispatch_block_t</code>里写的那段代码的具体实现地址。</p>
<p>将变量地址，<code>block</code>，<code>invoke</code>三个参数传入<code>dispatch_once_f</code>方法里，下面继续分析<code>dispatch_once_f</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)</div><div class="line">&#123;</div><div class="line">#if !DISPATCH_ONCE_INLINE_FASTPATH</div><div class="line">	if (likely(os_atomic_load(val, acquire) == DLOCK_ONCE_DONE)) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">#endif // !DISPATCH_ONCE_INLINE_FASTPATH</div><div class="line">	return dispatch_once_f_slow(val, ctxt, func);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>DISPATCH_ONCE_INLINE_FASTPATH</code>是判断当前编译环境，是真机还是模拟器。最终实现方法来到了<code>dispatch_once_f_slow</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">dispatch_once_f_slow(dispatch_once_t *val, void *ctxt, dispatch_function_t func)</div><div class="line">&#123;</div><div class="line">#if DISPATCH_GATE_USE_FOR_DISPATCH_ONCE</div><div class="line">	dispatch_once_gate_t l = (dispatch_once_gate_t)val;</div><div class="line"></div><div class="line">	if (_dispatch_once_gate_tryenter(l)) &#123;</div><div class="line">		_dispatch_client_callout(ctxt, func);</div><div class="line">		_dispatch_once_gate_broadcast(l);</div><div class="line">	&#125; else &#123;</div><div class="line">		_dispatch_once_gate_wait(l);</div><div class="line">	&#125;</div><div class="line">#else</div><div class="line">	_dispatch_once_waiter_t volatile *vval = (_dispatch_once_waiter_t*)val;</div><div class="line">	struct _dispatch_once_waiter_s dow = &#123; &#125;;</div><div class="line">	_dispatch_once_waiter_t tail = &amp;dow, next, tmp;</div><div class="line">	dispatch_thread_event_t event;</div><div class="line"></div><div class="line">	if (os_atomic_cmpxchg(vval, NULL, tail, acquire)) &#123;</div><div class="line">		dow.dow_thread = _dispatch_tid_self();</div><div class="line">		_dispatch_client_callout(ctxt, func);</div><div class="line"></div><div class="line">		next = (_dispatch_once_waiter_t)_dispatch_once_xchg_done(val);</div><div class="line">		while (next != tail) &#123;</div><div class="line">			tmp = (_dispatch_once_waiter_t)_dispatch_wait_until(next-&gt;dow_next);</div><div class="line">			event = &amp;next-&gt;dow_event;</div><div class="line">			next = tmp;</div><div class="line">			_dispatch_thread_event_signal(event);</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		_dispatch_thread_event_init(&amp;dow.dow_event);</div><div class="line">		next = *vval;</div><div class="line">		for (;;) &#123;</div><div class="line">			if (next == DISPATCH_ONCE_DONE) &#123;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			if (os_atomic_cmpxchgv(vval, next, tail, &amp;next, release)) &#123;</div><div class="line">				dow.dow_thread = next-&gt;dow_thread;</div><div class="line">				dow.dow_next = next;</div><div class="line">				if (dow.dow_thread) &#123;</div><div class="line">					pthread_priority_t pp = _dispatch_get_priority();</div><div class="line">					_dispatch_thread_override_start(dow.dow_thread, pp, val);</div><div class="line">				&#125;</div><div class="line">				_dispatch_thread_event_wait(&amp;dow.dow_event);</div><div class="line">				if (dow.dow_thread) &#123;</div><div class="line">					_dispatch_thread_override_end(dow.dow_thread, val);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		_dispatch_thread_event_destroy(&amp;dow.dow_event);</div><div class="line">	&#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很长，逐段分析：</p>
<p>首先初始化了一系列的变量，<code>_dispatch_once_waiter_s</code>类似于链表中的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct _dispatch_once_waiter_s &#123;</div><div class="line">	volatile struct _dispatch_once_waiter_s *volatile dow_next; // 下一个节点</div><div class="line">	dispatch_thread_event_s dow_event; // 信号量</div><div class="line">	mach_port_t dow_thread; // 线程端口</div><div class="line">&#125; *_dispatch_once_waiter_t;</div></pre></td></tr></table></figure>
<p><code>if (os_atomic_cmpxchg(vval, NULL, tail, acquire))</code>这行代码展开为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (*vval == NULL) &#123;</div><div class="line">	*vval = tail = &amp;dow;</div><div class="line">	return true;</div><div class="line">&#125; else &#123;</div><div class="line">	return false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>意思是传入的<code>*vval == NULL</code>如果为nil，则赋值，并返回true，并且这个方法是原子操作的。当我们第一次进来，<code>val=0</code>接下来执行<code>if</code>里面的代码。</p>
<p><code>_dispatch_client_callout</code>表示执行<code>block</code>，然后将next标记为<code>DISPATCH_ONCE_DONE</code>。</p>
<p>假如整个过程只有一个线程，那么下面的while循环不会执行，执行到这里就结束了，。假如有其他线程进来，就会进入else分支里。</p>
<p>else分支里，是一个死循环，先判断<code>if (next == DISPATCH_ONCE_DONE)</code>，如果是，直接跳出循环。每进来一次，都会生成一个<code>_dispatch_once_waiter_s</code>的节点，添加到链表的尾部，然后调用信号量等待。而链表的头部是第一次进来的，进入到if代码段的那个节点。当if分支执行完后，会进入while循环遍历链表，依次发送信号将线程唤醒。</p>
<p>这就是全部的执行过程，用到的知识点主要是原子性操作、链表。由此可以看出大家都说<code>dispatch_once</code>只执行一次这种说话是不严谨的，它本质上可以执行多次，只是把每次执行请求放到了内部的链表里。<br>还是画个图吧。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/dispatch_once%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://zhoujianimagebucket.oss-cn-hongkong.aliyuncs.com/zhoujian_headerImage.jpeg"
               alt="Zhou Jian" />
          <p class="site-author-name" itemprop="name">Zhou Jian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coderZhou10496" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"coderzhou"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Bw40KBIPanRkt0iqTr7NLT6I-gzGzoHsz", "MQjFPSYkEazqnUv2rS7TOsui");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
