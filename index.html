<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Sky的博客">
<meta property="og:url" content="http://coderzhou.com/index.html">
<meta property="og:site_name" content="Sky的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sky的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coderzhou.com/"/>

  <title> Sky的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Sky的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一枚小小的程序猿，专注于iOS开发</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/04/UIView block动画原理分析/" itemprop="url">
                  UIView block动画原理浅析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-04T18:05:52+08:00" content="2018-01-04">
              2018-01-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/01/04/UIView block动画原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/04/UIView block动画原理分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/04/UIView block动画原理分析/" class="leancloud_visitors" data-flag-title="UIView block动画原理浅析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们在Xcode里写下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:1 animations:^&#123;</div><div class="line">        view.center = CGPointMake(200, 200);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>我们的view就会进行动画，那么我们今天来探究两个问题</p>
<p> 1.这行代码写在block里面跟写在外面到底有什么不一样，系统是怎么处理的？</p>
<p> 2.系统是怎么知道 <code>view.center = CGPointMake(200, 200)</code> 这行代码是写在 UIView block 中的？</p>
<h3 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h3><p>动画分为隐式动画和显示动画，隐式动画就是我们并没有指定任何动画的类型，仅仅是改变了一个属性，没有加动画特效，但它却默认有动画效果。区分隐式动画和显示动画是由由CoreAnimation中的CATransaction控制的。官方文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Core Animation supports two types of transactions: implicit transactions </div><div class="line">and explicit transactions. Implicit transactions are created automatically</div><div class="line">when the layer tree is modified by a thread without an active transaction </div><div class="line">and are committed automatically when the thread&apos;s runloop next iterates. </div><div class="line">Explicit transactions occur when the the application sends the </div><div class="line">CATransaction class a begin message before modifying the layer tree, and a </div><div class="line">commit message afterwards.</div></pre></td></tr></table></figure>
<p>意思是CoreAnimation支持两种事务，显式事务和隐式事务。<br>显式事务是调用[CATransaction begin]，然后是[CATransaction commit]。当没有实现这些时CoreAnimation自动创建隐式事务，它们在线程的运行循环下一次迭代时自动提交。</p>
<p>大家按住cmd点进CALayer的头文件中看的话，会发现很多的属性的注释中，最后会有一个词叫做Animatable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/** Geometry and layer hierarchy properties. **/</div><div class="line">/* The bounds of the layer. Defaults to CGRectZero. Animatable. */</div><div class="line"></div><div class="line">@property CGRect bounds;</div></pre></td></tr></table></figure>
<p>表示直接对layer的这个属性进行赋值，会产生隐式动画。</p>
<p>比如这段代码，点击按钮改变创建的layer的背景色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">self.layer = [CALayer layer];</div><div class="line">self.layer.frame = CGRectMake(130.0f, 200.0f, 100.0f, 100.0f);</div><div class="line">self.layer.backgroundColor = [UIColor blueColor].CGColor; </div><div class="line">[self.view.layer addSublayer:self.layer];</div><div class="line"></div><div class="line">- (IBAction)click:(UIButton *)sender &#123;</div><div class="line">    sender.selected = !sender.selected;</div><div class="line">    self.layer.backgroundColor = sender.selected ? [UIColor redColor].CGColor : [UIColor blueColor].CGColor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AnimationColor1.gif" alt="image"></p>
<p>可以看到，每一次改变颜色都有默认的很短的动画效果，这个动画就是隐式动画。</p>
<p>但是假如我们这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (IBAction)click:(UIButton *)sender &#123;</div><div class="line"></div><div class="line">	[CATransaction begin];</div><div class="line">	[CATransaction setAnimationDuration:1.0];</div><div class="line">    sender.selected = !sender.selected;</div><div class="line">    self.layer.backgroundColor = sender.selected ? [UIColor redColor].CGColor : [UIColor blueColor].CGColor;</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AnimationColor2.gif" alt="image"></p>
<p>这样就是显式动画，这样我们就可以看到动画效果了。</p>
<p>在iOS 4之前我们通过下面的方式进行动画，实际上在 <code>beginAnimations:context:</code> 和 <code>commitAnimations</code>之间所有视图或者图层属性的改变而做的动画都是由于设置了CATransaction的原因,另外Block动画方法也是一样，CATransaction 的<code>begin</code> 和 <code>commit</code> 会在block块中内部自动调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[UIView beginAnimations:@&quot;...&quot; context:nil];</div><div class="line">...</div><div class="line">...</div><div class="line">[UIView commitAnimations];</div></pre></td></tr></table></figure>
<h3 id="actionForLayer-forKey-方法"><a href="#actionForLayer-forKey-方法" class="headerlink" title="actionForLayer: forKey:方法"></a>actionForLayer: forKey:方法</h3><p>CALayer有个属性delegate，创建layer时，delegate默认为nil，动画效果就按默认的隐式动画呈现。如果对delegate赋值，并且这个delegate实现了delegate方法，那么动画效果就由delegate方法控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的返回值分以下三种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.返回实现了`&lt;CAAction&gt;`的对象,就按照对象的动画效果</div><div class="line"></div><div class="line">2.返回nil，意思等同于是没有实现这个方法，隐式动画。</div><div class="line"></div><div class="line">3.返回NSNull对象，表示结束，无隐式动画。</div></pre></td></tr></table></figure>
<p>那么这个方法什么时候调用呢？是当这个layer显示、不显示、和属性改变的时候调用，并且从CALayer的头文件可以看出显示和不显示的event参数值为 <code>onOrderIn</code> 和 <code>onOrderOut</code>，改变属性的时候参数值为属性值字符串。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/Animation_key.png" alt="image"></p>
<p>初始化layer的时候，我们可以把当前viewController作为delegate，实现一下这个delegate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123;</div><div class="line">	CABasicAnimation *ani = [[CABasicAnimation alloc] init];</div><div class="line">    ani.duration = 1.0;//设置动画时间为1秒钟</div><div class="line">    return ani;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为CAAnimation相关的类已经实现了<code>&lt;CAAction&gt;</code>，所以可以直接返回CABasicAnimation对象。从下面的图中，我们可以看到同样的效果</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AnimationColor2.gif" alt="image"></p>
<p>当然我们还可以自定义对象，实现<code>&lt;CAAction&gt;</code>协议。</p>
<p>我们知道，每个UIView都有一个根Layer，UIView是根Layer的delegete。我们改变UIView的属性没有产生动画的原因就是这个方法默认返回NSNull对象。我们可以通过代码验证下：</p>
<p>将自定义view添加到UIViewController的view上，点击按钮改变背景色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MyCustomView *view = [[MyCustomView alloc] initWithFrame:CGRectMake(100, 300, 100, 100)];</div><div class="line">view.backgroundColor = [UIColor redColor];</div><div class="line">[self.view addSubview:view];</div><div class="line">self.customView = view;</div><div class="line"></div><div class="line">- (IBAction)click1:(UIButton *)sender &#123;</div><div class="line">   self.customView.backgroundColor = sender.selected ? [UIColor 			redColor] : [UIColor blueColor];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>自定义UIView,重写这个delegate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface MyCustomView : UIView</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyCustomView</div><div class="line"></div><div class="line">- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123;</div><div class="line">    id value = [super actionForLayer:layer forKey:event];</div><div class="line">    NSLog(@&quot;value:%d&quot;,[value isKindOfClass:[NSNull class]]);</div><div class="line">    return value;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/Animation_value.png" alt="image"></p>
<p>从log中可以看到返回的对象就是NSNull类型的对象，即UIView默认关闭了根layer的隐式动画。</p>
<p>那么回到我们最开始我们讨论的这个问题，既然在UIView Block中改变view的属性产生了动画，那就这个代理方法就一定返回了一个实现<code>&lt;CAAction&gt;</code>的对象。我们通过代码验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;%@&quot;,[view.layer.delegate actionForLayer:view.layer </div><div class="line">forKey:@&quot;position&quot;]);</div><div class="line"></div><div class="line"> [UIView animateWithDuration:1 animations:^&#123;</div><div class="line">        view.center = CGPointMake(200, 200);</div><div class="line">        NSLog(@&quot;%@&quot;,[view.layer.delegate actionForLayer:view.layer forKey:@&quot;position&quot;]);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/Animation_resultpng.png" alt="image"><br>通过输出可以看到，在block外面，这个方法将返回一个NSNull，在block里面返回了一个叫做UIViewAdditiveAnimationAction类的对象，通过这个私有类的类名就可以猜到，这是一个实现了<code>&lt;CAAction&gt;</code>的对象，即会产生动画。</p>
<p>总结一下：<br>每个UIView对它关联的图层都扮演了一个委托，并且提供了actionForLayer：forKey：的实现方法。当不在一个动画块的中改变相应的属性值，UIView对所有图层行为返回NULL，这时候不会有动画效果产生；反之，它就返回一个CAAction协议对应的对象，然后进行动画处理。</p>
<h3 id="系统是如何知道的"><a href="#系统是如何知道的" class="headerlink" title="系统是如何知道的"></a>系统是如何知道的</h3><p>但是系统是怎么知道我们把改变view属性的这行代码写在了Block里，然后进行动画的呢？既我们开篇讲到的第一个问题。</p>
<p>Block动画写法是在 iOS 4.0 提出来的，在 iOS 4.0之前，我们写动画的方式是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIView beginAnimations:@&quot;...&quot; context:nil];</div><div class="line">...</div><div class="line">...</div><div class="line">[UIView commitAnimations];</div></pre></td></tr></table></figure>
<p>这个context是一个全局的参数，当我们在context这个环境下改变view属性时会被context所记录下来。在 执行完<code>commitAnimations</code> 后，系统检测context内的动画内容，然后渲染绘制进行动画。Block写法其实就是对这种复杂写法的一种封装，其本质也是有全局的系统变量进行监控，只是Block更优雅，更方便。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/05/关于AFURLSessionManager的几点疑问/" itemprop="url">
                  关于AFURLSessionManager的几点疑问
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-12-05T19:16:30+08:00" content="2017-12-05">
              2017-12-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/12/05/关于AFURLSessionManager的几点疑问/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/05/关于AFURLSessionManager的几点疑问/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/12/05/关于AFURLSessionManager的几点疑问/" class="leancloud_visitors" data-flag-title="关于AFURLSessionManager的几点疑问">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这两天花了点时间看了下<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>的源码，特别是对于 <code>AFURLSessionManager</code> 这个核心类研究的比较多，其中有几个疑问，所以写篇文章来记录下</p>
<h3 id="关于AFURLSessionManager的内存泄露"><a href="#关于AFURLSessionManager的内存泄露" class="headerlink" title="关于AFURLSessionManager的内存泄露"></a>关于AFURLSessionManager的内存泄露</h3><p>这个问题在<a href="https://github.com/AFNetworking/AFNetworking/issues" target="_blank" rel="external">issues</a>上被多次提到，就是说仅仅是写个简单的请求，也会出现内存泄露的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];</div><div class="line">[manager POST:urlStringparameters:paraDic progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">        </div><div class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line">        </div><div class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>当我们在 UIViewController 写上这段代码，因为 AFHTTPSessionManager 不是全局的类，不是单利类，理论上来说，当退出当前 UIViewController 时，AFHTTPSessionManager 类的 dealloc 方法应该执行，然后事实上却没有。</p>
<p>使用Instruments分析为：<br><img src="http://ocauxqtbu.bkt.clouddn.com/AFURLSessionManager01.png" alt="image"></p>
<p>意思就是 AFURLSessionManager 持有了 NSURLSession 对象，并且 NSURLSession 的delegate 对象 为AFURLSessionManager，造成了循环引用。其实就是这行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration </div><div class="line">delegate:self delegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>为什么会出现这个问题呢？我们来看下苹果开发文档对于这个方法的描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The session object keeps a strong reference to the delegate until your app</div><div class="line"> exits or explicitly invalidates the session. If you do not invalidate the </div><div class="line"> session by calling the invalidateAndCancel or finishTasksAndInvalidate </div><div class="line"> method, your app leaks memory until it exits.</div></pre></td></tr></table></figure>
<p>果然如此，NSURLSession 对象会强引用传入的 delegate 对象直到APP退出或者手动调用方法使 session 失效，否则会出现内存泄露的问题。</p>
<p>其实解决这个内存泄露的方法也很简单，官方文档也说了，手动使其失效。我们在 block 回调里调用一下 <code>invalidateAndCancel</code> 就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[manager POST:urlString parameters:dic progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line"></div><div class="line">        </div><div class="line">        &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line"></div><div class="line">            [manager.session invalidateAndCancel];</div><div class="line">        &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">            [manager.session invalidateAndCancel];</div><div class="line">        &#125;];</div></pre></td></tr></table></figure>
<p>但是 AFNetworking 的作者为什么没有这么做呢，而是任其内存泄露？我猜测可能是当一个界面存在多个网络请求时，我们用 manager 去请求，假如在一个请求回调里调用 <code>[manager.session invalidateAndCancel]</code> 方法，那么就使其他的请求终止了，故而发生错误。并且我们在页面下拉刷新时，由于 manager.session 已失效，也会出现错误。</p>
<h3 id="为什么在block回调里可以写-self-访问属性"><a href="#为什么在block回调里可以写-self-访问属性" class="headerlink" title="为什么在block回调里可以写 self. 访问属性"></a>为什么在block回调里可以写 <code>self.</code> 访问属性</h3><p>比如这样写当前 UIViewController 仍能释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong)AFHTTPSessionManager *manager;</div><div class="line"></div><div class="line">self.manager = [[AFHTTPSessionManager alloc]init];</div><div class="line">[manager POST:urlString parameters:dic progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line"></div><div class="line">        self.XX = XX</div><div class="line">        </div><div class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>这里Controller对象是强引用了manager，block强引用了Controller，那么manager强引用了block了吗？肯定是没有的，我们来看下</p>
<p>AFHTTPSessionManager 有个字典属性：mutableTaskDelegatesKeyedByTaskIdentifier：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;</div></pre></td></tr></table></figure>
<p>字典里面放的是，key是NSURLSessionTask的唯一标识，value是AFURLSessionManagerTaskDelegate对象。</p>
<p>AFURLSessionManagerTaskDelegate这个类强引用了 AFURLSessionManager 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) AFURLSessionManager *manager;</div></pre></td></tr></table></figure>
<p>1.UIViewController对象      持有    AFHTTPSessionManager对象</p>
<p>2.AFHTTPSessionManager对象  持有    字典</p>
<p>3.字典                          持有    AF…TaskDelegate对象</p>
<p>4.AF…TaskDelegate对象     持有    AFHTTPSessionManager对象(weak) </p>
<p>5.AF…TaskDelegate对象     持有    completionHandler(回调的block)</p>
<p>6.completionHandler        持有    UIViewController对象</p>
<p>看着很乱，还是看图吧</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/AFURLSessionManager03.png" alt="image"></p>
<p>那么AFNetworking是怎么处理的呢，怎么打破这种循环引用呢。</p>
<p>看下这个代理方法，这个方法是请求完成后调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error &#123;</div><div class="line"></div><div class="line"> [self removeDelegateForTask:task];</div><div class="line"> </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line">    [self.lock lock];</div><div class="line">    [delegate cleanUpProgressForTask:task];</div><div class="line">    [self removeNotificationObserverForTask:task];</div><div class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个回调方法里，把 AFURLSessionManagerTaskDelegate 对象从字典中移除了，就是说字典不再持有 AFURLSessionManagerTaskDelegate 对象，所以就不存在强引用了问题了。</p>
<h3 id="关于文件下载的操作"><a href="#关于文件下载的操作" class="headerlink" title="关于文件下载的操作"></a>关于文件下载的操作</h3><p>我们来看下 <code>NSURLSessionDownloadDelegate</code> 的这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        //调用自定义的block拿到文件存储的地址</div><div class="line">        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (fileURL) &#123;</div><div class="line">            delegate.downloadFileURL = fileURL;</div><div class="line">            NSError *error = nil;</div><div class="line">            //location是临时路径，我们把数据从临时的下载路径移动至我们需要的路径</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</div><div class="line">             //如果出错</div><div class="line">            if (error) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     //转发代理</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法我下载文件完成的时候调用。如果设置了 <code>downloadTaskDidFinishDownloadingBlock</code>，就去操作数据，把数据从临时的下载路径移动至我们需要的路径，然后 return，意思就是直接返回，不再执行。</p>
<p>如果没有设置block，就把这个代理转发到 AFURLSessionManagerTaskDelegate 自定义的代理里面。在自定义代理里做了同样的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    NSError *fileManagerError = nil;</div><div class="line">    self.downloadFileURL = nil;</div><div class="line"></div><div class="line">    //AF代理的自定义Block</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        //得到自定义下载路径</div><div class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (self.downloadFileURL) &#123;</div><div class="line">            //把下载路径移动到我们自定义的下载路径</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            //错误发通知</div><div class="line">            if (fileManagerError) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即：如果设置了 <code>downloadTaskDidFinishDownloadingBlock</code>，就去操作数据，把数据从临时的下载路径移动至我们需要的路径。这一步骤跟<code>NSURLSessionDownloadDelegate</code> 里的方法完全一样。并且，如果设置了block，操作文件后直接return了，不会再转发代理了。如果没设置block，转发代理后，在自己的代理方法里又判断了是否设置了block。</p>
<p>这个转发代理的步骤看起来多余了，AF的作者为什么这样做，让我不得解，难道还有其他的用处？</p>
<h3 id="其他的一些疑问"><a href="#其他的一些疑问" class="headerlink" title="其他的一些疑问"></a>其他的一些疑问</h3><p>1.当 AFURLSessionManagerTaskDelegate 这个类把 AFURLSessionManager 对象作为属性的时候用的是 weak</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, weak) AFURLSessionManager *manager;</div></pre></td></tr></table></figure>
<p>在自定义的代理方法里，因为这个属性是weak，所以进行了下面这一步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">    //强引用self.manager，防止被提前释放；因为self.manager声明为weak</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line">    .......</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>关于这个 weak 属性，我看了下，即使换成 strong 也不会出现内存泄露的问题，因为请求完成后 AFURLSessionManager 把 AFURLSessionManagerTaskDelegate 对象从字典中移除了。并且在上面的这个方法里，也不用多去操作一步。有点不明白，为什么用weak。</p>
<p>2.AFURLSessionManagerTaskDelegate 这个类在声明的时候同样遵循了 <code>NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate协议</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, </div><div class="line">NSURLSessionDataDelegate, </div><div class="line">NSURLSessionDownloadDelegate&gt;</div></pre></td></tr></table></figure>
<p>这里不遵循协议一样是可以的。可能是作者为了使这个类更规范一些，更像官方文档那样，所以这样写</p>
<p>3.在创建 NSURLSession 对象时，指定了回调代理的queque</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.operationQueue.maxConcurrentOperationCount = 1;</div><div class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration </div><div class="line">delegate:self delegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>这里我注意到了，设置了queue的最大operation并发个数为1，实现似于串行队列的效果。难道是作者为了节省内存资源这样做的，因为即使设置了并发个数为1，NSOperation也是可以同时执行多个任务的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/一次由performSelector引发的BUG/" itemprop="url">
                  一次由performSelector引发的BUG
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-12T12:15:01+08:00" content="2017-11-12">
              2017-11-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/12/一次由performSelector引发的BUG/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/12/一次由performSelector引发的BUG/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/11/12/一次由performSelector引发的BUG/" class="leancloud_visitors" data-flag-title="一次由performSelector引发的BUG">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们的APP在打包后测试过程过发现，所有的按钮点击效果不灵敏了，就是有时候按钮点击一次后再点就无效了，不会响应用户的操作。这个bug我觉得非常不可思议，并且我在模拟器上，即开发环境下没有任何问题。这篇文章就这个bug，来记录一下解决问题的过程。</p>
<h3 id="找到解决bug的原因"><a href="#找到解决bug的原因" class="headerlink" title="找到解决bug的原因"></a>找到解决bug的原因</h3><p>刚才说了，是所有的按钮，并且是在 Release 模式下会出现这个问题。由于是所有的按钮，所以想到了是全局的设置，比如我们可以一行代码全局设置APP内的导航栏效果等。我在我们APP工程里找了下，只有一个文件，就是 UIButton 的分类，这个分类的作用是防止按钮重复点击，比如控制APP内所有的按钮0.5秒内只能点击一次，可是这也不会出现导致点击一次后就无法点击的问题啊。我带着疑问去看这个分类的源码，并且我单独把这个分类拷贝出来，开一个Demo工程,然后分别在 Debug，Release模式下进行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        SEL selA = @selector(sendAction:to:forEvent:);</div><div class="line">        SEL selB = @selector(zj_sendAction:to:forEvent:);</div><div class="line">        Method methodA =   class_getInstanceMethod(self,selA);</div><div class="line">        Method methodB = class_getInstanceMethod(self, selB);</div><div class="line">        BOOL isAdd = class_addMethod(self, selA, method_getImplementation(methodB), method_getTypeEncoding(methodB));</div><div class="line">        if (isAdd) &#123;</div><div class="line">            class_replaceMethod(self, selB, method_getImplementation(methodA), method_getTypeEncoding(methodA));</div><div class="line">        &#125;else&#123;</div><div class="line">            method_exchangeImplementations(methodA, methodB);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)zj_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class="line">    </div><div class="line">    if (self.zj_ignoreEvent)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (self.zj_timeInterval &gt; 0) &#123;</div><div class="line">        </div><div class="line">        self.zj_ignoreEvent = YES;</div><div class="line">        </div><div class="line">        </div><div class="line">        [self performSelector:@selector(setZj_ignoreEvent:) withObject:@(NO) afterDelay:self.zj_timeInterval];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    [self zj_sendAction:action to:target forEvent:event];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/buttonTest.jpg" alt=""></p>
<p>我们在 load 方法里替换系统的 <code>sendAction:to:forEvent:</code>方法，改为自己定义的 <code>zj_sendAction:to:forEvent:</code> 方法。在自己的方法里去用点击的间隔时间来控制，这个点击是否有效。我在 Debug 模式下试了，没问题，可以在 Release 模式确实会出现点击一次后就无法点击的诡异问题。我们注意看这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (self.zj_ignoreEvent)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码是直接不响应用户的点击操作，直接返回。只有下一次点击时间的间隔，大于我们设置的 <code>zj_timeInterval</code>，方法才会继续执行。难道说，这个属性 <code>zj_zj_ignoreEvent</code> 被永久的设置为了YES，永远无法继续执行？我们通过打断点调试发现，事实确实是我们设想的那样，点击一次之后，这个属性一直都为YES。为什么呢？当时间过了间隔时间后，我们不是 <code>performSelector</code> 使这个属性设置为 NO 了吗</p>
<h3 id="诡异的-performSelector-方法"><a href="#诡异的-performSelector-方法" class="headerlink" title="诡异的 performSelector 方法"></a>诡异的 performSelector 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(setZj_ignoreEvent:) withObject:@(NO) afterDelay:self.zj_timeInterval];</div></pre></td></tr></table></figure>
<p>为此，专门测试了一下 <code>performSelector: withObject:</code>方法<br>比如我们在项目中写下这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(test:) withObject:@(NO) afterDelay:1];</div><div class="line"></div><div class="line">-(void)test:(BOOL)boolTest &#123;</div><div class="line">    NSLog(@&quot;%d&quot;,boolTest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候，当 Debug 模式下，boolTest的值确实为0，但是 Release 模式下却为2，不为0，无论加不加延迟加载结果都是一样的。难道 <code>performSelector</code> 在开发环境下，和生产环境下对数据的处理完全不一样。所以，就是这个原因导致项目中<code>zj_zj_ignoreEvent</code> 被永久的设置为了YES，按钮无法正常响应用户点击操作。</p>
<p>我们去翻了下Runtime的源码，里面对这个方法的内部实现也没有过多的解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)performSelector:(SEL)sel &#123;</div><div class="line">    if (!sel) [self doesNotRecognizeSelector:sel];</div><div class="line">    return ((id(*)(id, SEL))objc_msgSend)(self, sel);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仅仅是调用 <code>objc_msgSend</code>，而 <code>objc_msgSend</code>内部是用汇编语言写的，查阅起来比较困难。<br>我现在的解决办法是，不是用这个 <code>performSelector</code> 方法，而是使用 GCD 延迟加载的方式来实现功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.zj_timeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">            self.zj_ignoreEvent = NO;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>将原来项目中的延迟调用方法，换成这种就OK了。</p>
<p>需要额外提一下，我在网上搜防止button重复点击的开源代码，大部分都是使用<code>performSelector</code> 来延迟设置属性，以此告诫大家，不能一味的拷贝别人的代码，我在这里就吃了一个亏，虽然知道了实现原理，却在实现方法上出了错，还是要多看看代码，检查一下代码的正确性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/04/APP的启动/" itemprop="url">
                  APP的启动
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-04T18:33:28+08:00" content="2017-11-04">
              2017-11-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/04/APP的启动/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/04/APP的启动/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/11/04/APP的启动/" class="leancloud_visitors" data-flag-title="APP的启动">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>APP的启动是指从用户点击 APP 那一刻开始到用户看到第一个界面的整个过程</p>
<h3 id="一、APP的启动过程"><a href="#一、APP的启动过程" class="headerlink" title="一、APP的启动过程"></a>一、APP的启动过程</h3><h4 id="1-启动过程"><a href="#1-启动过程" class="headerlink" title="1.启动过程"></a>1.启动过程</h4><p>简单的来说就是 App 进行编译、汇编、链接、代码签名以及启动执行等操作</p>
<h5 id="1-1-解析Info-plist"><a href="#1-1-解析Info-plist" class="headerlink" title="1.1 解析Info.plist"></a>1.1 解析Info.plist</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.加载相关信息，例如如闪屏</div><div class="line"></div><div class="line">2.沙箱建立、权限检查</div></pre></td></tr></table></figure>
<h5 id="1-2-Mach-O加载"><a href="#1-2-Mach-O加载" class="headerlink" title="1.2 Mach-O加载"></a>1.2 Mach-O加载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1.如果是胖二进制文件，寻找合适当前CPU类别的部分</div><div class="line"></div><div class="line"> (由于需要支持不同CPU架构的iOS设备，所以我们编译打包出来的执行文件是一个Universal Binary格式文件，通用二进制文件，也称胖二进制文件)</div><div class="line"> </div><div class="line">2.加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）</div><div class="line"></div><div class="line">3.定位内部、外部指针引用，例如字符串、函数等</div><div class="line"></div><div class="line">4.执行声明为__attribute__((constructor))的C函数</div><div class="line"></div><div class="line">5.加载类扩展（Category）中的方法</div><div class="line"></div><div class="line">6.C++静态对象加载、调用ObjC的 +load 函数</div><div class="line"></div><div class="line">关于Mach-O文件的格式以及详细的加载过程，可看[这篇文章](http://www.jianshu.com/p/54d842db3f69)</div></pre></td></tr></table></figure>
<h5 id="1-3-程序执行"><a href="#1-3-程序执行" class="headerlink" title="1.3 程序执行"></a>1.3 程序执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1.main函数</div><div class="line"></div><div class="line">2.执行 UIApplicationMain 函数</div><div class="line"></div><div class="line">3.创建 UIApplication 对象</div><div class="line"></div><div class="line">4.创建UIApplicationDelegate对象</div><div class="line"></div><div class="line">5.读取配置文件info.plist，设置程序启动的一些属性</div><div class="line"></div><div class="line">6.创建应用程序的Main Runloop循环</div><div class="line"></div><div class="line">7.UIApplicationDelegate对象开始处理监听对象</div><div class="line"></div><div class="line">8.调用didFinishLaunchingWithOptions方法</div><div class="line"></div><div class="line">9.如果info.plist中配置了启动的storyBoard的文件名，加载storyboard文件，如果没有，创建UIWindow —&gt; rootViewController 显示</div></pre></td></tr></table></figure>
<h3 id="二、启动时间的计算"><a href="#二、启动时间的计算" class="headerlink" title="二、启动时间的计算"></a>二、启动时间的计算</h3><h4 id="2-1-main-函数之前"><a href="#2-1-main-函数之前" class="headerlink" title="2.1 main()函数之前"></a>2.1 main()函数之前</h4><p>苹果已经给出了方法来帮我们计算这部分的启动时间：<br>在Xcode的菜单中选择<code>Project</code> → <code>Scheme→Edit Scheme</code>，然后找到 <code>Run</code> →  <code>Environment Variables</code>，添加name为 <code>DYLD_PRINT_STATISTICS</code> 为1的环境变量，然后运行APP，会在控制台有一个输出。例如，我在之前的一个项目中加入以上设置后：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/blog_runTime.png" alt=""></p>
<p>1.main()函数之前总共使用了401.01ms</p>
<p>2.在401.01ms中，加载动态库用了112.08ms，指针重定位使用了161.83ms，ObjC类初始化使用了71.04ms，各种初始化使用了55.93ms。</p>
<p>3.在初始化耗费的55.93ms中，用时最多的三个初始化是libSystem.B.dylib、libMainThreadChecker.dylib以及XiaoBanBattery(自己的项目名称)。</p>
<h4 id="2-2-main-函数之后"><a href="#2-2-main-函数之后" class="headerlink" title="2.2 main()函数之后"></a>2.2 main()函数之后</h4><p>从main()函数开始至applicationWillFinishLaunching结束，再到完成数据的加载并展示相关信息给用户。</p>
<p>我们可以自己在这个过程中插入代码，从而获得这段时间。比如在didFinishLaunchingWithOptions获取一下时间，再在第一个主界面viewDidAppear获取一下时间，算出时间差。</p>
<h3 id="三、启动时间的优化"><a href="#三、启动时间的优化" class="headerlink" title="三、启动时间的优化"></a>三、启动时间的优化</h3><p>一个App完整的启动时间应该保证400ms之内,而若超过20s后还未完全启动App,那么App进程就会被系统杀死。那么如何来提升启动速度呢？</p>
<h4 id="1-移除不需要用到的动态库"><a href="#1-移除不需要用到的动态库" class="headerlink" title="1. 移除不需要用到的动态库"></a>1. 移除不需要用到的动态库</h4><p>每个App都进行动态库加载,其中系统级别的动态库占据了绝大数,而针对系统级别的动态库都是经过系统高度优化的,不用担心时间的花费.所以我们应该关注于自己集成到App的那些动态库,有些库集成进来了，但是没在代码中用到，一样会需要时间来加载它。所以移除移除不需要用到的动态库是很有必要的。</p>
<h4 id="2-移除不需要用到的类"><a href="#2-移除不需要用到的类" class="headerlink" title="2. 移除不需要用到的类"></a>2. 移除不需要用到的类</h4><p>日常代码的维护非常重要，如果一个业务去掉了，就应该在当时删掉相关的代码，否则的话无用的代码就会越来越多。日后，再去找这些无用的代码，应该没那么方便了。</p>
<h4 id="3-合并功能类似的类和分类"><a href="#3-合并功能类似的类和分类" class="headerlink" title="3. 合并功能类似的类和分类"></a>3. 合并功能类似的类和分类</h4><p>这样做主要是为了加快程序的整个动态链接, 在进行动态库的重定位和绑定过程中减少指针修正的使用,加快程序机器码的生成。所以要合并一些在工程、架构上没有太大意义的类和分类。</p>
<h4 id="4-使用initialize方法进行必要的初始化工作"><a href="#4-使用initialize方法进行必要的初始化工作" class="headerlink" title="4. 使用initialize方法进行必要的初始化工作"></a>4. 使用initialize方法进行必要的初始化工作</h4><p>如果不是非必须的，我们要用+initialize方法替换调用原先在OC的+load方法中执行初始代码工作,从而加快所有类文件的加载速度。</p>
<h4 id="5-压缩资源图片"><a href="#5-压缩资源图片" class="headerlink" title="5. 压缩资源图片"></a>5. 压缩资源图片</h4><p>启动的时候加载图片，图片小了，IO操作量就小了，启动当然就会快了，但是还是要以图片的质量，清晰度为前提下。</p>
<h4 id="6-优化rootViewController加载"><a href="#6-优化rootViewController加载" class="headerlink" title="6. 优化rootViewController加载"></a>6. 优化rootViewController加载</h4><p>在didFinishLaunchingWithOptions方法里，我们一般进行初始化第三方SDK、自己的一些工具类的初始化、然后再到第一个界面的渲染。其实这些东西也可以分开来做：</p>
<p>1.最先配置的事件，比如日志，统计等可以在没有设置rootViewController前进行初始化。</p>
<p>2.第三方SDK，比如推送，支付SDk，直播SDk的集成，可以在设置rootViewController后进行初始化，这样不会影响第一个视图的加载，毕竟人的视觉看到视图出现很快，就会觉得加载很快。</p>
<p>3.工具类的初始化配置。比如集成了IQKeyboardManager,需要启动的时候进行全局设置，这个操作可以放在第一个界面的viewDidAppear，这里完全不会影响到启动时间。</p>
<p>本文只是简单简述了APP的启动，比如点击APP图标后，动态库是如何链接到内存中的，代码的二进制文件是如何加载的等这些过程还需更深层次的探究。对于优化启动时间这个方面，我们只能做的就是写出更好的代码，优化项目。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/24/三次握手及四次挥手/" itemprop="url">
                  三次握手及四次挥手
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-24T18:25:39+08:00" content="2017-10-24">
              2017-10-24
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/24/三次握手及四次挥手/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/24/三次握手及四次挥手/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/10/24/三次握手及四次挥手/" class="leancloud_visitors" data-flag-title="三次握手及四次挥手">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们向服务器发送HTTP请求，获取数据、修改信息时，为实现数据的可靠传输，都需要建立TCP连接，包括三次握手，四次挥手。在理解三次握手，四次挥手之前，我们先了解TCP首部包含的数据及各个字段的含义，因为连接与断开连接要用到其中的字段</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/TCPConnect1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">源端口号：Source Port,发送数据的源进程端口</div><div class="line"></div><div class="line">目的端口号：Destination Port,接收数据的进程端口</div><div class="line"></div><div class="line">序号：Sequence Number,在一个TCP连接中传送的字节流中每一个字节都是按顺序编号的，</div><div class="line">这里的序号是指发送的时候本报文段的第一个字节的序,当ACK标志位为1时才生效</div><div class="line"></div><div class="line">确认序列号：Acknowledgement Number,是期望收到下一个报文段的第一个数据字节的序号</div><div class="line"></div><div class="line">首部长度：Data Offset,也称为数据偏移，其代表的意思是本报文的数据起始处距离本报文段的起始处有多远，因为TCP首部中存在可选字段，所以首部长度不固定</div><div class="line"></div><div class="line">保留位：Reserved,目前未使用，置0</div><div class="line"></div><div class="line">控制位：Control Flag,其实是有6个控制位，其中包括：</div><div class="line"></div><div class="line">  SYN:表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，</div><div class="line">  当连接请求的时候，SYN=1，ACK=0。连接被响应的时候，SYN=1，</div><div class="line">  ACK=1。这个标志的数据包经常被用来进行端口扫描。扫描者发送一个</div><div class="line">  只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台</div><div class="line">  主机存在这个端口。但是由于这种扫描方式只是进行TCP三次握手的第一</div><div class="line">  次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的</div><div class="line">  主机将会强制要求一个连接严格的进行TCP的三次握手</div><div class="line">		</div><div class="line">  ACK: 此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在</div><div class="line">  TCP数据包中。有两个取值: 0和1，为1的时候表示应答域有效，反之为0</div><div class="line">		</div><div class="line">  FIN:表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有</div><div class="line">  数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个</div><div class="line">  标志的数据包也经常被用于进行端口扫描</div><div class="line">		</div><div class="line">  URG:为紧急序号，URG=1是紧急指针有效；</div><div class="line">		</div><div class="line">  PSH:指示接收方立即将数据提交给应用层，而不是等待缓冲区满；</div><div class="line">		</div><div class="line">  RST:重置连接。</div><div class="line">		</div><div class="line"></div><div class="line">  窗口大小：Window Size ,也就是有名的滑动窗口，用来进行流量控制</div><div class="line"></div><div class="line">  校验和：Checksum,用来校验首部和数据部分</div><div class="line"></div><div class="line">  紧急指针：Urgent Pointer,只有在URG位=1的时候才有效,紧急指</div><div class="line">  针的值与序号的相加值为紧急数据的最后一个字节位置。用于发送紧急数据</div></pre></td></tr></table></figure>
<p>关于连接和断开连接，直接上图，下面再文字解释</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/TCPConnect2.png" alt=""></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>1.第一次握手：客户端发送连接请求报文段，将SYN位置为1，Sequence Number为X(由操作系统动态随机选取一个32位长的序列号)；然后，客户端进入SYN_SEND状态，等待服务器的确认</p>
<p>2.第二次握手: 服务器收到客户端的SYN报文段。需要对这个SYN报文段进行确认，设置确认序列号Ack为X+1。同时，自己还要发送SYN请求信息，将SYN位置为1，ACK为1，序号Seq为K(由操作系统动态随机选取一个32位长的序列号)。服务器端将上述所有信息一并发送给客户端，此时服务器进入SYN_RECV状态</p>
<p>3.第三次握手: 客户端收到服务器的报文段。确认序列号Ack为K+1，序号Seq为X+1(第二次握手中的Ack值)，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手</p>
<h4 id="那么为什么要三次握手呢，两次不就够了吗？"><a href="#那么为什么要三次握手呢，两次不就够了吗？" class="headerlink" title="那么为什么要三次握手呢，两次不就够了吗？"></a>那么为什么要三次握手呢，两次不就够了吗？</h4><p>因为要防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，比如：<br>client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>1.第一次挥手: 主动关闭方(可以是客户端，也可以是服务端，这里假设为客户端)，将FIN置为1，ACK置为1，序号Seq设置为J，即上一次对方传送过来的Ack值，Ack设置为K,即为上一次对方传过来的Seq的值+1。设置好以上值后，将数据发送至被动关闭方。主动关闭方进入FIN_WAIT_1状态。</p>
<p>2.第二次挥手：服务端收到了客户端发送的FIN报文段，向客户端回复，将ACK置为1，确认序号Ack设置为J+1,即第一次挥手中的Seq值+1，Seq设置为K，即第一次挥手中的Ack值。然后服务端进入CLOSE_WAIT状态，客户端收到服务端的回复后，进入FIN_WAIT_2状态。</p>
<p>3.第三次挥手：服务端再次向客户端发送报文，将FIN置为1，ACK置为1，Ack设置为J+1,即第二次挥手中的Ack值，序号Seq设置为K,第二次挥手中的Seq值。然后服务端进入LAST_ACK状态</p>
<p>4.第四次挥手：客户端收到服务端发送的FIN报文段，向服务端回复，将ACK置为1，Ack设置为K+1,，序号Seq设置为J+1,即第三次挥手中的Ack值。然后客户端进入TIME_WAIT状态，服务端在收到报文后进入CLOSED状态，客户端在发送完报文等待了2MSL时间后进入CLOSED状态。至此，断开连接。</p>
<h4 id="为什么客户端在发送最后一次报文后，等待2MSL之后才关闭连接呢？"><a href="#为什么客户端在发送最后一次报文后，等待2MSL之后才关闭连接呢？" class="headerlink" title="为什么客户端在发送最后一次报文后，等待2MSL之后才关闭连接呢？"></a>为什么客户端在发送最后一次报文后，等待2MSL之后才关闭连接呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">因为这个ACK报文段有可能丢失，因而使处在LAST_ACK状态的服务端收不到对自己已发送的FIN+ACK</div><div class="line">报文段的确认，所以的服务端会超时重传这个FIN+ACK报文段。而客户端就能在2MSL时间内收到这个</div><div class="line">重传的FIN+ACK报文段。接着客户端重传一次确认，最后两者都正常进入到CLOSED状态。如果客户端</div><div class="line">在TIME_WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到服务</div><div class="line">端重传的FIN+ACK报文段，因而也不会在发送一次确认报文段。这样，服务端就无法按照正常步骤进入</div><div class="line">CLOSED状态。</div></pre></td></tr></table></figure>
<h4 id="为什么断开连接是四次挥手呢？像开始连接一样，三次不行吗？"><a href="#为什么断开连接是四次挥手呢？像开始连接一样，三次不行吗？" class="headerlink" title="为什么断开连接是四次挥手呢？像开始连接一样，三次不行吗？"></a>为什么断开连接是四次挥手呢？像开始连接一样，三次不行吗？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TCP四次挥手中的第二次、第三次挥手都是向客户端发送数据，那么这两次能否也能合为一次呢？答案</div><div class="line">是不行的。当开始连接时，服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把</div><div class="line">ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当服务端收</div><div class="line">到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了，服务端可能还存在着需要发送给客户</div><div class="line">端但是未发送的数据。所以，再发送FIN报文给对方来表示同意现在可以关闭连接了，所以它这里的</div><div class="line">ACK报文和FIN报文多数情况下都是分开发送的。</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/06/crash分析/" itemprop="url">
                  Crash分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-08-06T10:06:55+08:00" content="2017-08-06">
              2017-08-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/08/06/crash分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/08/06/crash分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/08/06/crash分析/" class="leancloud_visitors" data-flag-title="Crash分析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、-Crash文件的获取"><a href="#一、-Crash文件的获取" class="headerlink" title="一、 Crash文件的获取"></a>一、 Crash文件的获取</h3><p>在开发的过程中，难免会遇到应用crash的发生，了解为何会发生crash，对我们以后写代码的稳定有非常大的作用。应用的每一次闪退，手机会自动的把这次闪退记录下来，以文件的形式保存到手机上。Crash文件的获取分两种情况，一种是在测试阶段，一种是线上APP。</p>
<h4 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h4><p>在测试阶段，假如测试人员专业的话，应用奔溃时，会告诉你什么时候崩溃了，点击哪个按钮崩溃了。但是不专业的话，可能告诉你的信息就不那么全了。但是我们可以通过分析crash文件，来定位闪退的原因。通过打AdHoc包将APP安装到手机上，假如发生闪退了，可以把手机拿过来，通过iTunes连接，将crash信息同步到电脑上</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_tongbu.png" alt="image"></p>
<p>点击同步后，电脑上这个文件夹下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Logs/CrashReporter/MobileDevice</div></pre></td></tr></table></figure>
<p>就能找到对应设备的crash文件了</p>
<h4 id="线上APP"><a href="#线上APP" class="headerlink" title="线上APP"></a>线上APP</h4><p>APP上线以后，crash文件的获取在Xcode - Windwo - Organizer - Crashes<br>这里面列出了每个APP版本的闪退信息，通过Show in Finder也能获取到crash文件。但注意的是，这个Xcode，必须是上传时用的Xcode。</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_list.png" alt="image"></p>
<p>之前有人说，通过开发者中心，iTunes Connect，也能获取到，我去看了下，好像没有这个选项了。另外，假如苹果在审核的时候，发生闪退，被打了回来，审核团队也会提供一份crash文件，我们可以直接用来分析。</p>
<h3 id="二、-Crash文件的分析"><a href="#二、-Crash文件的分析" class="headerlink" title="二、 Crash文件的分析"></a>二、 Crash文件的分析</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>文件分析需要四样东西，crash文件，symbolicatecrash分析工具，闪退APP的打包后的.APP文件，以及此包对应的.dSYM符号表文件。我们在桌面上新建一个文件夹，命名为crash文件分析，一样一样准备就行了。</p>
<p>获取crash文件我们上面已经了解到了，symbolicatecrash分析工具是Xcode自带的，我们只需要拿来用就行，打开终端，输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find /Applications/Xcode.app -name symbolicatecrash -type f</div></pre></td></tr></table></figure>
<p>过几秒钟，symbolicatecrash分析工具的路径就会显示出来，我们进入这个路径中，将symbolicatecrash分析工具拷贝到桌面上刚才创建的crash文件分析的文件夹中</p>
<p>.APP及.dSYM符号表文件的获取：</p>
<p>在Organizer - Archives里显示的有打过的包，找到crash发生对应的那个版本包，然后 Show in Finder,显示包内容,.dSYM文件在dSYMs文件夹下，.APP文件在Products - Applications文件夹下。分别拷贝他们到桌面的crash文件分析的文件夹中</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_dsym.png" alt="image"></p>
<h4 id="dSYM符号表是什么？"><a href="#dSYM符号表是什么？" class="headerlink" title=".dSYM符号表是什么？"></a>.dSYM符号表是什么？</h4><p>符号表就是指在Xcode项目编译后，在编译生成的二进制文件.app的同级目录下生成的同名的.dSYM文件。.dSYM文件其实是一个目录，在子目录中包含了一个16进制的保存函数地址映射信息的中转文件，所有Debug的symbols都在这个文件中(包括文件名、函数名、行号等)，所以也称之为调试符号信息文件。一般地，Xcode项目每次编译后，都会生成一个新的.dSYM文件。因此，App的每一个发布版本，都需要备份一个对应的.dSYM文件，以便后续调试定位问题。</p>
<p>符号表有什么用<br>符号表的作用是把崩溃中的函数地址解析为函数名等信息。如果开发者能够获取到崩溃的函数地址信息，就可以利用符号表分析出具体的出错位置。<br> 在Xcode开发调试App时，一旦遇到崩溃问题，开发者可以直接使用Xcode的调试器定位分析。<br> 但如果App发布上线，开发者不可能进行调试，只能通过分析系统记录的崩溃日志来定位问题，在这份崩溃日志文件中，会指出App出错的函数内存地址，而这些函数地址是可以在.dSYM文件中找到具体的文件名、函数名和行号信息的，这正是符号表的重要作用所在，也是为什么要进行符号表进行管理，并纪录这是哪个版本的符号表。</p>
<h4 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h4><p>打开终端，cd到刚才创建的文件夹下，输入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./symbolicatecrash /Users/用户名/Desktop/crash文件/watchnail-2017-08-03-143201.crash /Users/用户名/Desktop/crash文件/watchnail.app.dSYM &gt; result.crash</div></pre></td></tr></table></figure>
<p>这个时候可能会出现一个error</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</div></pre></td></tr></table></figure>
<p>不用怕，继续输入指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export DEVELOPER_DIR=&quot;/Applications/XCode.app/Contents/Developer&quot;</div></pre></td></tr></table></figure>
<p>然后再输入一遍刚开始的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./symbolicatecrash /Users/用户名/Desktop/crash文件/watchnail-2017-08-03-143201.crash /Users/用户名/Desktop/crash文件/watchnail.app.dSYM &gt; result.crash</div></pre></td></tr></table></figure>
<p>这个时候如果成功的话，文件夹下回多出一个文件，名字为result.crash文件</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_result.png" alt="image"></p>
<p>而这个文件就是我们最终需要的文件，直接打开，里面列出了闪退时的各种信息：</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/crash_wenjian.png" alt="image"></p>
<p><code>Incident Identifier</code>：崩溃报告的唯一标识符，不同的Crash日志该标示符也不同。</p>
<p><code>CrashReporter Key</code>：设备标识相对应的唯一键值(并非真正的设备的UDID，苹果为了保护用户隐私iOS6以后已经无法获取)。通常同一个设备上同一版本的App发生Crash时，该值都是一样的。</p>
<p><code>Hardware Model</code> ：代表发生Crash的设备类型。</p>
<p><code>Process</code>：代表系统Crash的进程名称，通常都是我们的App的名字, [ ]里面是当时进程的ID。</p>
<p><code>Path</code>：App的所在路径。</p>
<p><code>Identifier</code>：我们App的Indentifier，通常为“com.xxx.yyy”，xxx代表公司的域名，yyy代表某一个App标识。</p>
<p><code>AppVersion</code>：当前App的版本号，由Info.plist中的两个字段组成，CFBundleShortVersionString and CFBundleVersion。</p>
<p><code>Code Type</code>：当前App的CPU架构。<br><code>Role</code>:表示crash时，程序在前台运行还是在后台<br><code>Parent Process</code>：当前进程的父进程，由于iOS中App通常都是单进程的，一般父进程都是launchd。</p>
<p><code>Date/Time</code>：发生crash的时间</p>
<p><code>Launch Time</code>：启动App的时间</p>
<p><code>OS Version</code>：iOS系统固件版本</p>
<p><code>Report Version</code>：日志版本</p>
<p><code>Exception Type</code>： 异常的类型<br>常见的Exception Type异常类型的信息</p>
<p>EXC_BAD_ACCESS：此类型是最常见的crash, 通常用于访问了不该访问的内存导致的，野指针错误形式在Xcode中通常表现就为这个</p>
<p>SIGSEGV:通常由于重复释放对象导致, 一般在ARC以后很少见到</p>
<p>SIGABRT: 收到Abort信号退出,</p>
<p>SEGV(Segmentation Violation): 代表无效内存地址, 比如空指针, 未初始化指针, 栈溢出等.</p>
<p>SIGBUS:总栈错误, 与SIGSEGV不同的是, SIGSEGV访问的是无效的地址, 而SIGBUS访问的是有效的地址, 但是总栈访问异常(如地址对齐问题)</p>
<p><code>Exception Codes</code>:  异常出错的代码</p>
<p><code>Exception Note</code>:  异常通知</p>
<p><code>Triggered by Thread</code>： 问题发生的thread</p>
<p><code>Last Exception Backtrace</code>:     最后异常回溯，一般根据这个代码就能找到crash的具体问题</p>
<p>下面来看下我这个crash文件，没有处理前的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Last Exception Backtrace:</div><div class="line">(0x18bdaafd8 0x18a80c538 0x18bdb1ef4 0x18bdaef4c 0x18bcaad2c </div><div class="line">0x18c887bfc 0x18bd59a9c 0x18bd597a0 0x18bd59060 0x18bd56c84 0x18bc86d94 0x18d6f0074 0x191f38130 0x1001a34d8 0x18ac9559c)</div><div class="line"></div><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libsystem_kernel.dylib        	0x000000018ada5014 0x18ad86000 + 126996</div><div class="line">1   libsystem_pthread.dylib       	0x000000018ae6f334 0x18ae6a000 + 21300</div><div class="line">2   libsystem_c.dylib             	0x000000018ad199c4 0x18acb8000 + 399812</div><div class="line">3   libc++abi.dylib               	0x000000018a7e51b0 0x18a7e4000 + 4528</div><div class="line">4   libc++abi.dylib               	0x000000018a7fb5f0 0x18a7e4000 + 95728</div><div class="line">5   libc++abi.dylib               	0x000000018a7fb1a8 0x18a7e4000 + 94632</div><div class="line">6   libobjc.A.dylib               	0x000000018a80c6f8 0x18a804000 + 34552</div><div class="line">7   CoreFoundation                	0x000000018bc86e00 0x18bc7e000 + 36352</div><div class="line">8   GraphicsServices              	0x000000018d6f0074 0x18d6e4000 + 49268</div><div class="line">9   UIKit                         	0x0000000191f38130 0x191ec3000 + 479536</div><div class="line">10  watchnail                     	0x00000001001a34d8 0x100060000 + 1324248</div><div class="line">11  libdyld.dylib                 	0x000000018ac9559c 0x18ac91000 + 17820</div></pre></td></tr></table></figure>
<p>处理后的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Last Exception Backtrace:</div><div class="line">0   CoreFoundation                	0x18bdaafd8 __exceptionPreprocess + 124</div><div class="line">1   libobjc.A.dylib               	0x18a80c538 objc_exception_throw + 56</div><div class="line">2   CoreFoundation                	0x18bdb1ef4 -[NSObject(NSObject) doesNotRecognizeSelector:] + 140</div><div class="line">3   CoreFoundation                	0x18bdaef4c ___forwarding___ + 916</div><div class="line">4   CoreFoundation                	0x18bcaad2c _CF_forwarding_prep_0 + 92</div><div class="line">5   Foundation                    	0x18c887bfc __NSFireDelayedPerform + 408</div><div class="line">6   CoreFoundation                	0x18bd59a9c __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 28</div><div class="line">7   CoreFoundation                	0x18bd597a0 __CFRunLoopDoTimer + 856</div><div class="line">8   CoreFoundation                	0x18bd59060 __CFRunLoopDoTimers + 244</div><div class="line">9   CoreFoundation                	0x18bd56c84 __CFRunLoopRun + 1484</div><div class="line">10  CoreFoundation                	0x18bc86d94 CFRunLoopRunSpecific + 424</div><div class="line">11  GraphicsServices              	0x18d6f0074 GSEventRunModal + 100</div><div class="line">12  UIKit                         	0x191f38130 UIApplicationMain + 208</div><div class="line">13  watchnail                     	0x1001a34d8 main (main.m:14)</div><div class="line">14  libdyld.dylib                 	0x18ac9559c start + 4</div><div class="line"></div><div class="line"></div><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libsystem_kernel.dylib        	0x000000018ada5014 __pthread_kill + 8</div><div class="line">1   libsystem_pthread.dylib       	0x000000018ae6f334 pthread_kill + 112</div><div class="line">2   libsystem_c.dylib             	0x000000018ad199c4 abort + 140</div><div class="line">3   libc++abi.dylib               	0x000000018a7e51b0 __cxa_bad_cast + 0</div><div class="line">4   libc++abi.dylib               	0x000000018a7fb5f0 std::__terminate(void (*)()) + 44</div><div class="line">5   libc++abi.dylib               	0x000000018a7fb1a8 __cxa_rethrow + 144</div><div class="line">6   libobjc.A.dylib               	0x000000018a80c6f8 objc_exception_rethrow + 44</div><div class="line">7   CoreFoundation                	0x000000018bc86e00 CFRunLoopRunSpecific + 532</div><div class="line">8   GraphicsServices              	0x000000018d6f0074 GSEventRunModal + 100</div><div class="line">9   UIKit                         	0x0000000191f38130 UIApplicationMain + 208</div><div class="line">10  watchnail                     	0x00000001001a34d8 main (main.m:14)</div><div class="line">11  libdyld.dylib</div></pre></td></tr></table></figure>
<p>可以看出，原来的函数地址，都被还原成了函数名。我们通过<code>Triggered by Thread</code>得到问题发生的线程，再去找相应的线程模块，就可以找到问题所在了。</p>
<p>我这个测试demo中，crash发生在主线程，崩溃原因为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[NSObject(NSObject) doesNotRecognizeSelector:]</div></pre></td></tr></table></figure>
<p>意思是没有实现相应的方法。但是美中不足的是，只提示了是什么原因导致的crash，并没有提示是哪个类不识别这个方法，难道需要其他的方法，来定位crash时所在的类？</p>
<p>现在也有很多的第三方服务来专门收集crash，如友盟，Bugly等等，不只是crash，还有对卡顿，性能的检测等等。</p>
<h3 id="三、-常见的crash类型"><a href="#三、-常见的crash类型" class="headerlink" title="三、 常见的crash类型"></a>三、 常见的crash类型</h3><h4 id="unrecognized-selector-crash"><a href="#unrecognized-selector-crash" class="headerlink" title="unrecognized selector crash"></a>unrecognized selector crash</h4><p>这个原因通常是一个对象调用了一个不属于它方法的方法导致的。</p>
<p>预防：使用Runtime的消息转发来实现</p>
<ol>
<li>动态创建一个桩类</li>
<li>动态为桩类添加对应的Selector，用一个通用的返回0的函数来实现该SEL的IMP</li>
<li>将消息直接转发到这个桩类对象上。</li>
</ol>
<h4 id="KVO-crash"><a href="#KVO-crash" class="headerlink" title="KVO crash"></a>KVO crash</h4><ol>
<li>KVO的被观察者dealloc时仍然注册着KVO导致的crash</li>
<li>添加KVO重复添加观察者或重复移除观察者（KVO注册观察者与移除观察者不匹配）导致的crash</li>
</ol>
<p>预防：被观察对象持有一个KVO的delegate，所有和KVO相关的操作均通过delegate来进行管理，delegate通过建立一张map来维护KVO整个关系。</p>
<p>这里极力推荐一个facebook开源的关于管理KVO的开源库<a href="https://github.com/facebook/KVOController" target="_blank" rel="external">KVOController</a></p>
<h4 id="NSNotification-crash"><a href="#NSNotification-crash" class="headerlink" title="NSNotification crash"></a>NSNotification crash</h4><p>当一个对象添加了notification之后，如果dealloc的时候，仍然持有notification，就会出现NSNotification类型的crash。<br>所幸的是，苹果在iOS9之后专门针对于这种情况做了处理，所以在iOS9之后，即使开发者没有移除observer，Notification crash也不会再产生了。<br>不过针对于iOS9之前的用户，我们还是有必要做一下NSNotification Crash的防护的。</p>
<h4 id="NSTimer-crash"><a href="#NSTimer-crash" class="headerlink" title="NSTimer crash"></a>NSTimer crash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</div></pre></td></tr></table></figure>
<p>使用这个方法时，NSTimer会强引用target实例，所以需要在合适的时机invalidate定时器，否则就会由于定时器timer强引用target的关系导致target不能被释放，造成内存泄露，甚至在定时任务触发时导致crash。</p>
<h4 id="Container-crash"><a href="#Container-crash" class="headerlink" title="Container crash"></a>Container crash</h4><p>Container 类型的crash 指的是容器类的crash，常见的有NSArray／NSMutableArray／NSDictionary／NSMutableDictionary／NSCache的crash。 一些常见的越界、插入nil等错误操作均会导致此类crash发生</p>
<h4 id="野指针crash"><a href="#野指针crash" class="headerlink" title="野指针crash"></a>野指针crash</h4><p>在App的所有Crash中，访问野指针导致的Crash占了很大一部分</p>
<h4 id="非主线程刷UI类型crash"><a href="#非主线程刷UI类型crash" class="headerlink" title="非主线程刷UI类型crash"></a>非主线程刷UI类型crash</h4><p>非主线程刷UI将会导致app运行crash，所以一定要在主线程中进行UI操作</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/20/OC与JS的交互/" itemprop="url">
                  OC与JS的交互
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-20T22:00:41+08:00" content="2017-05-20">
              2017-05-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/20/OC与JS的交互/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/20/OC与JS的交互/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/05/20/OC与JS的交互/" class="leancloud_visitors" data-flag-title="OC与JS的交互">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在开发的过程中，免不了要与webView打交道，比如一个活动页面，或者一个比较复杂的界面，H5同事写好之后直接给安卓、iOS开发的人调用就行了，但这里就需要用到 Objective-C 与 JavaScript 交互的知识了，OC调用JS的方法，JS调用OC的方法，以及它们之间传值等。闲暇之余花了一些时间整理了一下，大致就一下三种方式来进行交互，相关代码已传至<a href="https://github.com/coderZhou10496/Objective-CInteractiveWithJS" target="_blank" rel="external">Github</a></p>
<h3 id="一、通过UIWebView代理方法，拦截URL的方法"><a href="#一、通过UIWebView代理方法，拦截URL的方法" class="headerlink" title="一、通过UIWebView代理方法，拦截URL的方法"></a>一、通过UIWebView代理方法，拦截URL的方法</h3><h4 id="OC调用JS"><a href="#OC调用JS" class="headerlink" title="OC调用JS"></a>OC调用JS</h4><p>OC调用js是通过这个方法，来实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;</div></pre></td></tr></table></figure>
<p>在 Demo 中，我们先通过这个方法注入js方法，当然这个js方法可以直接先写在html文件中，就不用注入了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-(void)webViewDidFinishLoad:(UIWebView *)webView</div><div class="line">&#123;</div><div class="line">    [self.webView stringByEvaluatingJavaScriptFromString:[self loadJsFile:@&quot;test&quot;]];</div><div class="line"></div><div class="line">&#125;</div><div class="line">- (NSString *)loadJsFile:(NSString*)fileName</div><div class="line">&#123;</div><div class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;js&quot;];</div><div class="line">    NSString *jsScript = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];</div><div class="line">    return jsScript;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在点击方法里调用这个js方法就行了，返回值即为js方法的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (IBAction)click:(id)sender</div><div class="line">&#123;</div><div class="line">    //     OC 调用 JS</div><div class="line">    //    在OC中通过代码调用JS中名为calculate的方法,并传入两个参数</div><div class="line">    NSString *string =  [self.webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@&quot;calculate(&apos;%d&apos;,&apos;%d&apos;)&quot;,1,2]];</div><div class="line">    </div><div class="line">    NSLog(@&quot;resultString: %@&quot;,string);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="JS调用OC"><a href="#JS调用OC" class="headerlink" title="JS调用OC"></a>JS调用OC</h4><p>JS调用OC通过这个方法来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:</div><div class="line">(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</div></pre></td></tr></table></figure>
<p>在这个方法里，我们能拿到urlString，通过这个url进行判断来调用原生OC方法，例如，在js中，方法为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    function scanClick() &#123;</div><div class="line">        window.location.href = &quot;MyAction://scanClickOperation&quot;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    function shakeClick() &#123;</div><div class="line">    window.location.href = &quot;MyAction://shakeClickOperation&quot;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>我们通过UIWebView的代理方法，进行拦截判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//    通过 scheme 来拦截是否是自定义的 URL</div><div class="line">    if([[request.URL scheme] isEqualToString:@&quot;myaction&quot;])</div><div class="line">    &#123;</div><div class="line">        if([[request.URL host] isEqualToString:@&quot;scanClickOperation&quot;])</div><div class="line">        &#123;</div><div class="line">            NSLog(@&quot;扫一扫&quot;);</div><div class="line">        &#125;</div><div class="line">        if([[request.URL host] isEqualToString:@&quot;shakeClickOperation&quot;])</div><div class="line">        &#123;</div><div class="line">            NSLog(@&quot;摇一摇&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">    </div><div class="line">////    也可以通过这种方式来</div><div class="line">//    if([request.URL.absoluteString rangeOfString:@&quot;scanClickOperation&quot;].location != NSNotFound)</div><div class="line">//    &#123;</div><div class="line">//        NSLog(@&quot;扫一扫&quot;);</div><div class="line">//    &#125;</div></pre></td></tr></table></figure>
<p>GitHub上demo给的很详细，大家可以下载下来看下。</p>
<h3 id="二、WebViewJavascriptBridge"><a href="#二、WebViewJavascriptBridge" class="headerlink" title="二、WebViewJavascriptBridge"></a>二、WebViewJavascriptBridge</h3><p><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>是一个用于OC与JS交互第三方库，在GitHub上有8000多的star，它的原理也是通过shouldStartLoadWithRequest 这个代理方法，对url进行判断来实现的。接下来我们看看这个库怎么用。</p>
<p>初始化UIWebView的时候，不要为UIWebView设置代理为self，这个库的内部会自动为其设置代理，假如我们还是想在本类调用UIWebView的代理方法，WebViewJavascriptBridge有专门的API来调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//这里不要为UIWebView设置代理 UIWebView的代理被赋值给WebViewJavascriptBridge。</div><div class="line">UIWebView *webView = [[UIWebView alloc] initWithFrame:self.view.bounds];</div><div class="line">[webView loadHTMLString:appHtml baseURL:url];</div><div class="line">[self.view addSubview:webView];</div><div class="line">self.webView = webView;</div><div class="line"></div><div class="line">WebViewJavascriptBridge *webViewBridge = [WebViewJavascriptBridge bridgeForWebView:webView];</div><div class="line">//将UIWebView的代理，从webViewBridge中再传递出来。意思是假如你要在控制器中实现UIWebView的代理方法时，添加下面这样代码</div><div class="line">[webViewBridge setWebViewDelegate:self];</div><div class="line">self.webViewBridge = webViewBridge;</div></pre></td></tr></table></figure>
<p>任何有关方法的调用，必须经过下面的js注册，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*这段代码是固定的，必须要放到js中*/</div><div class="line">function setupWebViewJavascriptBridge(callback) &#123;</div><div class="line">  if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</div><div class="line">  if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</div><div class="line">  window.WVJBCallbacks = [callback];</div><div class="line">  var WVJBIframe = document.createElement(&apos;iframe&apos;);</div><div class="line">  WVJBIframe.style.display = &apos;none&apos;;</div><div class="line">  WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</div><div class="line">  document.documentElement.appendChild(WVJBIframe);</div><div class="line">  setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比较蛋疼，也是特别要注意的地方。</p>
<h4 id="OC调用JS-1"><a href="#OC调用JS-1" class="headerlink" title="OC调用JS"></a>OC调用JS</h4><p>OC调用JS的方法比较简单，调用分几种：</p>
<p>1.直接调用，无参数无回调</p>
<p>2.有参数，有回调</p>
<p>3.有多个参数，有回调</p>
<p>Demo中都给出了这几种的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 不传参数，直接调用，无回调</div><div class="line">[self.webViewBridge callHandler:@&quot;myOperation&quot;];</div><div class="line"></div><div class="line">// 传参数 有回调</div><div class="line">[self.webViewBridge callHandler:@&quot;factorial&quot; data:@(4) responseCallback:^(id responseData) &#123;</div><div class="line">    NSLog(@&quot;OC端得到responseData: %@&quot;,responseData);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 传参数 有回调</div><div class="line">NSArray *array = @[@(1),@(2)];</div><div class="line">[self.webViewBridge callHandler:@&quot;calculate&quot; data:array responseCallback:^(id responseData) &#123;</div><div class="line">    NSLog(@&quot;OC端得到responseData: %@&quot;,responseData);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>因为这三个方法，在html文件中，js自己调用 setupWebViewJavascriptBridge 这个方法了，所有不需要在OC代码中进行register，注意这里的方法名，一定要和js中的方法名相同。</p>
<h4 id="JS调用OC-1"><a href="#JS调用OC-1" class="headerlink" title="JS调用OC"></a>JS调用OC</h4><p>使用 WebViewJavascriptBridge 这个类的 <code>registerHandler</code> 方法进行注册，在block里我们可以使用JS传给OC的参数，及再回调给JS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[self.webViewBridge registerHandler:@&quot;changeColor&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">    </div><div class="line">    //data就是JS传给OC的参数</div><div class="line">    NSDictionary *tempDic = data;</div><div class="line">    CGFloat r = [[tempDic objectForKey:@&quot;r&quot;] floatValue];</div><div class="line">    CGFloat g = [[tempDic objectForKey:@&quot;g&quot;] floatValue];</div><div class="line">    CGFloat b = [[tempDic objectForKey:@&quot;b&quot;] floatValue];</div><div class="line">    CGFloat a = [[tempDic objectForKey:@&quot;a&quot;] floatValue];</div><div class="line">    </div><div class="line">    self.webView.scrollView.backgroundColor = [UIColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:a];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line">[self.webViewBridge registerHandler:@&quot;JS调用OC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">    </div><div class="line">    //data就是JS传给OC的参数</div><div class="line">    NSLog(@&quot;data from JS ：%@&quot;, data);</div><div class="line">    </div><div class="line">    if (responseCallback) &#123;</div><div class="line">        </div><div class="line">        //OC反馈给JS</div><div class="line">        responseCallback(@&quot;我是OC传给JS的数据&quot;);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="二、JavaScriptCore"><a href="#二、JavaScriptCore" class="headerlink" title="二、JavaScriptCore"></a>二、JavaScriptCore</h3><p>JavaScriptCore框架是iOS 7中加入的，该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。在项目中引入JavaScriptCore后，链到头文件中，除了大段的Copyright注释可以看到里面只要引入了5个文件，每个文件里都定义跟文件名对应的类。总的来说，JavaScriptCore的使用相对简单，也很方便</p>
<p>JSContext是JavaScript的运行环境，通过jSCore执行的JS代码都得通过JSContext来执行，相当于HTML中&lt; JavaScript &gt;之间的内容。</p>
<p>JSValue是JSContext的返回结果，他对数据类型进行了封装，并且为JS和OC的数据类型之间的转换提供了方法。</p>
<p>JSManagedValue是JSValue的封装，用它可以解决JS和原生代码之间循环引用的问题。</p>
<p>JSVirtualMachine 管理JS运行时和管理JS暴露的OC对象的内存,是JSContext的容器，可以包含若干个JSContext，在一个进程中，你可以有多个JSVirtualMachine，里面包含着若干个JSContext，而JSContext中又有若干个JSValue</p>
<p>JSExport是一个协议，通过实现它可以把一个OC对象暴漏给JS，这样JS就可以调用这个对象暴露的方法。</p>
<p>JavaScriptCore对于JS与OC的交互有两种方式，一种是使用JSExport，另一种是使用block形式。下面只介绍了使用block来进行交互</p>
<h4 id="JS调用OC-2"><a href="#JS调用OC-2" class="headerlink" title="JS调用OC"></a>JS调用OC</h4><p>先在 <code>viewDidLoad</code> 方法里创建 JSContext 对象，注入JS方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 初始化 JSContext 对象</div><div class="line">self.OCCallJScontext = [[JSContext alloc] init];</div><div class="line"></div><div class="line">NSString *jsPath = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;js&quot;];</div><div class="line">NSString *jsScript = [NSString stringWithContentsOfFile:jsPath encoding:NSUTF8StringEncoding error:nil];</div><div class="line"> [self.OCCallJScontext evaluateScript:jsScript];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (IBAction)click:(id)sender</div><div class="line">&#123;</div><div class="line">    JSValue *function = [self.OCCallJScontext objectForKeyedSubscript:@&quot;calculate&quot;];</div><div class="line">    </div><div class="line">    // 3 + 4</div><div class="line">    JSValue *result = [function callWithArguments:@[@(3),@(4)]];</div><div class="line">    </div><div class="line">    NSLog(@&quot;通过js方法计算两数之和为 %@&quot;,[result toString]);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>calculate</code> 方法是和H5同事约定好的，调用方法的字符串。</p>
<h4 id="OC调用JS-2"><a href="#OC调用JS-2" class="headerlink" title="OC调用JS"></a>OC调用JS</h4><p>首先在<code>webViewDidFinishLoad</code> 方法里获取到 JSContext 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.JSCallOCcontext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</div></pre></td></tr></table></figure>
<p>假如我们在js中，对button绑定了一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button onclick=&quot;methodA()&quot;&gt;不传参数&lt;/button&gt;</div></pre></td></tr></table></figure>
<p>当我们点击网页中的这个button的时候，让它调用原生的方法，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">self.JSCallOCcontext[@&quot;methodA&quot;] =</div><div class="line">^()</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;直接调用不传参数&quot;);</div><div class="line">    // 可以写自己的方法</div><div class="line">    // [self customMethod];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个方法是不传参数给OC的，假如JS要传参数给OC，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button onclick=&quot;methodB(&apos;我是参数&apos;)&quot;&gt;传参数&lt;/button&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">self.JSCallOCcontext[@&quot;methodB&quot;] =</div><div class="line">^(NSString *str)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;得到JS的参数为 %@&quot;,str);</div><div class="line">    // 可以写自己的方法</div><div class="line">    // [self customMethod];</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在block里写对应的原生方法，假如要把结果回调给JS，可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button onclick=&quot;methodD(&apos;我是参数&apos;)&quot;&gt;有返回&lt;/button&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    // 并将值返回给js</div><div class="line">__weak ViewController *weakSelf = self;</div><div class="line">self.JSCallOCcontext[@&quot;methodD&quot;] =</div><div class="line">^(NSString *str)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;得到JS的参数为 %@&quot;,str);</div><div class="line">    str = [NSString stringWithFormat:@&quot;呵呵哒%@&quot;,str];</div><div class="line">    JSValue *callback = weakSelf.JSCallOCcontext[@&quot;callback&quot;];</div><div class="line">    [callback callWithArguments:@[str]];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里要注意循环引用问题。</p>
<p>三种交互方法对比：</p>
<p>如果仅仅是简单的交互，直接在UIWebVIew的代理方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:</div><div class="line">(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</div></pre></td></tr></table></figure>
<p>实现功能即可。如果交互比较复杂，建议使用JavaScriptCore，WebViewJavascriptBridge这个库用起来比较麻烦，我当时也是看了一段时间才看明白，JavaScriptCore用起来还是很方便的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/29/自定义转场动画/" itemprop="url">
                  自定义转场动画
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-29T21:02:39+08:00" content="2017-04-29">
              2017-04-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/29/自定义转场动画/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/29/自定义转场动画/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/04/29/自定义转场动画/" class="leancloud_visitors" data-flag-title="自定义转场动画">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近详细学习了关于转场动画的知识，通过一些API可以帮助我们实现炫酷的转场动画，先直接上Demo:<a href="https://github.com/coderZhou10496/TransitionDemo" target="_blank" rel="external">Github地址</a>，下面的转场动画都是自定义的动画</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB.gif" alt="image"></p>
<p>先来了解一下转场动画所需要的几个protocol</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/TransitionPic.png" alt="image"></p>
<p>我们一一简单了解下这些类是干嘛用的：</p>
<blockquote>
<p><code>UINavigationControllerDelegate</code></p>
</blockquote>
<p>这个delegate主要有一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                   animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                                fromViewController:(UIViewController *)fromVC</div><div class="line">                                                  toViewController:(UIViewController *)toVC</div></pre></td></tr></table></figure></p>
<p>自定义 push pop 动画时要实现这个方法，这个方法需要我们提供一个实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象。</p>
<blockquote>
<p><code>UIViewControllerTransitioningDelegate</code></p>
</blockquote>
<p>这个delegate 用于实现自定义的 present diss 动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:</div><div class="line">(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</div></pre></td></tr></table></figure>
<p>这个方法也需要我们提供一个实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象。</p>
<blockquote>
<p><code>UIViewControllerInteractiveTransitioning</code></p>
</blockquote>
<p>这个protocol是跟手势交互相关的。比如需要通过手势来返回到上一界面，就要返回实现了这个protocol的对象</p>
<blockquote>
<p><code>UIViewControllerAnimatedTransitioning</code> </p>
</blockquote>
<p> 这个protocol就是用于实现动画效果的protocol了，其中有两个必须实现的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</div><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</div></pre></td></tr></table></figure>
<p>第一个方法返回动画所需要的时间，第二个方法就是动画的具体实现</p>
<blockquote>
<p><code>UIViewControllerContextTransitioning</code></p>
</blockquote>
<p>这个protocol提供我们动画的具体实现所需要的元素，比如这些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)viewControllerForKey:(UITransitionContextViewControllerKey)</div><div class="line">- ( UIView *)viewForKey:(UITransitionContextViewKey)</div><div class="line">- (UIView *)containerView</div></pre></td></tr></table></figure>
<p>通过 UITransitionContextViewControllerKey 获得 动画所需要的 fromVc toVc，通过UITransitionContextViewKey 获得 动画所需要的 fromView toView 等等。</p>
<p>接下来就是实战了，主要是对一系列过程的封装。我采用了类别的方式，对 UINavigationController 增加了一个属性，即 push 的动画方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger,ZJNavigationTransitioningStyle)&#123;</div><div class="line">    ZJNavigationTransitioningStyleSystem,</div><div class="line">    ZJNavigationTransitioningStyleRound,</div><div class="line">    ZJNavigationTransitioningStyleScale,</div><div class="line">    ZJNavigationTransitioningStyleLeftSunken,</div><div class="line">    ZJNavigationTransitioningStyleRotate</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface UINavigationController (ZJTransitioning)</div><div class="line">@property (nonatomic,assign) ZJNavigationTransitioningStyle transitioningStyle;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当我们 push 的时候 ，只需为这个属性赋值就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ResultViewController *controller = [[ResultViewController alloc] init];</div><div class="line">self.navigationController.transitioningStyle = ZJNavigationTransitioningStyleSystem;</div><div class="line">[self.navigationController pushViewController:controller animated:YES];</div></pre></td></tr></table></figure>
<p>下面我们对其中一种动画方式 ZJNavigationTransitioningStyleScale ，详细描述实现过程 </p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/scale.gif" alt="image"></p>
<p>在 UINavigationController (ZJTransitioning) 这个类别的 .m 实现文件中，我们将 UINavigationController 的 delegate 方法用 ZJNavigationDelegateMediator 这个类来接收，意思就是 <code>@protocol UINavigationControllerDelegate &lt;NSObject&gt;</code>里的方法，在 ZJNavigationDelegateMediator 类里面来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">-(void)viewDidLoad</div><div class="line">&#123;</div><div class="line">//    将delegate 设置为 ZJNavigationDelegateMediator 对象，在 ZJNavigationDelegateMediator 类里实现</div><div class="line">//    UINavigationControllerDelegate的方法</div><div class="line">    self.delegate = self.mediator;</div><div class="line">&#125;</div><div class="line">-(ZJNavigationTransitioningStyle)transitioningStyle</div><div class="line">&#123;</div><div class="line">    return self.mediator.transitioningStyle;</div><div class="line">&#125;</div><div class="line">-(void)setTransitioningStyle:(ZJNavigationTransitioningStyle)transitioningStyle</div><div class="line">&#123;</div><div class="line">    self.mediator.transitioningStyle = transitioningStyle;</div><div class="line">&#125;</div><div class="line">-(ZJNavigationDelegateMediator *)mediator</div><div class="line">&#123;</div><div class="line">    ZJNavigationDelegateMediator *mediator = objc_getAssociatedObject(self, &amp;ZJTransitioningMediator_key);</div><div class="line">    if(mediator == nil)</div><div class="line">    &#123;</div><div class="line">        mediator = [[ZJNavigationDelegateMediator alloc] init];</div><div class="line">        self.mediator = mediator;</div><div class="line">    &#125;</div><div class="line">    return mediator;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)setMediator:(ZJNavigationDelegateMediator *)mediator</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(self, &amp;ZJTransitioningMediator_key, mediator, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ZJNavigationDelegateMediator 类里也定义了一个 ZJNavigationTransitioningStyle 的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface ZJNavigationDelegateMediator : NSObject&lt;UINavigationControllerDelegate&gt;</div><div class="line">@property (nonatomic,assign) ZJNavigationTransitioningStyle transitioningStyle;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>设置完<code>self.navigationController.transitioningStyle</code>后，所有的操作都转交给 ZJNavigationDelegateMediator，返回的动画方式的对象，以及动画对象的管理，也是在这个类里实现。</p>
<p>下面是实现 UINavigationControllerDelegate 的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                  animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                               fromViewController:(UIViewController *)fromVC</div><div class="line">                                                 toViewController:(UIViewController *)toVC</div><div class="line">&#123;</div><div class="line">    self.operation = operation;</div><div class="line">    if(self.transitioningStyle == ZJNavigationTransitioningStyleRound)</div><div class="line">    &#123;</div><div class="line">        return self.roundTransitioning;</div><div class="line">    &#125;</div><div class="line">    else if (self.transitioningStyle == ZJNavigationTransitioningStyleScale)</div><div class="line">    &#123;</div><div class="line">        return self.scaleTransitioning;</div><div class="line">    &#125;</div><div class="line">    else if (self.transitioningStyle == ZJNavigationTransitioningStyleLeftSunken)</div><div class="line">    &#123;</div><div class="line">        return self.leftSunkenTransitioning;</div><div class="line">    &#125;</div><div class="line">    else if (self.transitioningStyle == ZJNavigationTransitioningStyleRotate)</div><div class="line">    &#123;</div><div class="line">        return self.rotateTransitioning;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>选择了哪种动画方式，就返回相应的 AnimatedTransitioning 对象，并将以何种方式进行页面切换 即是 push 还是 pop 也传到 AnimatedTransitioning 对象里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(ZJScaleAnimatedTransitioning *)scaleTransitioning</div><div class="line">&#123;</div><div class="line">    if(_scaleTransitioning == nil)</div><div class="line">    &#123;</div><div class="line">        _scaleTransitioning = [[ZJScaleAnimatedTransitioning alloc] init];</div><div class="line">    &#125;</div><div class="line">    _scaleTransitioning.operation = self.operation;</div><div class="line">    return _scaleTransitioning;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的动画对象，都继承自 ZJBaseAnimatedTransitioning，这个类 实现 <code>@protocol UIViewControllerAnimatedTransitioning &lt;NSObject&gt;</code>这个动画 protocol。</p>
<p>由于 动画方式 为 ZJNavigationTransitioningStyleScale 的时候，需要得到 push 前图片的位置信息，以及 push 后图片的位置信息 ，所以我声明了protocol，用来得到这些信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 此协议是为了得到push方式为 ZJNavigationTransitioningStyleRound 和 ZJNavigationTransitioningStyleScale 的图片的相关信息</div><div class="line"> */</div><div class="line">@protocol ZJTransitioningProtocol &lt;NSObject&gt;</div><div class="line">-(NSDictionary *)getTransitioningInfoWithTransitioning:(id &lt;UIViewControllerAnimatedTransitioning&gt;)transitioning;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在 <code>@protocol UIViewControllerAnimatedTransitioning &lt;NSObject&gt;</code> 实现方法里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</div></pre></td></tr></table></figure>
<p>我们去写实际动画相关的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</div><div class="line">UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</div><div class="line">UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey];</div><div class="line">UIView *containerView = [transitionContext containerView];</div></pre></td></tr></table></figure>
<p>在本例中，当为 push 操作时，fromVC 为 TableViewController，toVC 为 ImageViewController。而当为 pop 操作时，fromVC 为 ImageViewController，toVC 为 TableViewController，这一点千万要注意，是相反的。</p>
<p>先通过自己定义的 ZJTransitioningProtocol 得到图片的位置信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">UIImageView *fromImageView = nil;</div><div class="line">UIImageView *toImageView = nil;</div><div class="line">CGRect fromRect = CGRectZero ;</div><div class="line">CGRect ToRect = CGRectZero;</div><div class="line">if([fromVC respondsToSelector:@selector(getTransitioningInfoWithTransitioning:)])</div><div class="line">&#123;</div><div class="line">    NSDictionary *dic = [(id &lt;ZJTransitioningProtocol&gt;)fromVC getTransitioningInfoWithTransitioning:self];</div><div class="line">    fromImageView = dic[@&quot;imageView&quot;];</div><div class="line">    fromRect = CGRectFromString(dic[@&quot;frame&quot;]);</div><div class="line"> &#125;</div><div class="line">  if([toVC respondsToSelector:@selector(getTransitioningInfoWithTransitioning:)])</div><div class="line"> &#123;</div><div class="line">     NSDictionary *dic = [(id &lt;ZJTransitioningProtocol&gt;)toVC getTransitioningInfoWithTransitioning:self];</div><div class="line">     toImageView = dic[@&quot;imageView&quot;];</div><div class="line">     oRect = CGRectFromString(dic[@&quot;frame&quot;]);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 将 toView 加入到 containerView 的时候，当为 pop 操作时，注意为</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[containerView insertSubview:toView belowSubview:fromView];</div></pre></td></tr></table></figure>
<p> 上面都是准备操作，下面到了实际的动画操作</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIImageView *imageView = [self copyOfImageView:toImageView];</div><div class="line">imageView.frame = fromRect;</div><div class="line">[[UIApplication sharedApplication].keyWindow addSubview:imageView];</div><div class="line">fromImageView.hidden = YES;</div><div class="line">toImageView.hidden = YES;</div></pre></td></tr></table></figure>
<p>加一个过渡的imageView 加在 window 上 ，用imageView的坐标的变化实现动画效果，动画结束后移除此过渡imageView，并将先将原来的fromImageView toImageView隐藏.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0.0 options:UIViewAnimationOptionCurveEaseOut animations: ^&#123;</div><div class="line">   // 动画阴影效果</div><div class="line">    maskViewForFromView.alpha = maskViewAlpha;</div><div class="line">    maskViewForToView.alpha = 0.0;</div><div class="line">    </div><div class="line">    toView.frame = finalFrameForToVC;</div><div class="line">    if (self.operation == UINavigationControllerOperationPush)</div><div class="line">    &#123;</div><div class="line">        CGRect frame = fromView.frame;</div><div class="line">        frame.origin.x = frame.origin.x - frame.size.width / 3.0;</div><div class="line">        fromView.frame = frame;</div><div class="line">    &#125;</div><div class="line">    else if (self.operation == UINavigationControllerOperationPop)</div><div class="line">    &#123;</div><div class="line">        CGRect frame = fromView.frame;</div><div class="line">        frame.origin.x = frame.origin.x + frame.size.width;</div><div class="line">        fromView.frame = frame;</div><div class="line">    &#125;</div><div class="line">    imageView.frame = ToRect;</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">    [maskViewForFromView removeFromSuperview];</div><div class="line">    [maskViewForToView removeFromSuperview];</div><div class="line"></div><div class="line">    fromImageView.hidden = NO;</div><div class="line">    toImageView.hidden = NO;</div><div class="line">    [imageView removeFromSuperview];</div><div class="line">    [transitionContext completeTransition:!transitionContext.transitionWasCancelled];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>代码很好理解，在 fromView toView 上都加了过渡的阴影view，动画的过程中将 maskViewForFromView 的 alpha 增加，将 maskViewForToView 的 alpha 减小至0，动画结束后移除此阴影view。切换方式为 push pop时，分别设置 fromView.frame ，完成动画效果。最后，一定不要忘了设置这句代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[transitionContext completeTransition:!transitionContext.transitionWasCancelled];</div></pre></td></tr></table></figure>
<p>这是为了告诉系统，动画已经完成，这是系统为自动帮我们移除 fromView.</p>
<p>关于其他动画方式的具体实现，有兴趣的可以到Github上下载，都有注释，很好理解</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/04/关于__block的实现原理/" itemprop="url">
                  __block实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-04T19:04:46+08:00" content="2017-04-04">
              2017-04-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/04/关于__block的实现原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/04/关于__block的实现原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/04/04/关于__block的实现原理/" class="leancloud_visitors" data-flag-title="__block实现原理">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前面试的时候，面试官问到过这个问题, <code>__block</code>修饰的对象在 ARC 下和非ARC下有何不同？为什么在 ARC 环境下，<code>__block</code> 修饰对象解决不了循环引用，只能用 __weak? 之前了解的不够全面，今天来深入探讨下。</p>
<h3 id="block修饰基本常量"><a href="#block修饰基本常量" class="headerlink" title="__block修饰基本常量"></a>__block修饰基本常量</h3><p>首先，对于基本常量，我们来写下测试代码，声明一个两个 int 类型常量，一个加 __block 修饰符，一个不加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int value = 1;</div><div class="line">        __block int block_value = 1;</div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            NSLog(@&quot;value:%d block_value:%d&quot;,value,block_value);</div><div class="line">        &#125;;</div><div class="line">        value++;</div><div class="line">        block_value++;</div><div class="line">        myBlock();</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>clang 后源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_block_value_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_block_value_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int block_value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int value;</div><div class="line">  __Block_byref_block_value_0 *block_value; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _value, __Block_byref_block_value_0 *_block_value, int flags=0) : value(_value), block_value(_block_value-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_block_value_0 *block_value = __cself-&gt;block_value; // bound by ref</div><div class="line">  int value = __cself-&gt;value; // bound by copy</div><div class="line"></div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_f4_lvvgftyd48vbb5hbcyk0y1900000gn_T_main_13a5e9_mi_0,value,(block_value-&gt;__forwarding-&gt;block_value));</div><div class="line">        &#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;block_value, (void*)src-&gt;block_value, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;block_value, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line">        int value = 1;</div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_block_value_0 block_value = &#123;(void*)0,(__Block_byref_block_value_0 *)&amp;block_value, 0, sizeof(__Block_byref_block_value_0), 1&#125;;</div><div class="line">        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, value, (__Block_byref_block_value_0 *)&amp;block_value, 570425344));</div><div class="line">        value++;</div><div class="line">        (block_value.__forwarding-&gt;block_value)++;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咋一看，这么多代码，有点头疼，没事我们慢慢分析，首先看这一段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line">        int value = 1;</div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_block_value_0 block_value = &#123;(void*)0,(__Block_byref_block_value_0 *)&amp;block_value, 0, sizeof(__Block_byref_block_value_0), 1&#125;;</div><div class="line">        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, value, (__Block_byref_block_value_0 *)&amp;block_value, 570425344));</div><div class="line">        value++;</div><div class="line">        (block_value.__forwarding-&gt;block_value)++;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>int value = 1，这行代码没变，clang 后还是这行。倒是 <code>__block int block_value</code> = 1;这句代码，被转化成了 <code>__Block_byref_block_value_0</code> 类型的结构体。结构体里有5个成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_block_value_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_block_value_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int block_value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意，这个结构体包含了该实例本身的引用__forwarding，再看下面这行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, value, (__Block_byref_block_value_0 *)&amp;block_value, 570425344))</div></pre></td></tr></table></figure>
<p><code>__main_block_impl_0</code> 为 myBlock 的构造体函数，其中传入的参数具体为：</p>
<p><code>__main_block_func_0</code> ：包含了block内部的代码，在我们的例子中，就是 NSLog(@”value:%d block_value:%d”,value,block_value)；</p>
<p><code>__main_block_desc_0_DATA</code>：block的内存管理相关信息；</p>
<p><code>value</code>：即，传入的 value；</p>
<p><code>block_value</code>：被转化后的 __Block_byref_block_value_0类型的block_value。</p>
<p>当我们在 block 内部用到外部变量值的时候，在本例中就是 NSLog的时候，对于没有 __block修饰的 value 常量，直接通过自身，访问 value的值，得到最原始的值，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int value = __cself-&gt;value;</div></pre></td></tr></table></figure>
<p>关于为什么不能再 block 内部改变外部常量的值，是因为，int value变量定义在栈上，在block调用时已经被销毁，但是我们还能在block内部访问这个值，显然是被 copy 进了block内部。就算我可以在block内部重新设置 value的值，但是当我在 block内 NSlog(@”%d”,value)得到value值得时候，是通过 <code>__cself-&gt;value</code> 得到的，还是当初 copy进来的那个值。所以说，在block 内部重新改变外部 value值是做不到的，既然做不到，那干脆编译器不让我们这么写。所以说，在 block 内部设置外部变量的值得时候，编译器会给错误提示。<br>对于__block修饰的常量，是通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__Block_byref_block_value_0 *block_value = __cself-&gt;block_value; // bound by ref;</div><div class="line">block_value-&gt;__forwarding-&gt;block_value</div></pre></td></tr></table></figure>
<p>这样得到的。那么问题来了<code>__Block_byref_block_value_0</code> 结构体内部不是有一个成员变量 block_value 吗，直接访问不就好了，为什么还要通过自身引用 <code>__forwarding-&gt;block_value</code>这样得到呢？</p>
<p>先来了解一下关于 block 的类型：block一共有3种类型的block</p>
<p>_NSGlobalBlock 全局静态</p>
<p>_NSStackBlock 保存在栈中，出函数作用域就销毁</p>
<p>_NSMallocBlock 保存在堆中，retainCount == 0销毁</p>
<p>ARC环境下，一旦Block赋值就会触发copy，<code>__block</code>修饰的对象就会copy到堆上，Block也是<strong>NSMallocBlock。<br>MRC环境下，只有copy，`</strong>block<code>才会被复制到堆上，否则，</code><strong>block`一直都在栈上，block也只是</strong>NSStackBlock。</p>
<p>回到刚才的 <code>__forwarding-&gt;block_value</code>问题上，在上面的示例代码中，由于在 ARC 下进行，所以，block为 <code>__NSMallocBlock</code>，<code>__forwarding</code>指向自己。但是在 MRC 下，这样的代码示例，这个block 是 <code>_NSStackBlock</code>，只有被 copy 后才是 <code>__NSMallocBlock</code>。</p>
<p>通过<code>__forwarding-&gt;block_value</code>这样访问，正是考虑到了ARC 与 MRC的情况，当一个Block被复制到堆上时，与之相关的<code>__block</code>变量也会被复制到堆上，此时堆上的Block持有相应堆上的<code>__block</code>变量，而在栈上的<code>__block</code>变量被复制到堆上之后，会将成员变量<code>__forwarding</code>的值替换为堆上的<code>__block</code>变量的地址。这个时候我们可以通过代码访问：<code>__forwarding-&gt;block_value</code>。这里的两张图非常经典：</p>
<p>_NSMallocBlock:</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/blockTest_Stack.jpg" alt="image"></p>
<p>_NSStackBlock -&gt; _NSMallocBlock:</p>
<p><img src="http://ocauxqtbu.bkt.clouddn.com/blockTest_Malloc.jpg" alt="image"></p>
<h3 id="block修饰对象"><a href="#block修饰对象" class="headerlink" title="__block修饰对象"></a>__block修饰对象</h3><p>直接上代码，MRC 下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        // MRC下</div><div class="line">        NSObject *obj =[[NSObject alloc] init];</div><div class="line">        __block NSObject *blockObj =[[NSObject alloc] init];</div><div class="line">        </div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            NSLog(@&quot;%d %d&quot;,(int)obj.retainCount,(int)blockObj.retainCount);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，block内部 obj,和<code>__block</code>修饰下的 blockObj 的 retainCount 为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-04-05 15:50:22.732 BlockTest[4240:1342091] 1 1</div></pre></td></tr></table></figure>
<p>可以看出来，此时 block 为栈block, obj 和 blockObj 的引用计数都没有增加。但是当我将这个block copy之后，见代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSObject *obj =[[NSObject alloc] init];</div><div class="line"> __block NSObject *blockObj =[[NSObject alloc] init];</div><div class="line">      </div><div class="line">      void(^myBlock)(void) = ^&#123;</div><div class="line">          NSLog(@&quot;%d %d&quot;,(int)obj.retainCount,(int)blockObj.retainCount);</div><div class="line">      &#125;;</div><div class="line">      [myBlock copy];</div><div class="line">      myBlock();</div></pre></td></tr></table></figure>
<p>此时，此时 block 为堆block， retainCount 为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-04-05 15:55:22.732 BlockTest[4240:1342091] 2 1</div></pre></td></tr></table></figure>
<p>即 myBlock 强引用了 obj。这也印证了 ARC 下，block 会强引用内部使用的对象，因为在ARC环境下，我们对 block 进行赋值时，block 会自动copy，转为 <code>_NSMallocBlock</code>，所以会强引用内部对象。</p>
<p>在 ARC 下，clang 源码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_blockObj_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_blockObj_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</div><div class="line"> void (*__Block_byref_id_object_dispose)(void*);</div><div class="line"> NSObject *blockObj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  NSObject *obj;</div><div class="line">  __Block_byref_blockObj_0 *blockObj; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSObject *_obj, __Block_byref_blockObj_0 *_blockObj, int flags=0) : obj(_obj), blockObj(_blockObj-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_blockObj_0 *blockObj = __cself-&gt;blockObj; // bound by ref</div><div class="line">  NSObject *obj = __cself-&gt;obj; // bound by copy</div><div class="line"></div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_f4_lvvgftyd48vbb5hbcyk0y1900000gn_T_main_0bbf21_mi_0,obj ,(blockObj-&gt;__forwarding-&gt;blockObj));</div><div class="line">        &#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;obj, (void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;blockObj, (void*)src-&gt;blockObj, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;blockObj, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line"></div><div class="line">        NSObject *obj =((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_blockObj_0 blockObj = &#123;(void*)0,(__Block_byref_blockObj_0 *)&amp;blockObj, 33554432, sizeof(__Block_byref_blockObj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;))&#125;;</div><div class="line"></div><div class="line">        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, obj, (__Block_byref_blockObj_0 *)&amp;blockObj, 570425344));</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 obj 和 blockObj 的处理方法与处理常量大径相同，被 <code>__block</code>修饰的对象会被转为 <code>__Block_byref_blockObj_0</code> 结构体类型的对象，这个对象一样强引用着blockObj。就是说，block 会 一直持有被<code>__block</code>修饰的对象，直到 block 对象从堆上销毁。 所以，在ARC 下，<code>__block</code>修饰的对象，不会解决循环引用问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/27/Runtime学习之二：消息的传递与转发/" itemprop="url">
                  Runtime学习之二：消息的传递与转发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-27T22:22:26+08:00" content="2017-03-27">
              2017-03-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/27/Runtime学习之二：消息的传递与转发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/27/Runtime学习之二：消息的传递与转发/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/03/27/Runtime学习之二：消息的传递与转发/" class="leancloud_visitors" data-flag-title="Runtime学习之二：消息的传递与转发">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>消息机制是 Runtime 中最吸引人的地方，为什么说 OC 是一门动态语言，就是因为 OC 上所有的方法调用都是在运行时进行。就是说，向对象发送方法，就会使用动态绑定机制来决定需要调用的方法，这与 C 语言中调用方式完全不同，C 语言使用的是静态绑定，即在编译期就决定了运行时所调用的函数。今天我们就详细来看下 Runtime 的消息机制。</p>
<h3 id="一-、消息的传递"><a href="#一-、消息的传递" class="headerlink" title="一 、消息的传递"></a>一 、消息的传递</h3><p> 消息的传递，简单来说，就是 Runtime 通过 selector 查找 IMP 的过程，有了 IMP 这个函数指针之后就可以执行对应的函数实现</p>
<h4 id="1-1-objc-msgSend"><a href="#1-1-objc-msgSend" class="headerlink" title="1.1 objc_msgSend"></a>1.1 objc_msgSend</h4><p>当你随便写下一段函数调用的代码后，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[receiver message];</div></pre></td></tr></table></figure>
<p> 都会被编译器转化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSend(id self, SEL op, ...);</div></pre></td></tr></table></figure>
<p>Objective-C 中关于 objc_msgSend 的实现并没有开源，我们只能看到关于它的相关注释，在 message.h 文件里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> * @note When it encounters a method call, the compiler generates a call to one of the</div><div class="line"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.</div><div class="line"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper; </div><div class="line"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values</div><div class="line"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.</div><div class="line"> */</div><div class="line">OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)</div></pre></td></tr></table></figure>
<p> 简单翻译一下就是说，当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 objc_msgSend、objc_msgSend_stret、objc_msgSendSuper 和 objc_msgSendSuper_stret。 发送给对象的父类的消息会使用 objc_msgSendSuper 有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret 其它的消息都是使用 objc_msgSend 发送的。</p>
<p>objc_msgSend内部是用汇编写的，至于为什么用汇编写，速度快是一方面，<a href="http://arigrant.com/blog/2014/2/12/why-objcmsgsend-must-be-written-in-assembly" target="_blank" rel="external">这篇文章</a>也说了其他的原因。它针对不同架构有不同的实现，但它内部到底是怎么实现的呢？在 <a href="https://github.com/opensource-apple/objc4/blob/master/runtime/Messengers.subproj/objc-msg-x86_64.s" target="_blank" rel="external">objc-msg-x86_64.s </a>中，我们可以发现在 x86_64 架构下的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"> *</div><div class="line"> * id objc_msgSend(id self, SEL	_cmd,...);</div><div class="line"> *</div><div class="line"> ********************************************************************/</div><div class="line">	</div><div class="line">	.data</div><div class="line">	.align 3</div><div class="line">	.globl _objc_debug_taggedpointer_classes</div><div class="line">_objc_debug_taggedpointer_classes:</div><div class="line">	.fill 16, 8, 0</div><div class="line"></div><div class="line">	ENTRY	_objc_msgSend</div><div class="line">	MESSENGER_START</div><div class="line"></div><div class="line">	NilTest	NORMAL</div><div class="line"></div><div class="line">	GetIsaFast NORMAL		// r11 = self-&gt;isa</div><div class="line">	CacheLookup NORMAL		// calls IMP on success</div><div class="line"></div><div class="line">	NilTestSupport	NORMAL</div><div class="line"></div><div class="line">	GetIsaSupport	NORMAL</div><div class="line"></div><div class="line">// cache miss: go search the method lists</div><div class="line">LCacheMiss:</div><div class="line">	// isa still in r11</div><div class="line">	MethodTableLookup %a1, %a2	// r11 = IMP</div><div class="line">	cmp	%r11, %r11		// set eq (nonstret) for forwarding</div><div class="line">	jmp	*%r11			// goto *imp</div><div class="line"></div><div class="line">	END_ENTRY	_objc_msgSend</div><div class="line"></div><div class="line">	</div><div class="line">	ENTRY _objc_msgSend_fixup</div><div class="line">	int3</div><div class="line">	END_ENTRY _objc_msgSend_fixup</div><div class="line"></div><div class="line">	</div><div class="line">	STATIC_ENTRY _objc_msgSend_fixedup</div><div class="line">	// Load _cmd from the message_ref</div><div class="line">	movq	8(%a2), %a2</div><div class="line">	jmp	_objc_msgSend</div><div class="line">	END_ENTRY _objc_msgSend_fixedup</div><div class="line"></div><div class="line">	</div><div class="line">/********************************************************************</div></pre></td></tr></table></figure>
<p> 一看到汇编，好晕，不过还要硬着头皮来看下这段代码</p>
<p> <code>NilTest</code>  宏，判断被发送消息的对象是否为 nil 的。如果为 nil，那就直接返回 nil。这就是为啥也可以对 nil 发消息。</p>
<p> <code>GetIsaFast</code> 通过它的名字，我们也可以理解：快速地获取到对象的 isa 指针地址</p>
<p> <code>CacheLookup</code> 这是一个方法，它干了什么，我们可以通过它的注释来看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Locate the implementation for a class in a selector&apos;s method cache.</div></pre></td></tr></table></figure>
<p> 就是，在类的缓存中查找 selector 对应的 IMP，但是如果没有找到呢？我们继续看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// cache miss: go search the method lists</div><div class="line">LCacheMiss</div></pre></td></tr></table></figure>
<p> 就只能到 method lists 方法列表里找了</p>
<p> <code>MethodTableLookup</code> 负责在缓存没命中时在方法表中负责查找 IMP。<br> 接下来，我们具体看下 MethodTableLookup 内部是怎么实现的</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.macro MethodTableLookup</div><div class="line"></div><div class="line"> MESSENGER_END_SLOW</div><div class="line"></div><div class="line"> SaveRegisters</div><div class="line"></div><div class="line"> // _class_lookupMethodAndLoadCache3(receiver, selector, class)</div><div class="line"></div><div class="line"> movq $0, %a1</div><div class="line"> movq $1, %a2</div><div class="line"> movq %r11, %a3</div><div class="line"> call __class_lookupMethodAndLoadCache3</div><div class="line"></div><div class="line"> // IMP is now in %rax</div><div class="line"> movq %rax, %r11</div><div class="line"></div><div class="line"> RestoreRegisters</div><div class="line"></div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>这个方法里面最重要的就是调用 __class_lookupMethodAndLoadCache3 这个函数了，我们可以在 objc-runtime-new.mm 中看到它的具体实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* _class_lookupMethodAndLoadCache.</div><div class="line">* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().</div><div class="line">* This lookup avoids optimistic cache scan because the dispatcher </div><div class="line">* already tried that.</div><div class="line">**********************************************************************/</div><div class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</div><div class="line">&#123;</div><div class="line">    return lookUpImpOrForward(cls, sel, obj, </div><div class="line">                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果这个方法中又调用了 lookUpImpOrForward 这个方法，可以看到缓存参数传入为 NO ，因为之前已经查找过缓存了，没有在缓存中找到 IMP。我们再继续往下看。</p>
<p>lookUpImpOrForward 源码的具体实现太长了，所以不贴全部代码了，有感兴趣的可以自己下载看看源码。这里分模块说下，首先进行初始化，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Class curClass;</div><div class="line">IMP imp = nil;</div><div class="line">Method meth;</div><div class="line">bool triedResolver = NO;</div></pre></td></tr></table></figure>
<p>curClass 用来存放正在查找的类，imp 用来存放找到的 IMP，meth 用来存放找到的 Method，triedResolver 用来表示是否进行过动态方法解析。接下来，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runtimeLock.assertUnlocked();</div></pre></td></tr></table></figure>
<p>runtimeLock 本质上是对提供的线程读写锁 pthread_rwlock_t 的一层封装，所以这里就是加一个读写锁，保证线程安全。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> if (cache) &#123;</div><div class="line">     imp = cache_getImp(cls, sel);</div><div class="line">     if (imp) return imp;</div><div class="line"> &#125;</div><div class="line"> if (!cls-&gt;isRealized()) &#123;  </div><div class="line"> rwlock_writer_t lock(runtimeLock);</div><div class="line"> realizeClass(cls);</div><div class="line">&#125;</div><div class="line"> if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;  </div><div class="line"> _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。下面的两个判断是判断类是否载入了运行时以及是否进行了初始化，如果没有的话，会进行载入运行时操作和初始化操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runtimeLock.read();</div></pre></td></tr></table></figure>
<p>这里加了一个读锁。因为在运行时中会动态的添加方法（有 category 加入），为了保证线程安全，所以要加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Try this class&apos;s cache.</div><div class="line">imp = cache_getImp(cls, sel);</div><div class="line">if (imp) goto done;</div></pre></td></tr></table></figure>
<p>再次尝试从缓存中查找，因为加锁前可能已经有别的地方将方法的缓存加入了，如果缓存中还是没有的话，继续下面的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Try this class&apos;s method lists.</div><div class="line">meth = getMethodNoSuper_nolock(cls, sel);</div><div class="line">if (meth) &#123;</div><div class="line">    log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class="line">    imp = meth-&gt;imp;</div><div class="line">    goto done;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先使用 getMethodNoSuper_nolock(cls, sel) 在类里查找方法，如果找到了，调用 log_and_fill_cache 函数填充缓存并结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// Try superclass caches and method lists.</div><div class="line">curClass = cls;</div><div class="line">while ((curClass = curClass-&gt;superclass)) &#123;</div><div class="line">    // Superclass cache.</div><div class="line">    imp = cache_getImp(curClass, sel);</div><div class="line">    if (imp) &#123;</div><div class="line">        if (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class="line">            // Found the method in a superclass. Cache it in this class.</div><div class="line">            log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // Found a forward:: entry in a superclass.</div><div class="line">            // Stop searching, but don&apos;t cache yet; call method </div><div class="line">            // resolver for this class first.</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Superclass method list.</div><div class="line">    meth = getMethodNoSuper_nolock(curClass, sel);</div><div class="line">    if (meth) &#123;</div><div class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class="line">        imp = meth-&gt;imp;</div><div class="line">        goto done;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>往父类查找，首先现在父类的缓存中查找，找到后需要检查是否是 _objc_msgForward_impcache，这是运行时中消息转发的实现，需要先无视父类中消息转发的缓存，因为子类里可能实现了动态方法解析。找到了就把这个方法cache回自己的缓存中，然后结束。如果父类的缓存中没有，就调用 getMethodNoSuper_nolock 在父类中查找方法，找到了照样把这个方法cache回自己的缓存中，然后结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// No implementation found. Try method resolver once.</div><div class="line">if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class="line">    runtimeLock.unlockRead();</div><div class="line">    _class_resolveMethod(cls, sel, inst);</div><div class="line">    // Don&apos;t cache the result; we don&apos;t hold the lock so it may have </div><div class="line">    // changed already. Re-do the search from scratch instead.</div><div class="line">    triedResolver = YES;</div><div class="line">    goto retry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果最后都没有找到实现，那就进入动态方法解析过程。首先先判断是否开启了动态方法解析并且还没有尝试过，之后将锁打开，为什么将锁打开，是因为开发者可能会在这里动态增加方法实现，所以不需要缓存结果。调用 _class_resolveMethod，这个函数会根据 cls 是否是元类来调用我们熟知的 +resolveInstanceMethod: 或者 +resolveClassMethod。之后便重新走一遍消息发送过程（goto retry）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// No implementation found, and method resolver didn&apos;t help. </div><div class="line">// Use forwarding.</div><div class="line">imp = (IMP)_objc_msgForward_impcache;</div><div class="line">cache_fill(cls, sel, imp, inst);</div></pre></td></tr></table></figure>
<p>在缓存、当前类、父类以及 resolveInstanceMethod: 都没有解决实现查找的问题时，Objective-C 还为我们提供了最后一次翻身的机会，进行方法转发。</p>
<h3 id="二-、消息的转发"><a href="#二-、消息的转发" class="headerlink" title="二 、消息的转发"></a>二 、消息的转发</h3><p>消息的转发，就是在查找 IMP 失败后执行一系列转发流程的过程，如果不作转发处理，则会打日志和抛出异常。</p>
<p>_objc_msgForward_impcache 方法也是用汇编实现的，我们可以在<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/Messengers.subproj/objc-msg-x86_64.s" target="_blank" rel="external">objc-msg-x86_64.s </a>看下它的内部实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// _objc_msgForward_impcache is the function pointer actually stored in</div><div class="line">//   method caches.</div><div class="line">	STATIC_ENTRY	__objc_msgForward_impcache</div><div class="line">	// Method cache version</div><div class="line">	// THIS IS NOT A CALLABLE C FUNCTION</div><div class="line">	// Out-of-band condition register is NE for stret, EQ otherwise.</div><div class="line">	MESSENGER_START</div><div class="line">	nop</div><div class="line">	MESSENGER_END_SLOW</div><div class="line">	jne	__objc_msgForward_stret</div><div class="line">	jmp	__objc_msgForward</div><div class="line">	END_ENTRY	__objc_msgForward_impcache</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_objc_msgForward and _objc_msgForward_stret are the externally-callable</div><div class="line"> functions returned by things like method_getImplementation().</div></pre></td></tr></table></figure>
<p>我们通过注释也可以看到 _objc_msgForward_impcache 只是个内部的函数指针，只存储于上面提到的类的方法缓存中，需要被转化为 _objc_msgForward 和 _objc_msgForward_stret 才能被外部调用。_objc_msgForward_impcache 会根据返回值类型转化为 _objc_msgForward 或__objc_msgForward_stret。带 stret 后缀的函数依旧是返回值为结构体的版本。</p>
<p>_objc_msgForward 和 _objc_msgForward_stret 会分别调用 _objc_forward_handler 和 _objc_forward_handler_stret，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ENTRY	__objc_msgForward</div><div class="line">// Non-stret version</div><div class="line">movq	__objc_forward_handler(%rip), %r11</div><div class="line">jmp	*%r11</div><div class="line">END_ENTRY	__objc_msgForward</div><div class="line">ENTRY	__objc_msgForward_stret</div><div class="line">// Struct-return version</div><div class="line">movq	__objc_forward_stret_handler(%rip), %r11</div><div class="line">jmp	*%r11</div><div class="line">END_ENTRY	__objc_msgForward_stret</div></pre></td></tr></table></figure>
<p>接下来我们分析一下 _objc_forward_handler，继续看源码，在 objc-runtime.mm 文件中我们看到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</div><div class="line"></div><div class="line">__attribute__((noreturn)) void </div><div class="line">objc_defaultForwardHandler(id self, SEL sel)</div><div class="line">&#123;</div><div class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</div><div class="line">                &quot;(no message forward handler is installed)&quot;, </div><div class="line">                class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, </div><div class="line">                object_getClassName(self), sel_getName(sel), self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时，我们看到了比较熟悉的语句 <code>unrecognized selector sent to instance</code> ，_objc_fatal 作用就是输出日志并触发崩溃，此时崩溃就产生了。由此我们可以理解，objc_defaultForwardHandler 这个方法就是让崩溃产生的方法，我们不要让系统调用这个方法就行了，也就是消息转发。正好系统提供了方法，来设置 forward_handler 而替换到默认的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void objc_setForwardHandler(void *fwd, void *fwd_stret)</div><div class="line">&#123;</div><div class="line">    _objc_forward_handler = fwd;</div><div class="line">#if SUPPORT_STRET</div><div class="line">    _objc_forward_stret_handler = fwd_stret;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是我们设置了 ForwardHandler 之后又该干什么呢，objc_setForwardHandler 这个方法的调用栈是什么呢，这里必须要用到关于逆向的知识。大家可以看下<a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="external">这篇文章</a>，很详细。概括的说，就是：<br><code>__CF_forwarding_prep_0</code> 和 <code>__forwarding_prep_1</code> 作为参数调用 objc_setForwardHandler 方法, <code>__CF_forwarding_prep_0</code> 和 <code>__forwarding_prep_1</code> 函数都调用了 <code>__forwarding__</code>方法，<code>__forwarding__</code> 有两个参数，第一个参数为将要被转发消息的栈指针（可以简单理解成 IMP），第二个参数标记是否返回结构体。消息转发的逻辑几乎都写在 <code>__forwarding__</code>函数中了，这个函数的伪代码实现，大家可以<br><a href="http://arigrant.com/blog/2013/12/13/a-selector-left-unhandled" target="_blank" rel="external">看这里</a>。</p>
<p>1.先调用 forwardingTargetForSelector 方法获取新的 target 作为 receiver 重新执行 selector，如果返回的内容不合法（为 nil 或者跟旧 receiver 一样），那就进入第二步。</p>
<p>2.调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入第三步</p>
<p>3.调用 doesNotRecognizeSelector 方法，产生崩溃</p>
<p>至此，整个消息传递与转发流程结束。</p>
<h3 id="三-、消息转发实战练习"><a href="#三-、消息转发实战练习" class="headerlink" title="三 、消息转发实战练习"></a>三 、消息转发实战练习</h3><p>通过以上描述，我们知道了消息转发机制基本分为三个步骤：</p>
<p>1.动态方法解析</p>
<p>2.备用接受者</p>
<p>3.完整的消息转发</p>
<h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><p>对象在接收到未知的消息时，首先会调用所属类的类方法 +resolveInstanceMethod:(实例方法)或 者 +resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经 实现了该”处理方法”，只需要在运行时通过class_addMethod 函数动态添加到类里面就可以了。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface People : NSObject</div><div class="line">-(void)test;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我在People类里，.h文件声明了<code>test</code>方法，但在 .m 文件里没有实现，如果 People的实例对象调用这个方法，会发生崩溃，我们可以 + (BOOL)resolveInstanceMethod:(SEL)sel 这个方法避免, .m 文件为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#import &quot;People.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation People</div><div class="line"> //  先返回值  @: 传入的参数</div><div class="line">// v@:@    void self sel NSString  book.name = @&quot;c++ primer&quot;</div><div class="line"></div><div class="line">//@@: book.name</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    if(sel==@selector(test))</div><div class="line">    &#123;</div><div class="line">        class_addMethod(self, sel, (IMP)dynamicMethodIMP, &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line">void dynamicMethodIMP(id self, SEL _cmd)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;运行时加入的方法:%@&quot;,NSStringFromSelector(_cmd));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>外部 People 的实例对象调用 test 方法，不会产生崩溃，控制台啊输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RuntimeDemo[3672:97440] 运行时加入的方法:test</div></pre></td></tr></table></figure>
<p>不过这种方案，更多用于实现@dynamic属性。即运行时动态增加getter，setter方法。</p>
<p><code>延伸：关于&quot;v@:&quot;</code>：</p>
<p>Objective-C中的方法默认被隐藏了两个参数：self 和_cmd 。self 指向对象本身，_cmd 指向方法本身。举两个例子来说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSString *)name</div></pre></td></tr></table></figure>
<p>这个方法实际上有两个参数：self和_cmd。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)setValue:(int)val</div></pre></td></tr></table></figure>
<p>这个方法实际上有三个参数：self, _cmd和val。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)test</div></pre></td></tr></table></figure>
<p>这个方法无返回值，所以为 <code>v@:</code> ，这里的第一个字符v代表函数的返回类型是 void，后面两个个分别是self, _cmd。</p>
<h5 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h5><p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。代码如下：</p>
<p>还是一样，在People类里，.h文件声明了<code>test</code>方法，但在 .m 文件里没有实现，如果 People的实例对象调用这个方法，会发生崩溃。我 在People 类里面实现了 - (id)forwardingTargetForSelector:(SEL)aSelector 方法，另外再新建一个类 Dog，也继承自 NSObject。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;forwardingTargetForSelector&quot;);</div><div class="line">    </div><div class="line">    NSString *selectorString = NSStringFromSelector(aSelector);</div><div class="line">    </div><div class="line">    // 将消息转发给Dog类来处理</div><div class="line">    if ([selectorString isEqualToString:@&quot;test&quot;]) &#123;</div><div class="line">        return [[Dog alloc] init];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>意思就是，让 Dog类来处理这个方法，如果 Dog 类来处理这个消息，如果 Dog 也没有实现这个方法，一样会发生崩溃，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[Dog test]: unrecognized selector sent to instance 0x60800000d5f0</div></pre></td></tr></table></figure>
<p>如果实现了，就不会发生崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &quot;Dog.h&quot;</div><div class="line">@implementation Dog</div><div class="line">-(void)test</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;dog test&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RuntimeDemo[4158:111341] dog test</div></pre></td></tr></table></figure>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h5 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h5><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div></pre></td></tr></table></figure>
<p> 运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的 NSInvocation 对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标 (target) 和参数。我们可以在 forwardInvocation 方法中选择将消息转发给其它对象。 forwardInvocation:方法的实现有两个任务：</p>
<p>1.定位可以响应封装在anInvocation中的消息的对象，这个对象不需要能处理所有未知消息。</p>
<p>2.使用anInvocation作为参数，将消息发送到选中的对象</p>
<p>在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息 .</p>
<p>我们必须重写以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p> 消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象,为给定的selector提供一个合适的方法签名。具体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">-(NSString *)readWithBookName:(NSString *)nameString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p> Person类中声明了一个方法 <code>-(NSString *)readWithBookName:(NSString *)nameString;</code>，这个方法带参数，带返回值。</p>
<p> 我们在 .m 文件中实现完整消息转发的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &quot;Car.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation Person</div><div class="line"></div><div class="line"></div><div class="line">-(NSMethodSignature*)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSString *sel = NSStringFromSelector(aSelector);</div><div class="line">    if([sel isEqualToString:@&quot;readWithBookName:&quot;])</div><div class="line">    &#123;</div><div class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;];</div><div class="line">    &#125;</div><div class="line">    return [super methodSignatureForSelector:aSelector];</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    SEL selector = [anInvocation selector];</div><div class="line">    Car *c = [[Car alloc] init];</div><div class="line">    if([c respondsToSelector:selector])</div><div class="line">    &#123;</div><div class="line">        [anInvocation invokeWithTarget:c];</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p> 意思就是将这个方法转发到 Car 类中的 <code>-(NSString *)readWithBookName:(NSString *)nameString;</code> 这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface Car : NSObject</div><div class="line">-(NSString *)readWithBookName:(NSString *)nameString;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Car</div><div class="line">-(NSString *)readWithBookName:(NSString *)nameString;</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;car类中得到的nameString:%@&quot;,nameString);</div><div class="line">    return @&quot;西游记&quot;;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p> 接下来，我们在别处，别的类里面用 Person 类的实例调用这个方法，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Person *p = [[Person alloc] init];</div><div class="line">NSString *resultString = [p readWithBookName:@&quot;红楼梦&quot;];</div><div class="line">NSLog(@&quot;返回的结果为:%@&quot;,resultString);</div></pre></td></tr></table></figure>
<p>你可以发现，控制台输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2017-03-30 22:10:53.187 MyRuntimeDemo[9313:261584] car类中得到的nameString:红楼梦</div><div class="line">2017-03-30 22:10:53.187 MyRuntimeDemo[9313:261584] 返回的结果为:西游记</div></pre></td></tr></table></figure>
<p>即完成了消息的转发过程。</p>
<p>在这里介绍一下一个类 <code>NSProxy</code>,这是除了 NSObject 之外的另一个基类,这个类的官方文档为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSProxy is an abstract superclass defining an API for objects that act as stand-ins for other objects or for objects that don’t exist yet. Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create.</div></pre></td></tr></table></figure>
<p>意思就是， NSProxy是一个虚类，你可以通过继承它，并重写这两个方法以实现消息转发到另一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel;</div></pre></td></tr></table></figure>
<p>这个类除了重载消息转发机制外没有别的用法，这也是它被设计的初衷，自己什么都不干，转给代理对象就好,就是一种代理模式。NSProxy 实现了包括 NSObject 协议在内基类所需的基础方法，但是作为一个虚拟的基类并没有提供初始化的方法。它接收到任何自己没有定义的方法他都会产生一个异常，所以一个实际的子类必须提供一个初始化方法或者创建方法通过这个类可以调用其他类的方法。我们可以通过 NSProxy 实现类似于“多继承”的功能。这里我们就拿<a href="https://developer.apple.com/library/content/samplecode/ForwardInvocation/Listings/main_m.html#//apple_ref/doc/uid/DTS40008833-main_m-DontLinkElementID_4" target="_blank" rel="external">官方</a>的例子来说下：</p>
<p>新建一个类，继承自 NSProxy，并提供初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface MyProxy : NSProxy</div><div class="line">-(id)initWithTarget1:(id)target1 target2:(id)target2;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>其中target1，target2 为真正要实现方法的对象，在 .m 文件中重写必须实现的两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#import &quot;MyProxy.h&quot;</div><div class="line"></div><div class="line">@interface MyProxy()</div><div class="line"></div><div class="line">&#123;</div><div class="line">    id _target1;</div><div class="line">    id _target2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyProxy</div><div class="line">-(id)initWithTarget1:(id)target1 target2:(id)target2</div><div class="line">&#123;</div><div class="line">    _target1 = target1;</div><div class="line">    _target2 = target2;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *sig;</div><div class="line">    sig = [_target1 methodSignatureForSelector:aSelector];</div><div class="line">    if (sig) return sig;</div><div class="line">    sig = [_target2 methodSignatureForSelector:aSelector];</div><div class="line">    return sig;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</div><div class="line">    id target = [_target1 methodSignatureForSelector:[invocation selector]] ? _target1 : _target2;</div><div class="line">    [invocation invokeWithTarget:target];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector &#123;</div><div class="line">    if ([_target1 respondsToSelector:aSelector]) return YES;</div><div class="line">    if ([_target2 respondsToSelector:aSelector]) return YES;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>接下来，我们在外部使用这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;AppDelegate.h&quot;</div><div class="line">#import &quot;MyProxy.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        NSMutableString *string = [NSMutableString string];</div><div class="line">        NSMutableArray *array = @[].mutableCopy;</div><div class="line">        </div><div class="line">        id proxy = [[MyProxy alloc] initWithTarget1:string target2:array];</div><div class="line">        </div><div class="line">        [proxy appendString:@&quot;iOS&quot;];</div><div class="line">        </div><div class="line">        [proxy addObject:@1];</div><div class="line">        </div><div class="line">        NSLog(@&quot;string:%@\narray:%@&quot;,string,array);</div><div class="line">        </div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为 MyProxy 传入两个为 NSMutableString 与 NSMutableArray的实例对象。proxy 本身并没有<code>appendString：</code> 和 <code>addObject：</code>方法 ，但运行不会产生崩溃，因为proxy 调用的任何方法都会被转发，被 string 与 array 调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2017-04-02 10:37:34.651 MyProxyDemo[1752:40883] string:iOS</div><div class="line">array:(</div><div class="line">    1</div><div class="line">)</div></pre></td></tr></table></figure>
<p>但是假如，我们用 proxy 调用这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[proxy setObject:@&quot;Jane&quot; forKey:@&quot;name&quot;];</div></pre></td></tr></table></figure>
<p>就是产生崩溃，因为这个方法要转发给的对象 string ，array 都不能响应这个方法。</p>
<p>关于 NSProxy 的使用，<a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m" target="_blank" rel="external">YYWeakProxy</a>也用这个类实现了弱引用，有兴趣的话可以看下。</p>
<p>关于 Runtime 的消息转发就写到这里，确实，Runtime的确强大，我们可以用它做很多事情。虽然学的过程是痛苦的，也许为了弄清某一个非常小的知识点，需要花费很多时间，查阅很多资料，但最后学到的都是自己的，都是值得的。不进步，就相当于退步。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ocauxqtbu.bkt.clouddn.com/27563317749u=2381918280,2871499884&fm=21&gp=0.jpg"
               alt="Zhou Jian" />
          <p class="site-author-name" itemprop="name">Zhou Jian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coderZhou10496" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Jian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"coderzhou"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Bw40KBIPanRkt0iqTr7NLT6I-gzGzoHsz", "MQjFPSYkEazqnUv2rS7TOsui");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
